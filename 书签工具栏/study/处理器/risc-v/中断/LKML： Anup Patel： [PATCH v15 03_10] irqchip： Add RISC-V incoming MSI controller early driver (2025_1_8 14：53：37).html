<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"> <html xmlns=http://www.w3.org/1999/xhtml style><!--
 Page saved with SingleFile 
 url: https://lkml.org/lkml/2024/2/26/193 
 saved date: Wed Jan 08 2025 14:53:37 GMT+0800 (中国标准时间)
--><meta charset=utf-8><title>LKML: Anup Patel: [PATCH v15 03/10] irqchip: Add RISC-V incoming MSI controller early driver</title><style>body{margin:0em 0em 0em 0em;background-image:url(data:image/gif;base64,R0lGODlhIAAgAPABAM7l5eXl5SH5BAAAAAAALAAAAAAgACAAAAL+BAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECTJgwYcKECRMmTJgwYcKECRMmTJgwYcKECRMmTJgwYcKECRMmBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECTJgwYcKECRMmTJgwYcKECRMmTJgwYcKECRMmTJgwYcKECRMmBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECTJgwYcKECRMmTJgwYcKECRMmTJgwYcKECRMmTJgwYcKECRMmBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECTJj+MGHChAkTJkyYMGHChAkTJkyYMGHChAkTJkyYMGHChAkTJgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAkyYMGHChAkTJkyYMGHChAkTJkyYMGHChAkTJkyYMGHChAkTJgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAkyYMGHChAkTJkyYMGHChAkTJkyYMGHChAkTJkyYMGHChAkTJgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAkyYMGHChAkTJkyYMGHChAkTJkyYMGHChAkTJkyYMGHChAkTJgQIECBFQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQJMmDBhwoQJEyZMmDBhwoQJEyZMmDBhwoQJEyZMmDBhwoQJEyYFADs=)}.es-jasper-simpleCalendar{font-size:80%;text-align:center}td.c{background-image:url(data:image/gif;base64,R0lGODlhEAAQAOMAAM3Y2M3Z2c3a2s3b28/Z2c3c3M3d3c3e3s7f39Lb2////////////////////////yH5BAEKAA8ALAAAAAAQABAAAAQREMhJq7046827/2AojmRpThEAOw==);color:#000000;padding:0px 0px}td.lm{font-size:80%}td.lp{font-family:courier,monospace;font-weight:bold;padding:0em 1em 0em 0em;margin:0em}td.rp{font-family:courier,monospace;font-weight:normal}td.nb{font-size:90%}a.nb:hover{text-decoration:underline}a.nb:visited{color:#000000}div.threadlist{text-align:center}ul.threadlist{list-style-position:outside;margin-left:0.75em;padding-left:0.75em;font-size:80%}ul.threadlist ul{font-size:100%;list-style-position:outside;margin-left:0.50em;padding-left:0em}ul.threadlist li.origin>a{font-weight:bold;font-style:normal}ul.threadlist li{list-style:disc}ul.threadlist li.origin{list-style:square}ul.threadlist li a,td.lm a,td.nb a{text-decoration:none;font-style:italic;background-color:inherit;color:#000}ul.threadlist li a:hover,td.lm a:hover,td.nb a:hover{text-decoration:underline}</style><style>a.nowrap{display:inline}</style><link rel=alternate type=application/rss+xml title="lkml.org : last 100 messages" href=https://lkml.org/rss.php><link rel=alternate type=application/rss+xml title="lkml.org : last messages by Anup Patel" href="https://lkml.org/groupie.php?aid="><meta name=referrer content=no-referrer><link href=data:image/vnd.microsoft.icon;base64,AAABAAEAEBAQAAAAAAAoAQAAFgAAACgAAAAQAAAAIAAAAAEABAAAAAAAgAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAA/wAAAAAA/wAAlQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgARERAAAgICABAAAAACAgIAEAAAAAICAgAQAAAAAgICABAAAAACICIAEAAAAAAAAAAAAAAAAAAAAAAAAAABEREAMAMAAAEAAAAwMAAAAQAAADMAAAABAAAAMwAAAAEAAAAwMAAAAQAAADADAAAAAAAAAAAAD//wAA1YMAANW/AADVvwAA1b8AANW/AADJvwAA//8AAP//AADBtwAA368AAN+fAADfnwAA368AAN+3AAD//wAA rel="shortcut icon"><style>.sf-hidden{display:none!important}</style><link rel=canonical href=https://lkml.org/lkml/2024/2/26/193><meta http-equiv=content-security-policy content="default-src 'none'; font-src 'self' data:; img-src 'self' data:; style-src 'unsafe-inline'; media-src 'self' data:; script-src 'unsafe-inline' data:; object-src 'self' data:; frame-src 'self' data:;"><body itemscope itemtype=http://schema.org/BlogPosting><table border=0 cellpadding=0 cellspacing=0><tbody><tr><td width=180 align=center><a href=https://lkml.org/><img style=border:0;width:135px;height:32px src="data:image/gif;base64,R0lGODlhhwAgAPZmAAAAABcaGhgaGhoaGhsbGxwcHB0dHS4zMy8zMzMzMzE0NDU2NjY2Njc4ODk5OURMTEZNTUhOTkpPT0xMTE1NTUtQUE9SUlJSUlRUVFVVVVxmZmZmZmdnZ2BoaGNpaWVra2lpaWtra2hsbGptbW1tbXBwcHJycnJ/f39/f3WAgHiCgoODg4eHh4qMjI6OjomYmIyampCcnJSenpiYmJqamp6enpegoJ6kpKKioqSkpKampqaoqKioqKqqqqCysrKysrS0tLu7u7m/v729vb+/v7fLy77CwsLExMTExMfHx8vLy83NzdDQ0NPa2tra2tnd3d3d3c7l5dPn593g4Njq6t7t7eDg4OPj4+Xl5efn5+rq6u3t7ePw8Onz8+729vDw8PPz8/b29vT5+fn5+fn8/Pz8/P///////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAGcALAAAAACHACAAAAf+gFFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUYBRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVH+gFFRUVFRUVFRUVFRUVFRUVFRUVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWIBYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFj+gFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUYBRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUUUvLy9FUVFRUVFRUS8vLz5RUVFRUT4vLy8+UVEvLy8vL1FRUVFRUVFRUVE+Ly8vL0VRUT4vLy9RUVFRUVFRUVFRUVFRUVFRUVFRUVH+gFE+Ly8vRVFRUVFRUVFRUVEvLy8vLy8vL0VRUVFRUVFRUVFRUVFRPi8vL1FRUVFRUVFRUVFRUVhYWFhYMwAAADNYWFhYWFhYAAAAE1hYWFhKAwAAADNYWAAAAAAAM1hYWFhYWFhYWAAAAAAAM1hYEwAAAFhYWFhYWFhYWFhYWIBYWFhYWFhYPxMAAAAAAAADKFhYWFhYWFhYAAAAAAAAAAAACT9YWFhYWFhYWD8TAAAAAAAACShYWFhYWFhYWFhYWFhYWDMAAAAzWFhYWFhYWAAAABNYWFhYEwAAABtYWFgAAAAAABNYWFhYWFhYWDMAAAAAADNYWBMAAABYWFj+gFhYWFhYWFhYWFhYWFhYShMAAAAAAAAAAAAAAzNYWFhYWFgAAAAAAAAAAAAAADNYWFhYWEoTAAAAAAAAAAAAAAMzWFhYWFhYWFFRUVFRLwAAADJVUlFRUVFRAAAAEVVUUS8AAAARVVVVVAAAAAAAAFVRUVFRUVFRDwAAAAAAMoBVUg8AAABVVVFRUVFRUVFRUVFRUVFRRQEAAAAAAAAAAAAAAAAAL1FRUVFRAAAAAAAAAAAAAAAARVFRUUUBAAAAAAAAAAAAAAAAABpRUVFRUVFRUVFRUS8AAAA9ZlVRUVFRUQAAABlmXkUAAAABU2ZmZlUAAAAAAAA9VVFRUVH+gFFRAAAAAAAAPWZVDwAAAGZmUVFRUVFRUVFRUVFRUUUBAAAAAB5CZmZXLgYAAAAAL1FRUVEAAAAZZmZmSQ4AAAAeUVFFAQAAAAEqQmZmVy4GAAAAAC9RUVFRUVhYWFhYMwAAAD1mW1hYWFhYAAAAGWZhCQAAAERmZmZgWAAAAIAAAAAOYVhYWFhYMwAAAAAAAD1mWxMAAABmZlhYWFhYWFhYWFhYWFgTAAAAA05mZmZmZmZmGQAAAANKWFhYAAAAGWZmZmZmBgAABltYEwAAABNOZmZmZmZmZhkAAAAASlhYWFhYWFhYWDMAAAA9ZltYWFhYWAAAABlmJAAAACv+gGZmZmFYWAAAABkAAABXWFhYWFgTAAAXAAAAPWZbEwAAAGZmWFhYWFhYWFhYWFhYPwAAAANXZmZmZmZmZmZmGQAAACBYWFgAAAAZZmZmZmYZAAAAZj8AAAADV2ZmZmZmZmZmZiYZGRc4WFhYWFFRUVFRLwAAAD1mVVFRUVFRAIAAABlJAAAAD2ZmZmRSUVEAAAAZGQAALlVRUVFFAAAAPQAAAD1mVQ8AAABmZlFRUVFRUVFRUVFRURoAAAAtZmZmZl1UUVFSXFMAAAAGVVFRAAAAGWZeUVFREQAAAGYjAAAALWZmZmJcVFFRUlxkZmZmZlVRUVFRUVFRUS8AAAD+gD1mVVFRUVFRAAAADgYAAAFPZmZmVFFRUQAAABk9AAAOYlFRUScAABE9AAAAPWZVDwAAAGZmUVFRUVFRUVFRUVFRBwAAAGZmZmRSUVFRUVFRURYAAABHUlEAAAAZZl5RUUUAAAAOZg0AAABmZmZeUlFRUVFRUVFeZmZmZlJRUYBYWFhYWDMAAAA9ZltYWFhYWAAAAAAAAABEZmZmYFhYWFgAAAAZZgAAAFdYWFgJAABEPQAAAD1mWxMAAABmZlhYWFhYWFhYWFhYWAAAABlmZmNYWFhYWFhYWFgzAAAAPWBYAAAAGWZOMygDAAAALmYAAAAZZmZmWFhYWFhYWFj+gFhYYGFhYVtYWFhYWFhYMwAAAD1mW1hYWFhYAAAAAAAAA1dmZmFYWFhYWAAAABlmJAAALmBYSgAAA2Y9AAAAPWZbEwAAAGZmWFhYWFhYWFhYWFhYAAAAGWZmYFhYWFhYWFhYWDMAAAA9ZlgAAAAAAAAAAAAAAANmZgAAABlmZoBgWBMTExMTExMTExMTEyhYWFhRUVFRUS8AAAA9ZlVRUVFRUQAAAAYAAAAZZmRSUVFRUVEAAAAZZkIAAAZiUScAAB9mPQAAAD1mVQ8AAABmZlFRUVFRUVFRUVFRUQAAAA5mZlFRUVFRUVFRUVEvAAAAPWZUAAAAAAAAAAAAAAf+gFdmZgAAAA5mZlFRAAAAAAAAAAAAAAAAD1FRUVFRUVFRLwAAAD1mVVFRUVFRAAAAGRkAAAA9VFFRUVFRUQAAABlmXgEAAElSBwAARmY9AAAAPWZVDwAAAGZmUVFRUVFRUVFRUVFRDwAAAFdeUVFRUVFRUVFRUQ8AAABXZlUAAIAABgAAAAAWMmRmZmYRAAAAV15RUQAAAAAAAAAAAAAAAC9RUVFYWFhYWDMAAAA9ZltYWFhYWAAAABlXBgAAAEtYWFhYWFgAAAAZZmEbAAAmQQAAA2ZmPQAAAD1mWxMAAABmZlhYWFhYWFhYWFhYWCgAAAAmYVhYWFhYWFhYWEr+gAAAAA5mZlsAAAAZGQAAAD1mZmZmZigAAAAmYVhYExMXFxcXFxcAAAAATmFgWFhYWFhYMwAAAD1mW1hYWFhYAAAAF2ZJAAAAA1hYWFhYWAAAABlmYT8AAAYmAAAgZmY4AAAAPWZbEwAAAGZmWFhYWFhYWFhYWFhYSgAAAAA6WIBYWFhYWFhYWAkAAAAuZmZbAAAAGVcGAAAAV2ZmY1pYAwAAADpYWFhYZmZmZmYZAAAADmZmYVhRUVFRUS8AAAA9ZlVRUVFRUQAAABlmXiMAAAARUVFRUVEAAAAZZl5RAQAABgAARmZmMAAAAD1mVQ8AAABmZlFRUVFRUVFRUVH+gFFRUScAAAAAKVFRUVFRUUUHAAAAA2ZmZlIAAAAZZjsAAAAGXlVRUVEnAAAAAClRUVFmZmZXGQAAAABXZmZVUVFRUVFRLwAAACY9Mi8vL0VRAAAAGWZeUgYAAAAwUVFRUQAAABlmXlEaAAAAAANmZmMvAAAAPWZVDwAAAD09L4AvLy9RUS8vL0VRUVFRFQAAAAABGi8vJw8AAAAAAVhmZmJRAAAAGWZeFgAAABFRUVFRURUAAAAAARovNzcWAAAAAAA9ZmZmUlFYWFhYWDMAAAAAAAAAAAAzWAAAABlmYVhMAAAAA0tYWFgAAAAZZmFYPwAAAAAsZmZhMwAAAD3+gGZbEwAAAAAAAAAAAFhYAAAAM1hYWFhYGQAAAAAAAAAAAAAAAANQZmZmW1gAAAAZZmFLBgAAADNYWFhYWBkAAAAAAAAAAAAAAAAAOmZmZmNYWFhYWFhYMwAAAAAAAAAAADNYAAAAGWZhWFgsAAAADFhYWAAAABlmYVhYCQAAAIBXZmZaMwAAAD1mWxMAAAAAAAAAAABYWAAAADNYWFhYWGA9BgAAAAAAAAAAABtQZmZmZlhYAAAAGWZhWDUAAAAAS1hYWFhgPQYAAAAAAAAAAAADRGZmZmZYWFhRUVFRUS8AAAAAAAAAAAAyVQAAABlmXlFRUQwAAAAeUVEAAAD+gBlmXlFRJwAADmZmZFEvAAAAPWZVDwAAAAAAAAAAAFVVAAAAMlVSUVFRUV5mPRkGAAAAER9NZmZmZmRSUVEAAAAZZl5RURYAAAAMUVFRUVFeZj0ZDAAAAAoRQmZmZmZmVVFRUVFRUVFRUVFVZmZmZmZmZmZmVVFmZmZeUVFRUoBmZmZkUlFRUWZmZl5RUVFUZmZmZlxRUVFVZmZmVVFRXmZmZmZmZmZmZlFRZmZmVVFRUVFRXmZmZmZmZmZmZmZmZmRSUVFRUVFmZmZeUVFSZGZmZlVRUVFRUV5mZmZmZmZmZmZmZmZmVVFRUVFYWFhYWFhYW2ZmZmZmZmZmZlv+gFhmZmZhWFhYWGBmZmZjWFhYZmZmYVhYWFhjZmZmWFhYWFtmZmZbWFhhZmZmZmZmZmZmWFhmZmZbWFhYWFhYW2ZmZmZmZmZmZmZgWFhYWFhYWGZmZmFYWFhbZmZmZlhYWFhYWFtmZmZmZmZmZmZmZlpYWFhYWFhYWFhYWFhbZoBmZmZmZmZmZltYZmZmYVhYWFhYY2ZmZmBYWGZmZmFYWFhYYGZmY1hYWFhbZmZmW1hYYWZmZmZmZmZmZlhYZmZmW1hYWFhYWFhYW2FjZmZmYWFYWFhYWFhYWFhmZmZhWFhYWGFmZmZjWFhYWFhYWFthY2ZmZmNhWlhYWFhYWFj+gFFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUYBRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVFRUVH+gFFRUVFRUVFRUVFRUVFRUVFRUVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWIBYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFgmgFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWIEAOw==" alt=lkml.org></a><td width=32>&nbsp;<td class=nb><div><a class=nb href=https://lkml.org/lkml>
 [lkml]</a>
 &nbsp;
<a class=nb href=https://lkml.org/lkml/2024>
 [2024]</a>
 &nbsp;
<a class=nb href=https://lkml.org/lkml/2024/2>
 [Feb]</a>
 &nbsp;
<a class=nb href=https://lkml.org/lkml/2024/2/26>
 [26]</a>
 &nbsp;
<a class=nb href=https://lkml.org/lkml/last100>
 [last100]</a>
 &nbsp;
<a href=https://lkml.org/rss.php><img src="data:image/gif;base64,R0lGODlhJAAOANUAANVYBPHUwOFdBP/28P9yFeCngvfp4OVeBPRkBe3JsfBjBfr079+ecv+rc/fg0NByM+e9of/j0Z9BA//m1eWEQ/+FNP/awc5VBM1nI//t4eezkeirgtRhFPBsFOR3Lt1uJPDBofjXwf98JOZ7M/PCofqWU/CugiEOAfmygv/Rsv+PRP+0gn0zAv+aV8JQBD8aAf/IpP////9mAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAAJAAOAAAG8sAIbEgsGo/II6YlazYRMgTU6ZQKpNSrgBpllaiUB2Z8AVxlHQwEUsCYZYA1BOM6N73UmH5vkJj3exIuEIAxfVt3X056ECwaeiwYjC8SGAMShDEvLIMGLFR4i5qCA4Ysk3QuHIQDLIKCWIl5ppmUpXoDfS6SgIJ2MqFNhTGuCC4Gt5BjyTEQEojAisLNtRIdxqqZjXQXlnov0MEyeienypcuLhIGmgPO6RIxreHS48QSErfmhrcvmeyQ6jgJJmANhg4y1EBgoMYAO1ccMDl0V+kDqHoCVE0B4KLMBXWVEMIBKYHDlIESXqhcybKly5cuTwQBADs=" border=0 alt="RSS Feed"></a></div><div>Views:
<a href=# class=nowrap>[wrap]</a><a href=# class="wrap sf-hidden">[no wrap]</a>
&nbsp;
<a class=nb href=https://lkml.org/lkml/mheaders/2024/2/26/193>[headers]</a>&nbsp;
<a href=https://lkml.org/lkml/bounce/2024/2/26/193>[forward]</a>&nbsp;
 </div><td width=32>&nbsp;<tr><td valign=top><div class=es-jasper-simpleCalendar baseurl=/lkml/></div><div class=threadlist>Messages in this thread</div><ul class=threadlist><li class=root><a href=https://lkml.org/lkml/2024/2/26/190>First message in thread</a><li><a href=https://lkml.org/lkml/2024/2/26/190>Anup Patel</a><ul><li><a href=https://lkml.org/lkml/2024/2/26/191>Anup Patel</a><ul><li><a href=https://lkml.org/lkml/2024/2/26/1228>"tip-bot2 for Anup Patel"</a><li><a href=https://lkml.org/lkml/2024/2/27/1408>"tip-bot2 for Anup Patel"</a></ul><li><a href=https://lkml.org/lkml/2024/2/26/192>Anup Patel</a><li class=origin><a href=https://lkml.org/lkml/2024/2/26/193>Anup Patel</a><li><a href=https://lkml.org/lkml/2024/2/26/194>Anup Patel</a><li><a href=https://lkml.org/lkml/2024/2/26/195>Anup Patel</a><li><a href=https://lkml.org/lkml/2024/2/26/196>Anup Patel</a><li><a href=https://lkml.org/lkml/2024/2/26/197>Anup Patel</a><li><a href=https://lkml.org/lkml/2024/2/26/198>Anup Patel</a><ul><li><a href=https://lkml.org/lkml/2024/3/5/1594>Samuel Holland</a><ul><li><a href=https://lkml.org/lkml/2024/3/6/247>Anup Patel</a></ul><li><a href=https://lkml.org/lkml/2024/3/6/1038>=?utf-8?B?QmrDtnJuIFTDtnBlbA==?=</a><ul><li><a href=https://lkml.org/lkml/2024/3/7/999>=?utf-8?B?QmrDtnJuIFTDtnBlbA==?=</a><ul><li><a href=https://lkml.org/lkml/2024/3/7/1025>Anup Patel</a></ul></ul></ul><li><a href=https://lkml.org/lkml/2024/2/26/199>Anup Patel</a><li><a href=https://lkml.org/lkml/2024/2/26/200>Anup Patel</a><li><a href=https://lkml.org/lkml/2024/2/26/203>Anup Patel</a></ul></ul><div class=threadlist>Patch in this message</div><ul class=threadlist><li><a href=https://lkml.org/lkml/diff/2024/2/26/193/1>Get diff 1</a></ul><td width=32 rowspan=2 class=c valign=top><img src=data:image/gif;base64,R0lGODlhIAAgAKEAAM7l5eXl5f///////yH5BAEKAAIALAAAAAAgACAAAAJShI+pKy0Lo5si2Iuzplz7zIVPpIgimZjiB6ora7kmKs9S/Xq4+e126jsBg6ENsYg5Cg/KEKKJDECjU46hagVgKbGto+t9hB3accV8NpfR7Pa4AAA7 width=32 height=32 alt=/><td class=c rowspan=2 valign=top style=padding-top:1em><table><tbody><tr><td><table><tbody><tr><td class=lp>From<td class=rp itemprop=author>Anup Patel &lt;&gt;<tr><td class=lp>Subject<td class=rp itemprop=name>[PATCH v15 03/10] irqchip: Add RISC-V incoming MSI controller early driver<tr><td class=lp>Date<td class=rp itemprop=datePublished>Mon, 26 Feb 2024 09:37:39 +0530</table><td></table><pre itemprop=articleBody>The RISC-V advanced interrupt architecture (AIA) specification<br>defines a new MSI controller called incoming message signalled<br>interrupt controller (IMSIC) which manages MSI on per-HART (or<br>per-CPU) basis. It also supports IPIs as software injected MSIs.<br>(For more details refer <a href=https://github.com/riscv/riscv-aia>https://github.com/riscv/riscv-aia</a>)<br><br>Add an early irqchip driver for RISC-V IMSIC which sets up the<br>IMSIC state and provide IPIs.<br><br>Signed-off-by: Anup Patel &lt;apatel@ventanamicro.com&gt;<br>---<br> drivers/irqchip/Kconfig                 |   7 +<br> drivers/irqchip/Makefile                |   1 +<br> drivers/irqchip/irq-riscv-imsic-early.c | 201 ++++++<br> drivers/irqchip/irq-riscv-imsic-state.c | 865 ++++++++++++++++++++++++<br> drivers/irqchip/irq-riscv-imsic-state.h | 107 +++<br> include/linux/cpuhotplug.h              |   1 +<br> include/linux/irqchip/riscv-imsic.h     |  87 +++<br> 7 files changed, 1269 insertions(+)<br> create mode 100644 drivers/irqchip/irq-riscv-imsic-early.c<br> create mode 100644 drivers/irqchip/irq-riscv-imsic-state.c<br> create mode 100644 drivers/irqchip/irq-riscv-imsic-state.h<br> create mode 100644 include/linux/irqchip/riscv-imsic.h<br><br>diff --git a/drivers/irqchip/Kconfig b/drivers/irqchip/Kconfig<br>index f7149d0f3d45..85f86e31c996 100644<br>--- a/drivers/irqchip/Kconfig<br>+++ b/drivers/irqchip/Kconfig<br>@@ -546,6 +546,13 @@ config SIFIVE_PLIC<br> 	select IRQ_DOMAIN_HIERARCHY<br> 	select GENERIC_IRQ_EFFECTIVE_AFF_MASK if SMP<br> <br>+config RISCV_IMSIC<br>+	bool<br>+	depends on RISCV<br>+	select IRQ_DOMAIN_HIERARCHY<br>+	select GENERIC_IRQ_MATRIX_ALLOCATOR<br>+	select GENERIC_MSI_IRQ<br>+<br> config EXYNOS_IRQ_COMBINER<br> 	bool "Samsung Exynos IRQ combiner support" if COMPILE_TEST<br> 	depends on (ARCH_EXYNOS &amp;&amp; ARM) || COMPILE_TEST<br>diff --git a/drivers/irqchip/Makefile b/drivers/irqchip/Makefile<br>index ffd945fe71aa..d714724387ce 100644<br>--- a/drivers/irqchip/Makefile<br>+++ b/drivers/irqchip/Makefile<br>@@ -95,6 +95,7 @@ obj-$(CONFIG_QCOM_MPM)			+= irq-qcom-mpm.o<br> obj-$(CONFIG_CSKY_MPINTC)		+= irq-csky-mpintc.o<br> obj-$(CONFIG_CSKY_APB_INTC)		+= irq-csky-apb-intc.o<br> obj-$(CONFIG_RISCV_INTC)		+= irq-riscv-intc.o<br>+obj-$(CONFIG_RISCV_IMSIC)		+= irq-riscv-imsic-state.o irq-riscv-imsic-early.o<br> obj-$(CONFIG_SIFIVE_PLIC)		+= irq-sifive-plic.o<br> obj-$(CONFIG_IMX_IRQSTEER)		+= irq-imx-irqsteer.o<br> obj-$(CONFIG_IMX_INTMUX)		+= irq-imx-intmux.o<br>diff --git a/drivers/irqchip/irq-riscv-imsic-early.c b/drivers/irqchip/irq-riscv-imsic-early.c<br>new file mode 100644<br>index 000000000000..886418ec06cb<br>--- /dev/null<br>+++ b/drivers/irqchip/irq-riscv-imsic-early.c<br>@@ -0,0 +1,201 @@<br>+// SPDX-License-Identifier: GPL-2.0<br>+/*<br>+ * Copyright (C) 2021 Western Digital Corporation or its affiliates.<br>+ * Copyright (C) 2022 Ventana Micro Systems Inc.<br>+ */<br>+<br>+#define pr_fmt(fmt) "riscv-imsic: " fmt<br>+#include &lt;linux/cpu.h&gt;<br>+#include &lt;linux/interrupt.h&gt;<br>+#include &lt;linux/io.h&gt;<br>+#include &lt;linux/irq.h&gt;<br>+#include &lt;linux/irqchip.h&gt;<br>+#include &lt;linux/irqchip/chained_irq.h&gt;<br>+#include &lt;linux/module.h&gt;<br>+#include &lt;linux/spinlock.h&gt;<br>+#include &lt;linux/smp.h&gt;<br>+<br>+#include "irq-riscv-imsic-state.h"<br>+<br>+static int imsic_parent_irq;<br>+<br>+#ifdef CONFIG_SMP<br>+static void imsic_ipi_send(unsigned int cpu)<br>+{<br>+	struct imsic_local_config *local = per_cpu_ptr(imsic-&gt;global.local, cpu);<br>+<br>+	writel_relaxed(IMSIC_IPI_ID, local-&gt;msi_va);<br>+}<br>+<br>+static void imsic_ipi_starting_cpu(void)<br>+{<br>+	/* Enable IPIs for current CPU. */<br>+	__imsic_id_set_enable(IMSIC_IPI_ID);<br>+}<br>+<br>+static void imsic_ipi_dying_cpu(void)<br>+{<br>+	/* Disable IPIs for current CPU. */<br>+	__imsic_id_clear_enable(IMSIC_IPI_ID);<br>+}<br>+<br>+static int __init imsic_ipi_domain_init(void)<br>+{<br>+	int virq;<br>+<br>+	/* Create IMSIC IPI multiplexing */<br>+	virq = ipi_mux_create(IMSIC_NR_IPI, imsic_ipi_send);<br>+	if (virq &lt;= 0)<br>+		return virq &lt; 0 ? virq : -ENOMEM;<br>+<br>+	/* Set vIRQ range */<br>+	riscv_ipi_set_virq_range(virq, IMSIC_NR_IPI, true);<br>+<br>+	/* Announce that IMSIC is providing IPIs */<br>+	pr_info("%pfwP: providing IPIs using interrupt %d\n", imsic-&gt;fwnode, IMSIC_IPI_ID);<br>+<br>+	return 0;<br>+}<br>+#else<br>+static void imsic_ipi_starting_cpu(void) { }<br>+static void imsic_ipi_dying_cpu(void) { }<br>+static int __init imsic_ipi_domain_init(void) { return 0; }<br>+#endif<br>+<br>+/*<br>+ * To handle an interrupt, we read the TOPEI CSR and write zero in one<br>+ * instruction. If TOPEI CSR is non-zero then we translate TOPEI.ID to<br>+ * Linux interrupt number and let Linux IRQ subsystem handle it.<br>+ */<br>+static void imsic_handle_irq(struct irq_desc *desc)<br>+{<br>+	struct irq_chip *chip = irq_desc_get_chip(desc);<br>+	int err, cpu = smp_processor_id();<br>+	struct imsic_vector *vec;<br>+	unsigned long local_id;<br>+<br>+	chained_irq_enter(chip, desc);<br>+<br>+	while ((local_id = csr_swap(CSR_TOPEI, 0))) {<br>+		local_id &gt;&gt;= TOPEI_ID_SHIFT;<br>+<br>+		if (local_id == IMSIC_IPI_ID) {<br>+			if (IS_ENABLED(CONFIG_SMP))<br>+				ipi_mux_process();<br>+			continue;<br>+		}<br>+<br>+		if (unlikely(!imsic-&gt;base_domain))<br>+			continue;<br>+<br>+		vec = imsic_vector_from_local_id(cpu, local_id);<br>+		if (!vec) {<br>+			pr_warn_ratelimited("vector not found for local ID 0x%lx\n", local_id);<br>+			continue;<br>+		}<br>+<br>+		err = generic_handle_domain_irq(imsic-&gt;base_domain, vec-&gt;hwirq);<br>+		if (unlikely(err))<br>+			pr_warn_ratelimited("hwirq 0x%x mapping not found\n", vec-&gt;hwirq);<br>+	}<br>+<br>+	chained_irq_exit(chip, desc);<br>+}<br>+<br>+static int imsic_starting_cpu(unsigned int cpu)<br>+{<br>+	/* Mark per-CPU IMSIC state as online */<br>+	imsic_state_online();<br>+<br>+	/* Enable per-CPU parent interrupt */<br>+	enable_percpu_irq(imsic_parent_irq, irq_get_trigger_type(imsic_parent_irq));<br>+<br>+	/* Setup IPIs */<br>+	imsic_ipi_starting_cpu();<br>+<br>+	/*<br>+	 * Interrupts identities might have been enabled/disabled while<br>+	 * this CPU was not running so sync-up local enable/disable state.<br>+	 */<br>+	imsic_local_sync_all();<br>+<br>+	/* Enable local interrupt delivery */<br>+	imsic_local_delivery(true);<br>+<br>+	return 0;<br>+}<br>+<br>+static int imsic_dying_cpu(unsigned int cpu)<br>+{<br>+	/* Cleanup IPIs */<br>+	imsic_ipi_dying_cpu();<br>+<br>+	/* Mark per-CPU IMSIC state as offline */<br>+	imsic_state_offline();<br>+<br>+	return 0;<br>+}<br>+<br>+static int __init imsic_early_probe(struct fwnode_handle *fwnode)<br>+{<br>+	struct irq_domain *domain;<br>+	int rc;<br>+<br>+	/* Find parent domain and register chained handler */<br>+	domain = irq_find_matching_fwnode(riscv_get_intc_hwnode(), DOMAIN_BUS_ANY);<br>+	if (!domain) {<br>+		pr_err("%pfwP: Failed to find INTC domain\n", fwnode);<br>+		return -ENOENT;<br>+	}<br>+	imsic_parent_irq = irq_create_mapping(domain, RV_IRQ_EXT);<br>+	if (!imsic_parent_irq) {<br>+		pr_err("%pfwP: Failed to create INTC mapping\n", fwnode);<br>+		return -ENOENT;<br>+	}<br>+<br>+	/* Initialize IPI domain */<br>+	rc = imsic_ipi_domain_init();<br>+	if (rc) {<br>+		pr_err("%pfwP: Failed to initialize IPI domain\n", fwnode);<br>+		return rc;<br>+	}<br>+<br>+	/* Setup chained handler to the parent domain interrupt */<br>+	irq_set_chained_handler(imsic_parent_irq, imsic_handle_irq);<br>+<br>+	/*<br>+	 * Setup cpuhp state (must be done after setting imsic_parent_irq)<br>+	 *<br>+	 * Don't disable per-CPU IMSIC file when CPU goes offline<br>+	 * because this affects IPI and the masking/unmasking of<br>+	 * virtual IPIs is done via generic IPI-Mux<br>+	 */<br>+	cpuhp_setup_state(CPUHP_AP_IRQ_RISCV_IMSIC_STARTING, "irqchip/riscv/imsic:starting",<br>+			  imsic_starting_cpu, imsic_dying_cpu);<br>+<br>+	return 0;<br>+}<br>+<br>+static int __init imsic_early_dt_init(struct device_node *node, struct device_node *parent)<br>+{<br>+	struct fwnode_handle *fwnode = &amp;node-&gt;fwnode;<br>+	int rc;<br>+<br>+	/* Setup IMSIC state */<br>+	rc = imsic_setup_state(fwnode);<br>+	if (rc) {<br>+		pr_err("%pfwP: failed to setup state (error %d)\n", fwnode, rc);<br>+		return rc;<br>+	}<br>+<br>+	/* Do early setup of IPIs */<br>+	rc = imsic_early_probe(fwnode);<br>+	if (rc)<br>+		return rc;<br>+<br>+	/* Ensure that OF platform device gets probed */<br>+	of_node_clear_flag(node, OF_POPULATED);<br>+	return 0;<br>+}<br>+<br>+IRQCHIP_DECLARE(riscv_imsic, "riscv,imsics", imsic_early_dt_init);<br>diff --git a/drivers/irqchip/irq-riscv-imsic-state.c b/drivers/irqchip/irq-riscv-imsic-state.c<br>new file mode 100644<br>index 000000000000..5479f872e62b<br>--- /dev/null<br>+++ b/drivers/irqchip/irq-riscv-imsic-state.c<br>@@ -0,0 +1,865 @@<br>+// SPDX-License-Identifier: GPL-2.0<br>+/*<br>+ * Copyright (C) 2021 Western Digital Corporation or its affiliates.<br>+ * Copyright (C) 2022 Ventana Micro Systems Inc.<br>+ */<br>+<br>+#define pr_fmt(fmt) "riscv-imsic: " fmt<br>+#include &lt;linux/cpu.h&gt;<br>+#include &lt;linux/bitmap.h&gt;<br>+#include &lt;linux/interrupt.h&gt;<br>+#include &lt;linux/irq.h&gt;<br>+#include &lt;linux/module.h&gt;<br>+#include &lt;linux/of.h&gt;<br>+#include &lt;linux/of_address.h&gt;<br>+#include &lt;linux/of_irq.h&gt;<br>+#include &lt;linux/seq_file.h&gt;<br>+#include &lt;linux/spinlock.h&gt;<br>+#include &lt;linux/smp.h&gt;<br>+#include &lt;asm/hwcap.h&gt;<br>+<br>+#include "irq-riscv-imsic-state.h"<br>+<br>+#define IMSIC_DISABLE_EIDELIVERY		0<br>+#define IMSIC_ENABLE_EIDELIVERY			1<br>+#define IMSIC_DISABLE_EITHRESHOLD		1<br>+#define IMSIC_ENABLE_EITHRESHOLD		0<br>+<br>+static inline void imsic_csr_write(unsigned long reg, unsigned long val)<br>+{<br>+	csr_write(CSR_ISELECT, reg);<br>+	csr_write(CSR_IREG, val);<br>+}<br>+<br>+static inline unsigned long imsic_csr_read(unsigned long reg)<br>+{<br>+	csr_write(CSR_ISELECT, reg);<br>+	return csr_read(CSR_IREG);<br>+}<br>+<br>+static inline unsigned long imsic_csr_read_clear(unsigned long reg, unsigned long val)<br>+{<br>+	csr_write(CSR_ISELECT, reg);<br>+	return csr_read_clear(CSR_IREG, val);<br>+}<br>+<br>+static inline void imsic_csr_set(unsigned long reg, unsigned long val)<br>+{<br>+	csr_write(CSR_ISELECT, reg);<br>+	csr_set(CSR_IREG, val);<br>+}<br>+<br>+static inline void imsic_csr_clear(unsigned long reg, unsigned long val)<br>+{<br>+	csr_write(CSR_ISELECT, reg);<br>+	csr_clear(CSR_IREG, val);<br>+}<br>+<br>+struct imsic_priv *imsic;<br>+<br>+const struct imsic_global_config *imsic_get_global_config(void)<br>+{<br>+	return imsic ? &amp;imsic-&gt;global : NULL;<br>+}<br>+EXPORT_SYMBOL_GPL(imsic_get_global_config);<br>+<br>+static bool __imsic_eix_read_clear(unsigned long id, bool pend)<br>+{<br>+	unsigned long isel, imask;<br>+<br>+	isel = id / BITS_PER_LONG;<br>+	isel *= BITS_PER_LONG / IMSIC_EIPx_BITS;<br>+	isel += pend ? IMSIC_EIP0 : IMSIC_EIE0;<br>+	imask = BIT(id &amp; (__riscv_xlen - 1));<br>+<br>+	return !!(imsic_csr_read_clear(isel, imask) &amp; imask);<br>+}<br>+<br>+static inline bool __imsic_id_read_clear_enabled(unsigned long id)<br>+{<br>+	return __imsic_eix_read_clear(id, false);<br>+}<br>+<br>+static inline bool __imsic_id_read_clear_pending(unsigned long id)<br>+{<br>+	return __imsic_eix_read_clear(id, true);<br>+}<br>+<br>+void __imsic_eix_update(unsigned long base_id, unsigned long num_id, bool pend, bool val)<br>+{<br>+	unsigned long id = base_id, last_id = base_id + num_id;<br>+	unsigned long i, isel, ireg;<br>+<br>+	while (id &lt; last_id) {<br>+		isel = id / BITS_PER_LONG;<br>+		isel *= BITS_PER_LONG / IMSIC_EIPx_BITS;<br>+		isel += pend ? IMSIC_EIP0 : IMSIC_EIE0;<br>+<br>+		/*<br>+		 * Prepare the ID mask to be programmed in the<br>+		 * IMSIC EIEx and EIPx registers. These registers<br>+		 * are XLEN-wide and we must not touch IDs which<br>+		 * are &lt; base_id and &gt;= (base_id + num_id).<br>+		 */<br>+		ireg = 0;<br>+		for (i = id &amp; (__riscv_xlen - 1); id &lt; last_id &amp;&amp; i &lt; __riscv_xlen; i++) {<br>+			ireg |= BIT(i);<br>+			id++;<br>+		}<br>+<br>+		/*<br>+		 * The IMSIC EIEx and EIPx registers are indirectly<br>+		 * accessed via using ISELECT and IREG CSRs so we<br>+		 * need to access these CSRs without getting preempted.<br>+		 *<br>+		 * All existing users of this function call this<br>+		 * function with local IRQs disabled so we don't<br>+		 * need to do anything special here.<br>+		 */<br>+		if (val)<br>+			imsic_csr_set(isel, ireg);<br>+		else<br>+			imsic_csr_clear(isel, ireg);<br>+	}<br>+}<br>+<br>+static void __imsic_local_sync(struct imsic_local_priv *lpriv)<br>+{<br>+	struct imsic_local_config *mlocal;<br>+	struct imsic_vector *vec, *mvec;<br>+	int i;<br>+<br>+	lockdep_assert_held(&amp;lpriv-&gt;lock);<br>+<br>+	for_each_set_bit(i, lpriv-&gt;dirty_bitmap, imsic-&gt;global.nr_ids + 1) {<br>+		if (!i || i == IMSIC_IPI_ID)<br>+			goto skip;<br>+		vec = &amp;lpriv-&gt;vectors[i];<br>+<br>+		if (READ_ONCE(vec-&gt;enable))<br>+			__imsic_id_set_enable(i);<br>+		else<br>+			__imsic_id_clear_enable(i);<br>+<br>+		/*<br>+		 * If the ID was being moved to a new ID on some other CPU<br>+		 * then we can get a MSI during the movement so check the<br>+		 * ID pending bit and re-trigger the new ID on other CPU<br>+		 * using MMIO write.<br>+		 */<br>+		mvec = READ_ONCE(vec-&gt;move);<br>+		WRITE_ONCE(vec-&gt;move, NULL);<br>+		if (mvec &amp;&amp; mvec != vec) {<br>+			if (__imsic_id_read_clear_pending(i)) {<br>+				mlocal = per_cpu_ptr(imsic-&gt;global.local, mvec-&gt;cpu);<br>+				writel_relaxed(mvec-&gt;local_id, mlocal-&gt;msi_va);<br>+			}<br>+<br>+			imsic_vector_free(&amp;lpriv-&gt;vectors[i]);<br>+		}<br>+<br>+skip:<br>+		bitmap_clear(lpriv-&gt;dirty_bitmap, i, 1);<br>+	}<br>+}<br>+<br>+void imsic_local_sync_all(void)<br>+{<br>+	struct imsic_local_priv *lpriv = this_cpu_ptr(imsic-&gt;lpriv);<br>+	unsigned long flags;<br>+<br>+	raw_spin_lock_irqsave(&amp;lpriv-&gt;lock, flags);<br>+	bitmap_fill(lpriv-&gt;dirty_bitmap, imsic-&gt;global.nr_ids + 1);<br>+	__imsic_local_sync(lpriv);<br>+	raw_spin_unlock_irqrestore(&amp;lpriv-&gt;lock, flags);<br>+}<br>+<br>+void imsic_local_delivery(bool enable)<br>+{<br>+	if (enable) {<br>+		imsic_csr_write(IMSIC_EITHRESHOLD, IMSIC_ENABLE_EITHRESHOLD);<br>+		imsic_csr_write(IMSIC_EIDELIVERY, IMSIC_ENABLE_EIDELIVERY);<br>+		return;<br>+	}<br>+<br>+	imsic_csr_write(IMSIC_EIDELIVERY, IMSIC_DISABLE_EIDELIVERY);<br>+	imsic_csr_write(IMSIC_EITHRESHOLD, IMSIC_DISABLE_EITHRESHOLD);<br>+}<br>+<br>+#ifdef CONFIG_SMP<br>+static void imsic_local_timer_callback(struct timer_list *timer)<br>+{<br>+	struct imsic_local_priv *lpriv = this_cpu_ptr(imsic-&gt;lpriv);<br>+	unsigned long flags;<br>+<br>+	raw_spin_lock_irqsave(&amp;lpriv-&gt;lock, flags);<br>+	__imsic_local_sync(lpriv);<br>+	raw_spin_unlock_irqrestore(&amp;lpriv-&gt;lock, flags);<br>+}<br>+<br>+static void __imsic_remote_sync(struct imsic_local_priv *lpriv, unsigned int cpu)<br>+{<br>+	lockdep_assert_held(&amp;lpriv-&gt;lock);<br>+<br>+	/*<br>+	 * The spinlock acquire/release semantics ensure that changes<br>+	 * to vector enable, vector move and dirty bitmap are visible<br>+	 * to the target CPU.<br>+	 */<br>+<br>+	/*<br>+	 * We schedule a timer on the target CPU if the target CPU is not<br>+	 * same as the current CPU. An offline CPU will unconditionally<br>+	 * synchronize IDs through imsic_starting_cpu() when the<br>+	 * CPU is brought up.<br>+	 */<br>+	if (cpu_online(cpu)) {<br>+		if (cpu == smp_processor_id()) {<br>+			__imsic_local_sync(lpriv);<br>+			return;<br>+		}<br>+<br>+		if (!timer_pending(&amp;lpriv-&gt;timer)) {<br>+			lpriv-&gt;timer.expires = jiffies + 1;<br>+			add_timer_on(&amp;lpriv-&gt;timer, cpu);<br>+		}<br>+	}<br>+}<br>+#else<br>+static void __imsic_remote_sync(struct imsic_local_priv *lpriv, unsigned int cpu)<br>+{<br>+	lockdep_assert_held(&amp;lpriv-&gt;lock);<br>+	__imsic_local_sync(lpriv);<br>+}<br>+#endif<br>+<br>+void imsic_vector_mask(struct imsic_vector *vec)<br>+{<br>+	struct imsic_local_priv *lpriv;<br>+<br>+	lpriv = per_cpu_ptr(imsic-&gt;lpriv, vec-&gt;cpu);<br>+	if (WARN_ON_ONCE(&amp;lpriv-&gt;vectors[vec-&gt;local_id] != vec))<br>+		return;<br>+<br>+	/*<br>+	 * This function is called through Linux irq subsystem with<br>+	 * irqs disabled so no need to save/restore irq flags.<br>+	 */<br>+<br>+	raw_spin_lock(&amp;lpriv-&gt;lock);<br>+<br>+	WRITE_ONCE(vec-&gt;enable, false);<br>+	bitmap_set(lpriv-&gt;dirty_bitmap, vec-&gt;local_id, 1);<br>+	__imsic_remote_sync(lpriv, vec-&gt;cpu);<br>+<br>+	raw_spin_unlock(&amp;lpriv-&gt;lock);<br>+}<br>+<br>+void imsic_vector_unmask(struct imsic_vector *vec)<br>+{<br>+	struct imsic_local_priv *lpriv;<br>+<br>+	lpriv = per_cpu_ptr(imsic-&gt;lpriv, vec-&gt;cpu);<br>+	if (WARN_ON_ONCE(&amp;lpriv-&gt;vectors[vec-&gt;local_id] != vec))<br>+		return;<br>+<br>+	/*<br>+	 * This function is called through Linux irq subsystem with<br>+	 * irqs disabled so no need to save/restore irq flags.<br>+	 */<br>+<br>+	raw_spin_lock(&amp;lpriv-&gt;lock);<br>+<br>+	WRITE_ONCE(vec-&gt;enable, true);<br>+	bitmap_set(lpriv-&gt;dirty_bitmap, vec-&gt;local_id, 1);<br>+	__imsic_remote_sync(lpriv, vec-&gt;cpu);<br>+<br>+	raw_spin_unlock(&amp;lpriv-&gt;lock);<br>+}<br>+<br>+static bool imsic_vector_move_update(struct imsic_local_priv *lpriv, struct imsic_vector *vec,<br>+				     bool new_enable, struct imsic_vector *new_move)<br>+{<br>+	unsigned long flags;<br>+	bool enabled;<br>+<br>+	raw_spin_lock_irqsave(&amp;lpriv-&gt;lock, flags);<br>+<br>+	/* Update enable and move details */<br>+	enabled = READ_ONCE(vec-&gt;enable);<br>+	WRITE_ONCE(vec-&gt;enable, new_enable);<br>+	WRITE_ONCE(vec-&gt;move, new_move);<br>+<br>+	/* Mark the vector as dirty and synchronize */<br>+	bitmap_set(lpriv-&gt;dirty_bitmap, vec-&gt;local_id, 1);<br>+	__imsic_remote_sync(lpriv, vec-&gt;cpu);<br>+<br>+	raw_spin_unlock_irqrestore(&amp;lpriv-&gt;lock, flags);<br>+<br>+	return enabled;<br>+}<br>+<br>+void imsic_vector_move(struct imsic_vector *old_vec, struct imsic_vector *new_vec)<br>+{<br>+	struct imsic_local_priv *old_lpriv, *new_lpriv;<br>+	bool enabled;<br>+<br>+	if (WARN_ON_ONCE(old_vec-&gt;cpu == new_vec-&gt;cpu))<br>+		return;<br>+<br>+	old_lpriv = per_cpu_ptr(imsic-&gt;lpriv, old_vec-&gt;cpu);<br>+	if (WARN_ON_ONCE(&amp;old_lpriv-&gt;vectors[old_vec-&gt;local_id] != old_vec))<br>+		return;<br>+<br>+	new_lpriv = per_cpu_ptr(imsic-&gt;lpriv, new_vec-&gt;cpu);<br>+	if (WARN_ON_ONCE(&amp;new_lpriv-&gt;vectors[new_vec-&gt;local_id] != new_vec))<br>+		return;<br>+<br>+	/*<br>+	 * Move and re-trigger the new vector based on the pending<br>+	 * state of the old vector because we might get a device<br>+	 * interrupt on the old vector while device was being moved<br>+	 * to the new vector.<br>+	 */<br>+	enabled = imsic_vector_move_update(old_lpriv, old_vec, false, new_vec);<br>+	imsic_vector_move_update(new_lpriv, new_vec, enabled, new_vec);<br>+}<br>+<br>+#ifdef CONFIG_GENERIC_IRQ_DEBUGFS<br>+void imsic_vector_debug_show(struct seq_file *m, struct imsic_vector *vec, int ind)<br>+{<br>+	struct imsic_local_priv *lpriv;<br>+	struct imsic_vector *mvec;<br>+	bool is_enabled;<br>+<br>+	lpriv = per_cpu_ptr(imsic-&gt;lpriv, vec-&gt;cpu);<br>+	if (WARN_ON_ONCE(&amp;lpriv-&gt;vectors[vec-&gt;local_id] != vec))<br>+		return;<br>+<br>+	is_enabled = imsic_vector_isenabled(vec);<br>+	mvec = imsic_vector_get_move(vec);<br>+<br>+	seq_printf(m, "%*starget_cpu      : %5u\n", ind, "", vec-&gt;cpu);<br>+	seq_printf(m, "%*starget_local_id : %5u\n", ind, "", vec-&gt;local_id);<br>+	seq_printf(m, "%*sis_reserved     : %5u\n", ind, "",<br>+		   (vec-&gt;local_id &lt;= IMSIC_IPI_ID) ? 1 : 0);<br>+	seq_printf(m, "%*sis_enabled      : %5u\n", ind, "", is_enabled ? 1 : 0);<br>+	seq_printf(m, "%*sis_move_pending : %5u\n", ind, "", mvec ? 1 : 0);<br>+	if (mvec) {<br>+		seq_printf(m, "%*smove_cpu        : %5u\n", ind, "", mvec-&gt;cpu);<br>+		seq_printf(m, "%*smove_local_id   : %5u\n", ind, "", mvec-&gt;local_id);<br>+	}<br>+}<br>+<br>+void imsic_vector_debug_show_summary(struct seq_file *m, int ind)<br>+{<br>+	irq_matrix_debug_show(m, imsic-&gt;matrix, ind);<br>+}<br>+#endif<br>+<br>+struct imsic_vector *imsic_vector_from_local_id(unsigned int cpu, unsigned int local_id)<br>+{<br>+	struct imsic_local_priv *lpriv = per_cpu_ptr(imsic-&gt;lpriv, cpu);<br>+<br>+	if (!lpriv || imsic-&gt;global.nr_ids &lt; local_id)<br>+		return NULL;<br>+<br>+	return &amp;lpriv-&gt;vectors[local_id];<br>+}<br>+<br>+struct imsic_vector *imsic_vector_alloc(unsigned int hwirq, const struct cpumask *mask)<br>+{<br>+	struct imsic_vector *vec = NULL;<br>+	struct imsic_local_priv *lpriv;<br>+	unsigned long flags;<br>+	unsigned int cpu;<br>+	int local_id;<br>+<br>+	raw_spin_lock_irqsave(&amp;imsic-&gt;matrix_lock, flags);<br>+	local_id = irq_matrix_alloc(imsic-&gt;matrix, mask, false, &amp;cpu);<br>+	raw_spin_unlock_irqrestore(&amp;imsic-&gt;matrix_lock, flags);<br>+	if (local_id &lt; 0)<br>+		return NULL;<br>+<br>+	lpriv = per_cpu_ptr(imsic-&gt;lpriv, cpu);<br>+	vec = &amp;lpriv-&gt;vectors[local_id];<br>+	vec-&gt;hwirq = hwirq;<br>+	vec-&gt;enable = false;<br>+	vec-&gt;move = NULL;<br>+<br>+	return vec;<br>+}<br>+<br>+void imsic_vector_free(struct imsic_vector *vec)<br>+{<br>+	unsigned long flags;<br>+<br>+	raw_spin_lock_irqsave(&amp;imsic-&gt;matrix_lock, flags);<br>+	vec-&gt;hwirq = UINT_MAX;<br>+	irq_matrix_free(imsic-&gt;matrix, vec-&gt;cpu, vec-&gt;local_id, false);<br>+	raw_spin_unlock_irqrestore(&amp;imsic-&gt;matrix_lock, flags);<br>+}<br>+<br>+static void __init imsic_local_cleanup(void)<br>+{<br>+	struct imsic_local_priv *lpriv;<br>+	int cpu;<br>+<br>+	for_each_possible_cpu(cpu) {<br>+		lpriv = per_cpu_ptr(imsic-&gt;lpriv, cpu);<br>+<br>+		bitmap_free(lpriv-&gt;dirty_bitmap);<br>+		kfree(lpriv-&gt;vectors);<br>+	}<br>+<br>+	free_percpu(imsic-&gt;lpriv);<br>+}<br>+<br>+static int __init imsic_local_init(void)<br>+{<br>+	struct imsic_global_config *global = &amp;imsic-&gt;global;<br>+	struct imsic_local_priv *lpriv;<br>+	struct imsic_vector *vec;<br>+	int cpu, i;<br>+<br>+	/* Allocate per-CPU private state */<br>+	imsic-&gt;lpriv = alloc_percpu(typeof(*imsic-&gt;lpriv));<br>+	if (!imsic-&gt;lpriv)<br>+		return -ENOMEM;<br>+<br>+	/* Setup per-CPU private state */<br>+	for_each_possible_cpu(cpu) {<br>+		lpriv = per_cpu_ptr(imsic-&gt;lpriv, cpu);<br>+<br>+		raw_spin_lock_init(&amp;lpriv-&gt;lock);<br>+<br>+		/* Allocate dirty bitmap */<br>+		lpriv-&gt;dirty_bitmap = bitmap_zalloc(global-&gt;nr_ids + 1, GFP_KERNEL);<br>+		if (!lpriv-&gt;dirty_bitmap)<br>+			goto fail_local_cleanup;<br>+<br>+#ifdef CONFIG_SMP<br>+		/* Setup lazy timer for synchronization */<br>+		timer_setup(&amp;lpriv-&gt;timer, imsic_local_timer_callback, TIMER_PINNED);<br>+#endif<br>+<br>+		/* Allocate vector array */<br>+		lpriv-&gt;vectors = kcalloc(global-&gt;nr_ids + 1, sizeof(*lpriv-&gt;vectors),<br>+					 GFP_KERNEL);<br>+		if (!lpriv-&gt;vectors)<br>+			goto fail_local_cleanup;<br>+<br>+		/* Setup vector array */<br>+		for (i = 0; i &lt;= global-&gt;nr_ids; i++) {<br>+			vec = &amp;lpriv-&gt;vectors[i];<br>+			vec-&gt;cpu = cpu;<br>+			vec-&gt;local_id = i;<br>+			vec-&gt;hwirq = UINT_MAX;<br>+		}<br>+	}<br>+<br>+	return 0;<br>+<br>+fail_local_cleanup:<br>+	imsic_local_cleanup();<br>+	return -ENOMEM;<br>+}<br>+<br>+void imsic_state_online(void)<br>+{<br>+	unsigned long flags;<br>+<br>+	raw_spin_lock_irqsave(&amp;imsic-&gt;matrix_lock, flags);<br>+	irq_matrix_online(imsic-&gt;matrix);<br>+	raw_spin_unlock_irqrestore(&amp;imsic-&gt;matrix_lock, flags);<br>+}<br>+<br>+void imsic_state_offline(void)<br>+{<br>+	unsigned long flags;<br>+<br>+	raw_spin_lock_irqsave(&amp;imsic-&gt;matrix_lock, flags);<br>+	irq_matrix_offline(imsic-&gt;matrix);<br>+	raw_spin_unlock_irqrestore(&amp;imsic-&gt;matrix_lock, flags);<br>+<br>+#ifdef CONFIG_SMP<br>+	struct imsic_local_priv *lpriv = this_cpu_ptr(imsic-&gt;lpriv);<br>+<br>+	raw_spin_lock_irqsave(&amp;lpriv-&gt;lock, flags);<br>+	WARN_ON_ONCE(try_to_del_timer_sync(&amp;lpriv-&gt;timer) &lt; 0);<br>+	raw_spin_unlock_irqrestore(&amp;lpriv-&gt;lock, flags);<br>+#endif<br>+}<br>+<br>+static int __init imsic_matrix_init(void)<br>+{<br>+	struct imsic_global_config *global = &amp;imsic-&gt;global;<br>+<br>+	raw_spin_lock_init(&amp;imsic-&gt;matrix_lock);<br>+	imsic-&gt;matrix = irq_alloc_matrix(global-&gt;nr_ids + 1,<br>+					 0, global-&gt;nr_ids + 1);<br>+	if (!imsic-&gt;matrix)<br>+		return -ENOMEM;<br>+<br>+	/* Reserve ID#0 because it is special and never implemented */<br>+	irq_matrix_assign_system(imsic-&gt;matrix, 0, false);<br>+<br>+	/* Reserve IPI ID because it is special and used internally */<br>+	irq_matrix_assign_system(imsic-&gt;matrix, IMSIC_IPI_ID, false);<br>+<br>+	return 0;<br>+}<br>+<br>+static int __init imsic_get_parent_hartid(struct fwnode_handle *fwnode,<br>+					  u32 index, unsigned long *hartid)<br>+{<br>+	struct of_phandle_args parent;<br>+	int rc;<br>+<br>+	/*<br>+	 * Currently, only OF fwnode is supported so extend this<br>+	 * function for ACPI support.<br>+	 */<br>+	if (!is_of_node(fwnode))<br>+		return -EINVAL;<br>+<br>+	rc = of_irq_parse_one(to_of_node(fwnode), index, &amp;parent);<br>+	if (rc)<br>+		return rc;<br>+<br>+	/*<br>+	 * Skip interrupts other than external interrupts for<br>+	 * current privilege level.<br>+	 */<br>+	if (parent.args[0] != RV_IRQ_EXT)<br>+		return -EINVAL;<br>+<br>+	return riscv_of_parent_hartid(parent.np, hartid);<br>+}<br>+<br>+static int __init imsic_get_mmio_resource(struct fwnode_handle *fwnode,<br>+					  u32 index, struct resource *res)<br>+{<br>+	/*<br>+	 * Currently, only OF fwnode is supported so extend this<br>+	 * function for ACPI support.<br>+	 */<br>+	if (!is_of_node(fwnode))<br>+		return -EINVAL;<br>+<br>+	return of_address_to_resource(to_of_node(fwnode), index, res);<br>+}<br>+<br>+static int __init imsic_parse_fwnode(struct fwnode_handle *fwnode,<br>+				     struct imsic_global_config *global,<br>+				     u32 *nr_parent_irqs,<br>+				     u32 *nr_mmios)<br>+{<br>+	unsigned long hartid;<br>+	struct resource res;<br>+	int rc;<br>+	u32 i;<br>+<br>+	/*<br>+	 * Currently, only OF fwnode is supported so extend this<br>+	 * function for ACPI support.<br>+	 */<br>+	if (!is_of_node(fwnode))<br>+		return -EINVAL;<br>+<br>+	*nr_parent_irqs = 0;<br>+	*nr_mmios = 0;<br>+<br>+	/* Find number of parent interrupts */<br>+	while (!imsic_get_parent_hartid(fwnode, *nr_parent_irqs, &amp;hartid))<br>+		(*nr_parent_irqs)++;<br>+	if (!*nr_parent_irqs) {<br>+		pr_err("%pfwP: no parent irqs available\n", fwnode);<br>+		return -EINVAL;<br>+	}<br>+<br>+	/* Find number of guest index bits in MSI address */<br>+	rc = of_property_read_u32(to_of_node(fwnode), "riscv,guest-index-bits",<br>+				  &amp;global-&gt;guest_index_bits);<br>+	if (rc)<br>+		global-&gt;guest_index_bits = 0;<br>+<br>+	/* Find number of HART index bits */<br>+	rc = of_property_read_u32(to_of_node(fwnode), "riscv,hart-index-bits",<br>+				  &amp;global-&gt;hart_index_bits);<br>+	if (rc) {<br>+		/* Assume default value */<br>+		global-&gt;hart_index_bits = __fls(*nr_parent_irqs);<br>+		if (BIT(global-&gt;hart_index_bits) &lt; *nr_parent_irqs)<br>+			global-&gt;hart_index_bits++;<br>+	}<br>+<br>+	/* Find number of group index bits */<br>+	rc = of_property_read_u32(to_of_node(fwnode), "riscv,group-index-bits",<br>+				  &amp;global-&gt;group_index_bits);<br>+	if (rc)<br>+		global-&gt;group_index_bits = 0;<br>+<br>+	/*<br>+	 * Find first bit position of group index.<br>+	 * If not specified assumed the default APLIC-IMSIC configuration.<br>+	 */<br>+	rc = of_property_read_u32(to_of_node(fwnode), "riscv,group-index-shift",<br>+				  &amp;global-&gt;group_index_shift);<br>+	if (rc)<br>+		global-&gt;group_index_shift = IMSIC_MMIO_PAGE_SHIFT * 2;<br>+<br>+	/* Find number of interrupt identities */<br>+	rc = of_property_read_u32(to_of_node(fwnode), "riscv,num-ids",<br>+				  &amp;global-&gt;nr_ids);<br>+	if (rc) {<br>+		pr_err("%pfwP: number of interrupt identities not found\n", fwnode);<br>+		return rc;<br>+	}<br>+<br>+	/* Find number of guest interrupt identities */<br>+	rc = of_property_read_u32(to_of_node(fwnode), "riscv,num-guest-ids",<br>+				  &amp;global-&gt;nr_guest_ids);<br>+	if (rc)<br>+		global-&gt;nr_guest_ids = global-&gt;nr_ids;<br>+<br>+	/* Sanity check guest index bits */<br>+	i = BITS_PER_LONG - IMSIC_MMIO_PAGE_SHIFT;<br>+	if (i &lt; global-&gt;guest_index_bits) {<br>+		pr_err("%pfwP: guest index bits too big\n", fwnode);<br>+		return -EINVAL;<br>+	}<br>+<br>+	/* Sanity check HART index bits */<br>+	i = BITS_PER_LONG - IMSIC_MMIO_PAGE_SHIFT - global-&gt;guest_index_bits;<br>+	if (i &lt; global-&gt;hart_index_bits) {<br>+		pr_err("%pfwP: HART index bits too big\n", fwnode);<br>+		return -EINVAL;<br>+	}<br>+<br>+	/* Sanity check group index bits */<br>+	i = BITS_PER_LONG - IMSIC_MMIO_PAGE_SHIFT -<br>+	    global-&gt;guest_index_bits - global-&gt;hart_index_bits;<br>+	if (i &lt; global-&gt;group_index_bits) {<br>+		pr_err("%pfwP: group index bits too big\n", fwnode);<br>+		return -EINVAL;<br>+	}<br>+<br>+	/* Sanity check group index shift */<br>+	i = global-&gt;group_index_bits + global-&gt;group_index_shift - 1;<br>+	if (i &gt;= BITS_PER_LONG) {<br>+		pr_err("%pfwP: group index shift too big\n", fwnode);<br>+		return -EINVAL;<br>+	}<br>+<br>+	/* Sanity check number of interrupt identities */<br>+	if (global-&gt;nr_ids &lt; IMSIC_MIN_ID ||<br>+	    global-&gt;nr_ids &gt;= IMSIC_MAX_ID ||<br>+	    (global-&gt;nr_ids &amp; IMSIC_MIN_ID) != IMSIC_MIN_ID) {<br>+		pr_err("%pfwP: invalid number of interrupt identities\n", fwnode);<br>+		return -EINVAL;<br>+	}<br>+<br>+	/* Sanity check number of guest interrupt identities */<br>+	if (global-&gt;nr_guest_ids &lt; IMSIC_MIN_ID ||<br>+	    global-&gt;nr_guest_ids &gt;= IMSIC_MAX_ID ||<br>+	    (global-&gt;nr_guest_ids &amp; IMSIC_MIN_ID) != IMSIC_MIN_ID) {<br>+		pr_err("%pfwP: invalid number of guest interrupt identities\n", fwnode);<br>+		return -EINVAL;<br>+	}<br>+<br>+	/* Compute base address */<br>+	rc = imsic_get_mmio_resource(fwnode, 0, &amp;res);<br>+	if (rc) {<br>+		pr_err("%pfwP: first MMIO resource not found\n", fwnode);<br>+		return -EINVAL;<br>+	}<br>+	global-&gt;base_addr = res.start;<br>+	global-&gt;base_addr &amp;= ~(BIT(global-&gt;guest_index_bits +<br>+				   global-&gt;hart_index_bits +<br>+				   IMSIC_MMIO_PAGE_SHIFT) - 1);<br>+	global-&gt;base_addr &amp;= ~((BIT(global-&gt;group_index_bits) - 1) &lt;&lt;<br>+			       global-&gt;group_index_shift);<br>+<br>+	/* Find number of MMIO register sets */<br>+	while (!imsic_get_mmio_resource(fwnode, *nr_mmios, &amp;res))<br>+		(*nr_mmios)++;<br>+<br>+	return 0;<br>+}<br>+<br>+int __init imsic_setup_state(struct fwnode_handle *fwnode)<br>+{<br>+	u32 i, j, index, nr_parent_irqs, nr_mmios, nr_handlers = 0;<br>+	struct imsic_global_config *global;<br>+	struct imsic_local_config *local;<br>+	void __iomem **mmios_va = NULL;<br>+	struct resource *mmios = NULL;<br>+	unsigned long reloff, hartid;<br>+	phys_addr_t base_addr;<br>+	int rc, cpu;<br>+<br>+	/*<br>+	 * Only one IMSIC instance allowed in a platform for clean<br>+	 * implementation of SMP IRQ affinity and per-CPU IPIs.<br>+	 *<br>+	 * This means on a multi-socket (or multi-die) platform we<br>+	 * will have multiple MMIO regions for one IMSIC instance.<br>+	 */<br>+	if (imsic) {<br>+		pr_err("%pfwP: already initialized hence ignoring\n", fwnode);<br>+		return -EALREADY;<br>+	}<br>+<br>+	if (!riscv_isa_extension_available(NULL, SxAIA)) {<br>+		pr_err("%pfwP: AIA support not available\n", fwnode);<br>+		return -ENODEV;<br>+	}<br>+<br>+	imsic = kzalloc(sizeof(*imsic), GFP_KERNEL);<br>+	if (!imsic)<br>+		return -ENOMEM;<br>+	imsic-&gt;fwnode = fwnode;<br>+	global = &amp;imsic-&gt;global;<br>+<br>+	global-&gt;local = alloc_percpu(typeof(*global-&gt;local));<br>+	if (!global-&gt;local) {<br>+		rc = -ENOMEM;<br>+		goto out_free_priv;<br>+	}<br>+<br>+	/* Parse IMSIC fwnode */<br>+	rc = imsic_parse_fwnode(fwnode, global, &amp;nr_parent_irqs, &amp;nr_mmios);<br>+	if (rc)<br>+		goto out_free_local;<br>+<br>+	/* Allocate MMIO resource array */<br>+	mmios = kcalloc(nr_mmios, sizeof(*mmios), GFP_KERNEL);<br>+	if (!mmios) {<br>+		rc = -ENOMEM;<br>+		goto out_free_local;<br>+	}<br>+<br>+	/* Allocate MMIO virtual address array */<br>+	mmios_va = kcalloc(nr_mmios, sizeof(*mmios_va), GFP_KERNEL);<br>+	if (!mmios_va) {<br>+		rc = -ENOMEM;<br>+		goto out_iounmap;<br>+	}<br>+<br>+	/* Parse and map MMIO register sets */<br>+	for (i = 0; i &lt; nr_mmios; i++) {<br>+		rc = imsic_get_mmio_resource(fwnode, i, &amp;mmios[i]);<br>+		if (rc) {<br>+			pr_err("%pfwP: unable to parse MMIO regset %d\n", fwnode, i);<br>+			goto out_iounmap;<br>+		}<br>+<br>+		base_addr = mmios[i].start;<br>+		base_addr &amp;= ~(BIT(global-&gt;guest_index_bits +<br>+				   global-&gt;hart_index_bits +<br>+				   IMSIC_MMIO_PAGE_SHIFT) - 1);<br>+		base_addr &amp;= ~((BIT(global-&gt;group_index_bits) - 1) &lt;&lt;<br>+			       global-&gt;group_index_shift);<br>+		if (base_addr != global-&gt;base_addr) {<br>+			rc = -EINVAL;<br>+			pr_err("%pfwP: address mismatch for regset %d\n", fwnode, i);<br>+			goto out_iounmap;<br>+		}<br>+<br>+		mmios_va[i] = ioremap(mmios[i].start, resource_size(&amp;mmios[i]));<br>+		if (!mmios_va[i]) {<br>+			rc = -EIO;<br>+			pr_err("%pfwP: unable to map MMIO regset %d\n", fwnode, i);<br>+			goto out_iounmap;<br>+		}<br>+	}<br>+<br>+	/* Initialize local (or per-CPU )state */<br>+	rc = imsic_local_init();<br>+	if (rc) {<br>+		pr_err("%pfwP: failed to initialize local state\n",<br>+		       fwnode);<br>+		goto out_iounmap;<br>+	}<br>+<br>+	/* Configure handlers for target CPUs */<br>+	for (i = 0; i &lt; nr_parent_irqs; i++) {<br>+		rc = imsic_get_parent_hartid(fwnode, i, &amp;hartid);<br>+		if (rc) {<br>+			pr_warn("%pfwP: hart ID for parent irq%d not found\n", fwnode, i);<br>+			continue;<br>+		}<br>+<br>+		cpu = riscv_hartid_to_cpuid(hartid);<br>+		if (cpu &lt; 0) {<br>+			pr_warn("%pfwP: invalid cpuid for parent irq%d\n", fwnode, i);<br>+			continue;<br>+		}<br>+<br>+		/* Find MMIO location of MSI page */<br>+		index = nr_mmios;<br>+		reloff = i * BIT(global-&gt;guest_index_bits) *<br>+			 IMSIC_MMIO_PAGE_SZ;<br>+		for (j = 0; nr_mmios; j++) {<br>+			if (reloff &lt; resource_size(&amp;mmios[j])) {<br>+				index = j;<br>+				break;<br>+			}<br>+<br>+			/*<br>+			 * MMIO region size may not be aligned to<br>+			 * BIT(global-&gt;guest_index_bits) * IMSIC_MMIO_PAGE_SZ<br>+			 * if holes are present.<br>+			 */<br>+			reloff -= ALIGN(resource_size(&amp;mmios[j]),<br>+			BIT(global-&gt;guest_index_bits) * IMSIC_MMIO_PAGE_SZ);<br>+		}<br>+		if (index &gt;= nr_mmios) {<br>+			pr_warn("%pfwP: MMIO not found for parent irq%d\n", fwnode, i);<br>+			continue;<br>+		}<br>+<br>+		local = per_cpu_ptr(global-&gt;local, cpu);<br>+		local-&gt;msi_pa = mmios[index].start + reloff;<br>+		local-&gt;msi_va = mmios_va[index] + reloff;<br>+<br>+		nr_handlers++;<br>+	}<br>+<br>+	/* If no CPU handlers found then can't take interrupts */<br>+	if (!nr_handlers) {<br>+		pr_err("%pfwP: No CPU handlers found\n", fwnode);<br>+		rc = -ENODEV;<br>+		goto out_local_cleanup;<br>+	}<br>+<br>+	/* Initialize matrix allocator */<br>+	rc = imsic_matrix_init();<br>+	if (rc) {<br>+		pr_err("%pfwP: failed to create matrix allocator\n", fwnode);<br>+		goto out_local_cleanup;<br>+	}<br>+<br>+	/* We don't need MMIO arrays anymore so let's free-up */<br>+	kfree(mmios_va);<br>+	kfree(mmios);<br>+<br>+	return 0;<br>+<br>+out_local_cleanup:<br>+	imsic_local_cleanup();<br>+out_iounmap:<br>+	for (i = 0; i &lt; nr_mmios; i++) {<br>+		if (mmios_va[i])<br>+			iounmap(mmios_va[i]);<br>+	}<br>+	kfree(mmios_va);<br>+	kfree(mmios);<br>+out_free_local:<br>+	free_percpu(imsic-&gt;global.local);<br>+out_free_priv:<br>+	kfree(imsic);<br>+	imsic = NULL;<br>+	return rc;<br>+}<br>diff --git a/drivers/irqchip/irq-riscv-imsic-state.h b/drivers/irqchip/irq-riscv-imsic-state.h<br>new file mode 100644<br>index 000000000000..8ec9649d0d01<br>--- /dev/null<br>+++ b/drivers/irqchip/irq-riscv-imsic-state.h<br>@@ -0,0 +1,107 @@<br>+/* SPDX-License-Identifier: GPL-2.0-only */<br>+/*<br>+ * Copyright (C) 2021 Western Digital Corporation or its affiliates.<br>+ * Copyright (C) 2022 Ventana Micro Systems Inc.<br>+ */<br>+<br>+#ifndef _IRQ_RISCV_IMSIC_STATE_H<br>+#define _IRQ_RISCV_IMSIC_STATE_H<br>+<br>+#include &lt;linux/irqchip/riscv-imsic.h&gt;<br>+#include &lt;linux/irqdomain.h&gt;<br>+#include &lt;linux/fwnode.h&gt;<br>+#include &lt;linux/timer.h&gt;<br>+<br>+#define IMSIC_IPI_ID				1<br>+#define IMSIC_NR_IPI				8<br>+<br>+struct imsic_vector {<br>+	/* Fixed details of the vector */<br>+	unsigned int				cpu;<br>+	unsigned int				local_id;<br>+	/* Details saved by driver in the vector */<br>+	unsigned int				hwirq;<br>+	/* Details accessed using local lock held */<br>+	bool					enable;<br>+	struct imsic_vector			*move;<br>+};<br>+<br>+struct imsic_local_priv {<br>+	/* Local lock to protect vector enable/move variables and dirty bitmap */<br>+	raw_spinlock_t				lock;<br>+<br>+	/* Local dirty bitmap for synchronization */<br>+	unsigned long				*dirty_bitmap;<br>+<br>+#ifdef CONFIG_SMP<br>+	/* Local timer for synchronization */<br>+	struct timer_list			timer;<br>+#endif<br>+<br>+	/* Local vector table */<br>+	struct imsic_vector			*vectors;<br>+};<br>+<br>+struct imsic_priv {<br>+	/* Device details */<br>+	struct fwnode_handle			*fwnode;<br>+<br>+	/* Global configuration common for all HARTs */<br>+	struct imsic_global_config		global;<br>+<br>+	/* Per-CPU state */<br>+	struct imsic_local_priv __percpu	*lpriv;<br>+<br>+	/* State of IRQ matrix allocator */<br>+	raw_spinlock_t				matrix_lock;<br>+	struct irq_matrix			*matrix;<br>+<br>+	/* IRQ domains (created by platform driver) */<br>+	struct irq_domain			*base_domain;<br>+};<br>+<br>+extern struct imsic_priv *imsic;<br>+<br>+void __imsic_eix_update(unsigned long base_id, unsigned long num_id, bool pend, bool val);<br>+<br>+static inline void __imsic_id_set_enable(unsigned long id)<br>+{<br>+	__imsic_eix_update(id, 1, false, true);<br>+}<br>+<br>+static inline void __imsic_id_clear_enable(unsigned long id)<br>+{<br>+	__imsic_eix_update(id, 1, false, false);<br>+}<br>+<br>+void imsic_local_sync_all(void);<br>+void imsic_local_delivery(bool enable);<br>+<br>+void imsic_vector_mask(struct imsic_vector *vec);<br>+void imsic_vector_unmask(struct imsic_vector *vec);<br>+<br>+static inline bool imsic_vector_isenabled(struct imsic_vector *vec)<br>+{<br>+	return READ_ONCE(vec-&gt;enable);<br>+}<br>+<br>+static inline struct imsic_vector *imsic_vector_get_move(struct imsic_vector *vec)<br>+{<br>+	return READ_ONCE(vec-&gt;move);<br>+}<br>+<br>+void imsic_vector_move(struct imsic_vector *old_vec, struct imsic_vector *new_vec);<br>+<br>+struct imsic_vector *imsic_vector_from_local_id(unsigned int cpu, unsigned int local_id);<br>+<br>+struct imsic_vector *imsic_vector_alloc(unsigned int hwirq, const struct cpumask *mask);<br>+void imsic_vector_free(struct imsic_vector *vector);<br>+<br>+void imsic_vector_debug_show(struct seq_file *m, struct imsic_vector *vec, int ind);<br>+void imsic_vector_debug_show_summary(struct seq_file *m, int ind);<br>+<br>+void imsic_state_online(void);<br>+void imsic_state_offline(void);<br>+int imsic_setup_state(struct fwnode_handle *fwnode);<br>+<br>+#endif<br>diff --git a/include/linux/cpuhotplug.h b/include/linux/cpuhotplug.h<br>index 172d0a743e5d..39d36183d9fc 100644<br>--- a/include/linux/cpuhotplug.h<br>+++ b/include/linux/cpuhotplug.h<br>@@ -146,6 +146,7 @@ enum cpuhp_state {<br> 	CPUHP_AP_IRQ_MIPS_GIC_STARTING,<br> 	CPUHP_AP_IRQ_LOONGARCH_STARTING,<br> 	CPUHP_AP_IRQ_SIFIVE_PLIC_STARTING,<br>+	CPUHP_AP_IRQ_RISCV_IMSIC_STARTING,<br> 	CPUHP_AP_ARM_MVEBU_COHERENCY,<br> 	CPUHP_AP_PERF_X86_AMD_UNCORE_STARTING,<br> 	CPUHP_AP_PERF_X86_STARTING,<br>diff --git a/include/linux/irqchip/riscv-imsic.h b/include/linux/irqchip/riscv-imsic.h<br>new file mode 100644<br>index 000000000000..faf0b800b1b0<br>--- /dev/null<br>+++ b/include/linux/irqchip/riscv-imsic.h<br>@@ -0,0 +1,87 @@<br>+/* SPDX-License-Identifier: GPL-2.0-only */<br>+/*<br>+ * Copyright (C) 2021 Western Digital Corporation or its affiliates.<br>+ * Copyright (C) 2022 Ventana Micro Systems Inc.<br>+ */<br>+#ifndef __LINUX_IRQCHIP_RISCV_IMSIC_H<br>+#define __LINUX_IRQCHIP_RISCV_IMSIC_H<br>+<br>+#include &lt;linux/types.h&gt;<br>+#include &lt;linux/bitops.h&gt;<br>+#include &lt;asm/csr.h&gt;<br>+<br>+#define IMSIC_MMIO_PAGE_SHIFT		12<br>+#define IMSIC_MMIO_PAGE_SZ		BIT(IMSIC_MMIO_PAGE_SHIFT)<br>+#define IMSIC_MMIO_PAGE_LE		0x00<br>+#define IMSIC_MMIO_PAGE_BE		0x04<br>+<br>+#define IMSIC_MIN_ID			63<br>+#define IMSIC_MAX_ID			2048<br>+<br>+#define IMSIC_EIDELIVERY		0x70<br>+<br>+#define IMSIC_EITHRESHOLD		0x72<br>+<br>+#define IMSIC_EIP0			0x80<br>+#define IMSIC_EIP63			0xbf<br>+#define IMSIC_EIPx_BITS			32<br>+<br>+#define IMSIC_EIE0			0xc0<br>+#define IMSIC_EIE63			0xff<br>+#define IMSIC_EIEx_BITS			32<br>+<br>+#define IMSIC_FIRST			IMSIC_EIDELIVERY<br>+#define IMSIC_LAST			IMSIC_EIE63<br>+<br>+#define IMSIC_MMIO_SETIPNUM_LE		0x00<br>+#define IMSIC_MMIO_SETIPNUM_BE		0x04<br>+<br>+struct imsic_local_config {<br>+	phys_addr_t				msi_pa;<br>+	void __iomem				*msi_va;<br>+};<br>+<br>+struct imsic_global_config {<br>+	/*<br>+	 * MSI Target Address Scheme<br>+	 *<br>+	 * XLEN-1                                                12     0<br>+	 * |                                                     |     |<br>+	 * -------------------------------------------------------------<br>+	 * |xxxxxx|Group Index|xxxxxxxxxxx|HART Index|Guest Index|  0  |<br>+	 * -------------------------------------------------------------<br>+	 */<br>+<br>+	/* Bits representing Guest index, HART index, and Group index */<br>+	u32					guest_index_bits;<br>+	u32					hart_index_bits;<br>+	u32					group_index_bits;<br>+	u32					group_index_shift;<br>+<br>+	/* Global base address matching all target MSI addresses */<br>+	phys_addr_t				base_addr;<br>+<br>+	/* Number of interrupt identities */<br>+	u32					nr_ids;<br>+<br>+	/* Number of guest interrupt identities */<br>+	u32					nr_guest_ids;<br>+<br>+	/* Per-CPU IMSIC addresses */<br>+	struct imsic_local_config __percpu	*local;<br>+};<br>+<br>+#ifdef CONFIG_RISCV_IMSIC<br>+<br>+const struct imsic_global_config *imsic_get_global_config(void);<br>+<br>+#else<br>+<br>+static inline const struct imsic_global_config *imsic_get_global_config(void)<br>+{<br>+	return NULL;<br>+}<br>+<br>+#endif<br>+<br>+#endif<br>-- <br>2.34.1<br><br></pre><td width=32 rowspan=2 class=c valign=top><img src="data:image/gif;base64,R0lGODlhIAAgAKEAAM7l5eXl5f///////yH5BAEKAAIALAAAAAAgACAAAAJUlAWpy+0HkZsz2oCz3tx6wYXb91EP6ZkMSooj+7kZTKp0Td2tqO9dX2oAcYth7GW8aJKpItPifEZm0immCgVgI4kt5Oo1gMMIskFrDphBa/T6vS4AADs=" width=32 height=32 alt=\><tr><td align=right valign=bottom>
 &nbsp;
 <tr><td align=right valign=bottom>&nbsp;<td class=c valign=bottom style=padding-bottom:0px><img src="data:image/gif;base64,R0lGODlhIAAgAKEAAOXl5c7l5f///////yH5BAEKAAIALAAAAAAgACAAAAJUlI+py+0PYwKymmArzpFy6H1OsIkMaTZAmE5se5AlfKH0sa63keu3bKMBg62eD2Y8poYyGLOZSvai0pzpORRhs5yqNOP9arZYCfn8CKuti7WbbSgAADs=" width=32 height=32 alt=\><td class=c>&nbsp;<td class=c valign=bottom style=padding-bottom:0px><img src=data:image/gif;base64,R0lGODlhIAAgAKEAAOXl5c7l5f///////yH5BAEKAAIALAAAAAAgACAAAAJSlI+py+0Po5wL0BmuzBra/nwgE3DjUp4MIKoI6yalGQtzbbBwre/xnPoBaaeer2hsgYa3E7MJSvZG0mnnObxigZeqlOL9RrbbB/m8CquP67auAAA7 width=32 height=32 alt=/><tr><td align=right valign=top colspan=2>
&nbsp;
<td class=lm>Last update: 2024-05-27 15:21 &nbsp;&nbsp; [from the cache]<br>©2003-2020 <a href=http://blog.jasper.es/><span itemprop=editor>Jasper Spaans</span></a>|hosted at <a href="https://www.digitalocean.com/?refcode=9a8e99d24cf9">Digital Ocean</a> and my Meterkast|<a href=http://blog.jasper.es/categories.html#lkml-ref>Read the blog</a><td>&nbsp;</table><div style=all:initial><div style=all:initial id=__hcfy__><template shadowrootmode=open><style class=sf-hidden>#root{-webkit-text-size-adjust:100%;box-sizing:border-box;font-size:14px;font-weight:400;letter-spacing:0;line-height:1.28581;text-transform:none;color:#182026;font-family:-apple-system,"BlinkMacSystemFont","Segoe UI","Roboto","Oxygen","Ubuntu","Cantarell","Open Sans","Helvetica Neue","Icons16",sans-serif;touch-action:manipulation}#root>.bp5-portal{z-index:9999999999}</style><style class=sf-hidden>#translate-panel{background-color:#f6f7f9;display:flex;flex-direction:column;padding-bottom:8px}.bp5-dark #translate-panel{background-color:#252a31}#translate-panel .fixed{flex-shrink:0;margin-bottom:10px}#translate-panel .body{flex-grow:1;overflow:auto;overscroll-behavior:contain}#translate-panel .body::-webkit-scrollbar{width:8px;background-color:rgba(0,0,0,0);-webkit-border-radius:100px}#translate-panel .body::-webkit-scrollbar:hover{background-color:rgba(0,0,0,.09)}#translate-panel .body::-webkit-scrollbar-thumb:vertical{background:rgba(0,0,0,.5);-webkit-border-radius:100px}#translate-panel .body::-webkit-scrollbar-thumb:vertical:active{background:rgba(0,0,0,.61);-webkit-border-radius:100px}#translate-panel.size-small,#translate-panel.size-small h6.bp5-heading,#translate-panel.size-small .bp5-control.bp5-large,#translate-panel.size-small textarea.bp5-input.bp5-small{font-size:14px}#translate-panel.size-small .phonetic-item,#translate-panel.size-small .quick-settings a{font-size:12px}#translate-panel.size-middle,#translate-panel.size-middle h6.bp5-heading,#translate-panel.size-middle .bp5-control.bp5-large,#translate-panel.size-middle textarea.bp5-input{font-size:18px}#translate-panel.size-middle .phonetic-item,#translate-panel.size-middle .quick-settings a{font-size:14px}#translate-panel.size-large,#translate-panel.size-large h6.bp5-heading,#translate-panel.size-large .bp5-control.bp5-large,#translate-panel.size-large textarea.bp5-input.bp5-large{font-size:22px}#translate-panel.size-large .source,#translate-panel.size-large .phonetic-item,#translate-panel.size-large .quick-settings a{font-size:18px}#translate-panel .bp5-button.bp5-small,#translate-panel .bp5-small .bp5-button{min-height:20px;min-width:20px}#translate-panel .header{display:flex;align-items:center;padding:4px 6px 4px 10px;border-bottom:1px solid #d1d1d1}.bp5-dark #translate-panel .header{border-bottom-color:rgba(17,20,24,.4)}#translate-panel .header .drag-block{min-width:5px;flex-shrink:0;flex-grow:1;align-self:stretch}#translate-panel .header .left{flex-shrink:0;display:flex}#translate-panel .header .right{flex-shrink:0;display:flex;align-items:center}#translate-panel .header .right .bp5-icon-arrow-right{flex-shrink:0;margin:0 5px}#translate-panel .header .right>.bp5-button{flex-shrink:0;margin:0 1px}#translate-panel .header .right>.bp5-button:last-child{margin-right:0}#translate-panel .quick-settings{padding:4px 9px;margin:0 1px}#translate-panel .quick-settings>div{margin-bottom:5px}#translate-panel .quick-settings .bp5-control{margin-bottom:0}#translate-panel .query-text{position:relative;padding:10px 10px 2px 10px}#translate-panel .query-text textarea.bp5-input{min-height:44px;font-family:system-ui,-apple-system,"Segoe UI","Roboto","Ubuntu","Cantarell","Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";overscroll-behavior:contain}#translate-panel .query-text .translate-btn{position:absolute;opacity:.6}#translate-panel .query-text .translate-btn:hover{opacity:1}#translate-panel .body{padding:0 10px}#translate-panel .body .bp5-card:first-child{margin-top:1px}#translate-panel .body .bp5-card:last-child{margin-bottom:1px}#translate-panel .body .no-api{margin:20px 0}.result-block{margin:8px 0;padding:2px 5px}.result-block .bp5-button{visibility:hidden}.result-block .error .bp5-button,.result-block:hover .bp5-button{visibility:visible}.result-block .legend{display:flex;align-items:center;justify-content:space-between}.result-block .legend .legend-left{display:flex;align-items:center}.result-block .legend .api-ico,.result-block .legend .bp5-heading{flex-shrink:0;white-space:nowrap}.result-block .legend .api-ico{display:inline-block;width:14px;height:14px;background-size:contain;margin-right:3px}.result-block .legend .bp5-heading{margin-bottom:0;margin-right:10px}.result-block .legend .source{cursor:pointer;font-size:12px;display:inline-flex;align-items:center}.result-block .legend .source .source-text{overflow:hidden}.result-block .legend .source .bp5-icon{position:relative;top:-1px;margin-left:1px}.result-block .phonetic{display:flex;flex-wrap:wrap}.result-block .phonetic .phonetic-item{display:flex;align-items:center;font-size:12px}.result-block .phonetic .phonetic-item:not(:last-child){margin-right:12px}.result-block .common-result p{line-height:1.3;margin:2px 0;overflow-wrap:break-word}.result-block .common-result .dict a{text-decoration:underline}.result-block .error{font-size:12px;padding:5px 10px}.result-block .dict-pos{margin-right:5px}.external-translators{margin-bottom:3px;padding:0;display:flex;flex-wrap:wrap}.external-translators>div{margin:0 5px 5px 0}.quick-links a{margin:0 5px 5px 0}#popper-container{width:250px;max-width:100%;position:absolute;left:0;top:0;z-index:9999999998;touch-action:none;transition:opacity .2s;background-color:#f6f7f9}.bp5-dark #popper-container{background-color:#252a31}#popper-container.show{opacity:1;pointer-events:auto;-moz-user-select:auto;user-select:auto}#popper-container,#popper-container[data-popper-reference-hidden=true]{opacity:0;pointer-events:none;-moz-user-select:none;user-select:none}#popper-container .drag-block{cursor:-webkit-grab;cursor:grab}#popper-container.pin{position:fixed}#popper-container.pin .arrow{display:none}#popper-container .arrow,#popper-container .arrow::before{position:absolute;width:8px;height:8px;z-index:-1}#popper-container .arrow::before{content:"";transform:rotate(45deg);background:#f6f7f9}.bp5-dark #popper-container .arrow::before{background-color:#252a31}#popper-container .arrow{display:none}#popper-container.show[data-popper-placement]:not([data-popper-reference-hidden=true]) .arrow{display:block}#popper-container[data-popper-placement^=top] .arrow{bottom:-5px}#popper-container[data-popper-placement^=top] .arrow::before{border-right:1px solid #d1d1d1;border-bottom:1px solid #d1d1d1}#popper-container[data-popper-placement^=bottom] .arrow{top:-5px}#popper-container[data-popper-placement^=bottom] .arrow::before{border-left:1px solid #d1d1d1;border-top:1px solid #d1d1d1}#popper-container[data-popper-placement^=left] .arrow{right:-5px}#popper-container[data-popper-placement^=left] .arrow::before{border-right:1px solid #d1d1d1;border-top:1px solid #d1d1d1}#popper-container[data-popper-placement^=right] .arrow{left:-5px}#popper-container[data-popper-placement^=right] .arrow::before{border-left:1px solid #d1d1d1;border-bottom:1px solid #d1d1d1}#translate-btn{display:none;position:absolute;z-index:9999999999;left:0;top:0}#translate-btn .bp5-button{padding:2px;min-width:0;min-height:0}#translate-btn .btn-icon{width:18px;height:18px;background-image:url(moz-extension://19651fe5-a2eb-4315-b2c9-0ae3c022c917/logo.png);background-size:contain}.bp5-dark #translate-btn .btn-icon{background-image:url(moz-extension://19651fe5-a2eb-4315-b2c9-0ae3c022c917/logowhite36.png)}#translate-btn.show{display:block}.translate-type-selector .bp5-label{display:inline}.translate-type-selector .bp5-radio{margin-bottom:0}#ocr-container{position:fixed;z-index:99999999999999;left:0;top:0;right:0;bottom:0}#ocr-container .toolbar{display:none;position:absolute;z-index:1}#ocr-container img{max-width:100%}#app{cursor:default}.switch-pin{flex-shrink:0;cursor:pointer}.switch-pin .bp5-icon-pin{transition:transform .2s,color .2s;transform:rotate(-45deg)}.pin .switch-pin .bp5-icon-pin{transform:rotate(-70deg)}.cut-btn{margin-left:2px}.app-toaster-container{position:fixed!important;z-index:9999999999!important}.app-toaster-container .bp5-toast{min-width:auto}#web-trs-panel .app-toaster-container{padding-right:0;padding-left:0}#web-trs-panel .page-trs-form-group{margin:0 0 0 0;align-items:center}#web-trs-panel .page-trs-form-group>label{width:70px}</style><div id=root dir=ltr><div id=app><div id=translate-btn class=sf-hidden></div><div id=popper-container style=width:290px;transform:translate(0px) class=bp5-elevation-4><div id=translate-panel class=size-small><div class=fixed><div class=header><div class=left><div class=switch-pin><button type=button class="bp5-button bp5-minimal bp5-small"><span aria-hidden=true class="bp5-icon bp5-icon-pin"><svg data-icon=pin height=14 role=img viewBox="0 0 16 16" width=14><path d="M9.41.92c-.51.51-.41 1.5.15 2.56L4.34 7.54C2.8 6.48 1.45 6.05.92 6.58l3.54 3.54-3.54 4.95 4.95-3.54 3.54 3.54c.53-.53.1-1.88-.96-3.42l4.06-5.22c1.06.56 2.04.66 2.55.15L9.41.92z" fill-rule=evenodd></path></svg></span></button></div><button type=button title=图片翻译 class="bp5-button bp5-minimal bp5-small"><span aria-hidden=true class="bp5-icon bp5-icon-media"><svg data-icon=media height=14 role=img viewBox="0 0 16 16" width=14><path d="M11.99 6.99c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm3-5h-14c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h14c.55 0 1-.45 1-1v-10c0-.55-.45-1-1-1zm-1 9l-5-3-1 2-3-4-3 5v-7h12v7z" fill-rule=evenodd></path></svg></span></button><button type=button title=语音翻译 class="bp5-button bp5-minimal bp5-small"><span class=bp5-icon><svg version=1.1 id=Capa_1 width=14 height=14 xmlns=http://www.w3.org/2000/svg xmlns:xlink=http://www.w3.org/1999/xlink x=0px y=0px viewBox="0 0 490.9 490.9" xml:space=preserve><g><g><path d="M245.5,322.9c53,0,96.2-43.2,96.2-96.2V96.2c0-53-43.2-96.2-96.2-96.2s-96.2,43.2-96.2,96.2v130.5 C149.3,279.8,192.5,322.9,245.5,322.9z M173.8,96.2c0-39.5,32.2-71.7,71.7-71.7s71.7,32.2,71.7,71.7v130.5 c0,39.5-32.2,71.7-71.7,71.7s-71.7-32.2-71.7-71.7V96.2z"></path><path d="M94.4,214.5c-6.8,0-12.3,5.5-12.3,12.3c0,85.9,66.7,156.6,151.1,162.8v76.7h-63.9c-6.8,0-12.3,5.5-12.3,12.3 s5.5,12.3,12.3,12.3h152.3c6.8,0,12.3-5.5,12.3-12.3s-5.5-12.3-12.3-12.3h-63.9v-76.7c84.4-6.3,151.1-76.9,151.1-162.8 c0-6.8-5.5-12.3-12.3-12.3s-12.3,5.5-12.3,12.3c0,76.6-62.3,138.9-138.9,138.9s-138.9-62.3-138.9-138.9 C106.6,220,101.2,214.5,94.4,214.5z"></path></g></g></svg></span></button></div><div class=drag-block title=按住不放可以拖动></div><div class=right><button type=button disabled title=添加到收藏夹 class="bp5-button bp5-disabled bp5-minimal bp5-small" tabindex=-1><span aria-hidden=true class="bp5-icon bp5-icon-star-empty"><svg data-icon=star-empty height=14 role=img viewBox="0 0 16 16" width=14><path d="M16 6.11l-5.53-.84L8 0 5.53 5.27 0 6.11l4 4.1L3.06 16 8 13.27 12.94 16 12 10.21l4-4.1zM4.91 13.2l.59-3.62L3 7.02l3.45-.53L8 3.2l1.55 3.29 3.45.53-2.5 2.56.59 3.62L8 11.49 4.91 13.2z" fill-rule=evenodd></path></svg></span></button><button type=button class="bp5-button bp5-minimal bp5-small settings" title=快捷设置><span aria-hidden=true class="bp5-icon bp5-icon-cog"><svg data-icon=cog height=14 role=img viewBox="0 0 16 16" width=14><path d="M15.19 6.39h-1.85c-.11-.37-.27-.71-.45-1.04l1.36-1.36c.31-.31.31-.82 0-1.13l-1.13-1.13a.803.803 0 00-1.13 0l-1.36 1.36c-.33-.17-.67-.33-1.04-.44V.79c0-.44-.36-.8-.8-.8h-1.6c-.44 0-.8.36-.8.8v1.86c-.39.12-.75.28-1.1.47l-1.3-1.3c-.3-.3-.79-.3-1.09 0L1.82 2.91c-.3.3-.3.79 0 1.09l1.3 1.3c-.2.34-.36.7-.48 1.09H.79c-.44 0-.8.36-.8.8v1.6c0 .44.36.8.8.8h1.85c.11.37.27.71.45 1.04l-1.36 1.36c-.31.31-.31.82 0 1.13l1.13 1.13c.31.31.82.31 1.13 0l1.36-1.36c.33.18.67.33 1.04.44v1.86c0 .44.36.8.8.8h1.6c.44 0 .8-.36.8-.8v-1.86c.39-.12.75-.28 1.1-.47l1.3 1.3c.3.3.79.3 1.09 0l1.09-1.09c.3-.3.3-.79 0-1.09l-1.3-1.3c.19-.35.36-.71.48-1.1h1.85c.44 0 .8-.36.8-.8v-1.6a.816.816 0 00-.81-.79zm-7.2 4.6c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3z" fill-rule=evenodd></path></svg></span></button><button type=button title=关闭(Esc) class="bp5-button bp5-minimal bp5-small"><span aria-hidden=true class="bp5-icon bp5-icon-cross"><svg data-icon=cross height=18 role=img viewBox="0 0 16 16" width=18><path d="M9.41 8l3.29-3.29c.19-.18.3-.43.3-.71a1.003 1.003 0 00-1.71-.71L8 6.59l-3.29-3.3a1.003 1.003 0 00-1.42 1.42L6.59 8 3.3 11.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71L8 9.41l3.29 3.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71L9.41 8z" fill-rule=evenodd></path></svg></span></button></div></div><div class=bp5-collapse><div class="bp5-collapse-body sf-hidden" aria-hidden=true></div></div></div><div class=body><p>请输入需要翻译的文本。</p></div></div><div class="arrow sf-hidden"></div></div><div id=web-trs-panel></div></div></div></template></div></div><script data-template-shadow-root>(()=>{document.currentScript.remove();processNode(document);function processNode(node){node.querySelectorAll("template[shadowrootmode]").forEach(element=>{let shadowRoot = element.parentElement.shadowRoot;if (!shadowRoot) {try {shadowRoot=element.parentElement.attachShadow({mode:element.getAttribute("shadowrootmode"),delegatesFocus:element.getAttribute("shadowrootdelegatesfocus")!=null,clonable:element.getAttribute("shadowrootclonable")!=null,serializable:element.getAttribute("shadowrootserializable")!=null});shadowRoot.innerHTML=element.innerHTML;element.remove()} catch (error) {} if (shadowRoot) {processNode(shadowRoot)}}})}})()</script>