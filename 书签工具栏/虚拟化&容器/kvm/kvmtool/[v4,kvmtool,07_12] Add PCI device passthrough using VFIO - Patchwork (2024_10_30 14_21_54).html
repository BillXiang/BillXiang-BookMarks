<!DOCTYPE html> <html xmlns=http://www.w3.org/1999/xhtml lang=en style><!--
 Page saved with SingleFile 
 url: https://patchwork.kernel.org/project/kvm/patch/20171122185823.7765-8-jean-philippe.brucker@arm.com/ 
 saved date: Wed Oct 30 2024 14:21:54 GMT+0800 (中国标准时间)
--><meta charset=utf-8>
<title>[v4,kvmtool,07/12] Add PCI device passthrough using VFIO - Patchwork</title>
<style>/*!
 * Bootstrap v3.2.0 (http://getbootstrap.com)
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 *//*! normalize.css v3.0.1 | MIT License | git.io/normalize */html{font-family:sans-serif;-webkit-text-size-adjust:100%;-ms-text-size-adjust:100%}body{margin:0}nav{display:block}template{display:none}a{background:0 0}a:active,a:hover{outline:0}h1{margin:.67em 0}svg:not(:root){overflow:hidden}pre{overflow:auto}button{margin:0;font:inherit;color:inherit}button{overflow:visible}button{text-transform:none}button{-webkit-appearance:button;cursor:pointer}button[disabled]{cursor:default}button::-moz-focus-inner,input::-moz-focus-inner{padding:0;border:0}table{border-spacing:0}@font-face{font-family:"Glyphicons Halflings";src:url(data:font/woff;base64,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)format("woff")}.glyphicon{position:relative;top:1px;display:inline-block;font-family:"Glyphicons Halflings";font-style:normal;font-weight:400;line-height:1;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.glyphicon-file:before{content:""}.glyphicon-info-sign:before{content:""}.glyphicon-gift:before{content:""}*{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}:before,:after{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}html{font-size:10px;-webkit-tap-highlight-color:rgba(0,0,0,0)}body{font-family:"Helvetica Neue",Helvetica,Arial,sans-serif;font-size:14px;line-height:1.42857143;color:#333;background-color:#fff}button{font-family:inherit;font-size:inherit;line-height:inherit}a{color:#428bca;text-decoration:none}a:hover,a:focus{color:#2a6496;text-decoration:underline}a:focus{outline:thin dotted;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}h1,h2{font-family:inherit;font-weight:500;line-height:1.1;color:inherit}h1,h2{margin-top:20px;margin-bottom:10px}h1{font-size:36px}p{margin:0 0 10px}@media (min-width:768px){}ul{margin-top:0}@media (min-width:768px){}pre{font-family:Menlo,Monaco,Consolas,"Courier New",monospace}pre{display:block;padding:9.5px;margin:0 0 10px;font-size:13px;color:#333;word-break:break-all;word-wrap:break-word;border:1px solid #ccc}@media (min-width:768px){}@media (min-width:992px){}@media (min-width:1200px){}.container-fluid{padding-right:15px;padding-left:15px;margin-right:auto;margin-left:auto}@media (min-width:768px){}@media (min-width:992px){}@media (min-width:1200px){}table{background-color:transparent}@media screen and (max-width:767px){}@media (min-width:768px){}@media (min-width:768px){}@media (min-width:768px){}@media (min-width:768px){}.btn{display:inline-block;padding:6px 12px;margin-bottom:0;font-size:14px;font-weight:400;line-height:1.42857143;text-align:center;white-space:nowrap;vertical-align:middle;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;background-image:none;border:1px solid transparent;border-radius:4px}.btn:focus,.btn:active:focus,.btn.active:focus{outline:thin dotted;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}.btn:hover,.btn:focus{color:#333;text-decoration:none}.btn:active,.btn.active{background-image:none;outline:0;-webkit-box-shadow:inset 0 3px 5px rgba(0,0,0,.125);box-shadow:inset 0 3px 5px rgba(0,0,0,.125)}.btn-default{color:#333;background-color:#fff;border-color:#ccc}.btn-default:hover,.btn-default:focus,.btn-default:active,.btn-default.active,.open>.dropdown-toggle.btn-default{color:#333;background-color:#e6e6e6;border-color:#adadad}.btn-default:active,.btn-default.active,.open>.dropdown-toggle.btn-default{background-image:none}.collapse{display:none}@media (min-width:768px){}.btn-group{position:relative;display:inline-block;vertical-align:middle}.btn-group>.btn{position:relative;float:left}.btn-group>.btn:hover,.btn-group-vertical>.btn:hover,.btn-group>.btn:focus,.btn-group-vertical>.btn:focus,.btn-group>.btn:active,.btn-group-vertical>.btn:active,.btn-group>.btn.active,.btn-group-vertical>.btn.active{z-index:2}.btn-group>.btn:focus,.btn-group-vertical>.btn:focus{outline:0}.btn-group .btn+.btn{margin-left:-1px}.btn-group>.btn:not(:first-child):not(:last-child):not(.dropdown-toggle){border-radius:0}.btn-group>.btn:first-child{margin-left:0}.btn-group>.btn:first-child:not(:last-child):not(.dropdown-toggle){border-top-right-radius:0;border-bottom-right-radius:0}.btn-group>.btn:last-child:not(:first-child),.btn-group>.dropdown-toggle:not(:first-child){border-top-left-radius:0;border-bottom-left-radius:0}.nav{padding-left:0;margin-bottom:0;list-style:none}.nav>li{position:relative;display:block}.nav>li>a{position:relative;display:block;padding:10px 15px}.nav>li>a:hover,.nav>li>a:focus{text-decoration:none;background-color:#eee}@media (min-width:768px){}@media (min-width:768px){}@media (min-width:768px){}@media (min-width:768px){}.navbar{position:relative;min-height:50px;margin-bottom:20px;border:1px solid transparent}@media (min-width:768px){.navbar{border-radius:4px}}@media (min-width:768px){.navbar-header{float:left}}.navbar-collapse{padding-right:15px;padding-left:15px;overflow-x:visible;-webkit-overflow-scrolling:touch;border-top:1px solid transparent;-webkit-box-shadow:inset 0 1px 0 rgba(255,255,255,.1);box-shadow:inset 0 1px 0 rgba(255,255,255,.1)}@media (min-width:768px){.navbar-collapse{width:auto;border-top:0;-webkit-box-shadow:none;box-shadow:none}.navbar-collapse.collapse{display:block!important;height:auto!important;padding-bottom:0;overflow:visible!important}.navbar-static-top .navbar-collapse{padding-right:0;padding-left:0}}@media (max-width:480px) and (orientation:landscape){}.container-fluid>.navbar-header,.container-fluid>.navbar-collapse{margin-right:-15px;margin-left:-15px}@media (min-width:768px){.container-fluid>.navbar-header,.container-fluid>.navbar-collapse{margin-right:0;margin-left:0}}.navbar-static-top{z-index:1000;border-width:0 0 1px}@media (min-width:768px){.navbar-static-top{border-radius:0}}@media (min-width:768px){}.navbar-brand{float:left;height:50px;padding:15px 15px;font-size:18px;line-height:20px}.navbar-brand:hover,.navbar-brand:focus{text-decoration:none}@media (min-width:768px){.navbar>.container-fluid .navbar-brand{margin-left:-15px}}@media (min-width:768px){}.navbar-nav{margin:7.5px -15px}.navbar-nav>li>a{padding-top:10px;padding-bottom:10px;line-height:20px}@media (max-width:767px){}@media (min-width:768px){.navbar-nav{float:left;margin:0}.navbar-nav>li{float:left}.navbar-nav>li>a{padding-top:15px;padding-bottom:15px}.navbar-nav.navbar-right:last-child{margin-right:-15px}}@media (min-width:768px){.navbar-right{float:right!important}}@media (min-width:768px){}@media (max-width:767px){}@media (min-width:768px){}@media (min-width:768px){}@media (max-width:767px){}.navbar-inverse{background-color:#222;border-color:#080808}.navbar-inverse .navbar-brand{color:#777}.navbar-inverse .navbar-brand:hover,.navbar-inverse .navbar-brand:focus{color:#fff;background-color:transparent}.navbar-inverse .navbar-nav>li>a:hover,.navbar-inverse .navbar-nav>li>a:focus{color:#fff;background-color:transparent}.navbar-inverse .navbar-collapse{border-color:#101010}@media (max-width:767px){}@media screen and (min-width:768px){}@-webkit-keyframes progress-bar-stripes{from{background-position:40px 0}to{background-position:0 0}}@-o-keyframes progress-bar-stripes{from{background-position:40px 0}to{background-position:0 0}}@keyframes progress-bar-stripes{from{background-position:40px 0}to{background-position:0 0}}@media (min-width:768px){}@media (min-width:992px){}@media screen and (min-width:768px){}.clearfix:before,.clearfix:after,.dl-horizontal dd:before,.dl-horizontal dd:after,.container:before,.container:after,.container-fluid:before,.container-fluid:after,.row:before,.row:after,.form-horizontal .form-group:before,.form-horizontal .form-group:after,.btn-toolbar:before,.btn-toolbar:after,.btn-group-vertical>.btn-group:before,.btn-group-vertical>.btn-group:after,.nav:before,.nav:after,.navbar:before,.navbar:after,.navbar-header:before,.navbar-header:after,.navbar-collapse:before,.navbar-collapse:after,.pager:before,.pager:after,.panel-body:before,.panel-body:after,.modal-footer:before,.modal-footer:after{display:table;content:" "}.clearfix:after,.dl-horizontal dd:after,.container:after,.container-fluid:after,.row:after,.form-horizontal .form-group:after,.btn-toolbar:after,.btn-group-vertical>.btn-group:after,.nav:after,.navbar:after,.navbar-header:after,.navbar-collapse:after,.pager:after,.panel-body:after,.modal-footer:after{clear:both}.pull-right{float:right!important}@-ms-viewport{width:device-width}@media (max-width:767px){}@media (max-width:767px){}@media (max-width:767px){}@media (max-width:767px){}@media (min-width:768px) and (max-width:991px){}@media (min-width:768px) and (max-width:991px){}@media (min-width:768px) and (max-width:991px){}@media (min-width:768px) and (max-width:991px){}@media (min-width:992px) and (max-width:1199px){}@media (min-width:992px) and (max-width:1199px){}@media (min-width:992px) and (max-width:1199px){}@media (min-width:992px) and (max-width:1199px){}@media (min-width:1200px){}@media (min-width:1200px){}@media (min-width:1200px){}@media (min-width:1200px){}@media (max-width:767px){}@media (min-width:768px) and (max-width:991px){}@media (min-width:992px) and (max-width:1199px){}@media (min-width:1200px){}</style>
<style>h2{font-size:25px;margin:18px 0 18px 0}pre{line-height:110%;background-color:white;border-radius:0}.navbar-inverse .navbar-nav>li>a{color:#999}.navbar-subbrand{float:left;height:50px;padding:15px 15px 15px 0;font-size:18px;line-height:20px}.navbar-subbrand{color:#999}table{border-collapse:collapse}#footer{padding:1em;font-size:small;text-align:center;color:#909090}#footer a{color:#909090}div.patchforms{margin-top:1em}table.patchmeta tr th,table.patchmeta tr td{text-align:left;padding:1px 10px;vertical-align:top}.comment .meta{background:#f0f0f0;padding:0.3em 0.5em}.comment .content{border:0}.patch .content{padding:1em}.quote{color:#007f00}span.p_header{color:#2e8b57;font-weight:bold}span.p_chunk{color:#a52a2a;font-weight:bold}span.p_context{color:#a020f0}span.p_add{color:#008b8b}span.p_del{color:#6a5acd}.signed-off-by{color:#672d45;font-weight:bold}</style>
<!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js">
    </script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/es5-shim/2.0.8/es5-shim.min.js"></script>
  <![endif]-->
<meta name=referrer content=no-referrer><style>.sf-hidden{display:none!important}</style><link rel=canonical href=https://patchwork.kernel.org/project/kvm/patch/20171122185823.7765-8-jean-philippe.brucker@arm.com/><meta http-equiv=content-security-policy content="default-src 'none'; font-src 'self' data:; img-src 'self' data:; style-src 'unsafe-inline'; media-src 'self' data:; script-src 'unsafe-inline' data:; object-src 'self' data:; frame-src 'self' data:;"><style>img[src="data:,"],source[src="data:,"]{display:none!important}</style></head>
 <body>
 <nav class="navbar navbar-inverse navbar-static-top">
 <div class=container-fluid>
 <div class=navbar-header>
 <button type=button class="navbar-toggle collapsed sf-hidden" data-toggle=collapse data-target=#navbar-collapse>
 
 
 
 
 </button>
 <a class=navbar-brand href=https://patchwork.kernel.org/>Patchwork</a>
 <span class=navbar-subbrand>
 KVM development
 </span>
 </div>
 <div class="collapse navbar-collapse" id=navbar-collapse>
 <ul class="nav navbar-nav">
 <li>
 <a href=https://patchwork.kernel.org/project/kvm/list/>
 <span class="glyphicon glyphicon-file"></span>
 Patches
 </a>
 </li>
 <li>
 <a href=https://patchwork.kernel.org/project/kvm/bundles/>
 <span class="glyphicon glyphicon-gift"></span>
 Bundles
 </a>
 </li>
 <li>
 <a href=https://patchwork.kernel.org/project/kvm/>
 <span class="glyphicon glyphicon-info-sign"></span>
 About this project
 </a>
 </li>
 </ul>
 <ul class="nav navbar-nav navbar-right">
 <li><a href=https://patchwork.kernel.org/user/login/>Login</a></li>
 <li><a href=https://patchwork.kernel.org/register/>Register</a></li>
 <li><a href=https://patchwork.kernel.org/mail/>Mail settings</a></li>
 </ul>
 </div>
 </div>
 </nav>
 <div class=container-fluid>
<div>
 <div class="btn-group pull-right">
 <button type=button class="btn btn-default btn-copy" data-clipboard-text=10070771 title="Copy to Clipboard">
 10070771
 </button>
 
 <a href=https://patchwork.kernel.org/project/kvm/patch/20171122185823.7765-8-jean-philippe.brucker@arm.com/raw/ class="btn btn-default" role=button title="Download patch diff">diff</a>
 <a href=https://patchwork.kernel.org/project/kvm/patch/20171122185823.7765-8-jean-philippe.brucker@arm.com/mbox/ class="btn btn-default" role=button title="Download patch mbox">mbox</a>
 
 
</div>
 <h1>[v4,kvmtool,07/12] Add PCI device passthrough using VFIO</h1>
</div>
<table class=patchmeta>
 <tbody><tr>
 <th>Message ID</th>
 
 <td>20171122185823.7765-8-jean-philippe.brucker@arm.com (<a href=https://lore.kernel.org/r/20171122185823.7765-8-jean-philippe.brucker@arm.com>mailing list archive</a>)</td>
 
 </tr>
 <tr>
 <th>State</th>
 <td>New, archived</td>
 </tr>
 <tr>
 <th>Headers</th>
 <td><a id=togglepatchheaders href=javascript:void(0)>show</a>
 <div id=patchheaders class=patchheaders style=display:none>
 
 </div>
 </td>
 </tr>
</table>
<div class=patchforms>
 <div style=clear:both>
 </div>
</div>
<h2>Commit Message</h2>
<div class=comment>
<div class=meta>
 <span><a href="https://patchwork.kernel.org/project/kvm/list/?submitter=97951">Jean-Philippe Brucker</a></span>
 <span class=pull-right>Nov. 22, 2017, 6:58 p.m. UTC</span>
</div>
<pre class=content>Assigning devices using VFIO allows the guest to have direct access to the
device, whilst filtering accesses to sensitive areas by trapping config
space accesses and mapping DMA with an IOMMU.

This patch adds a new option to lkvm run: --vfio-pci=&lt;BDF&gt;. Before
assigning a device to a VM, some preparation is required. As described in
Linux Documentation/vfio.txt, the device driver needs to be changed to
vfio-pci:

  $ dev=0000:00:00.0

  $ echo $dev &gt; /sys/bus/pci/devices/$dev/driver/unbind
  $ echo vfio-pci &gt; /sys/bus/pci/devices/$dev/driver_override
  $ echo $dev &gt; /sys/bus/pci/drivers_probe

Adding --vfio-pci=$dev to lkvm-run will pass the device to the guest.
Multiple devices can be passed to the guest by adding more --vfio-pci
parameters.

This patch only implements PCI with INTx. MSI-X routing will be added in a
subsequent patch, and at some point we might add support for passing
platform devices to guests.
<span class=signed-off-by>
Signed-off-by: Will Deacon &lt;will.deacon@arm.com&gt;</span>
<span class=signed-off-by>Signed-off-by: Robin Murphy &lt;robin.murphy@arm.com&gt;</span>
<span class=signed-off-by>Signed-off-by: Jean-Philippe Brucker &lt;jean-philippe.brucker@arm.com&gt;</span>

---
Changes v3-&gt;v4
* Pass individual devices on the command-line instead of the whole group
* Handle 64-bit BARs
* Remove VFIO_TYPE1_NESTED which isn't supported by x86 IOMMUs and
  cannot be probed with VFIO_CHECK_EXTENSION (we'll have to try
  VFIO_SET_IOMMU instead).
---
 Makefile                 |   2 +
 arm/pci.c                |   1 +
 builtin-run.c            |   5 +
 include/kvm/kvm-config.h |   3 +
 include/kvm/pci.h        |   3 +-
 include/kvm/vfio.h       |  71 +++++++
 vfio/core.c              | 488 +++++++++++++++++++++++++++++++++++++++++++++++
 vfio/pci.c               | 395 ++++++++++++++++++++++++++++++++++++++
 8 files changed, 967 insertions(+), 1 deletion(-)
 create mode 100644 include/kvm/vfio.h
 create mode 100644 vfio/core.c
 create mode 100644 vfio/pci.c
</pre>
</div>
<h2>Comments</h2>
<a name=21562583></a>
<div class=comment>
<div class=meta>
 <span><a href="https://patchwork.kernel.org/project/kvm/list/?submitter=58591">Punit Agrawal</a></span>
 <span class=pull-right>March 5, 2018, 3:11 p.m. UTC | <a href=https://patchwork.kernel.org/comment/21562583/>#1</a></span>
</div>
<pre class=content>Hi Jean-Philippe,

One comment below.

Jean-Philippe Brucker &lt;jean-philippe.brucker@arm.com&gt; writes:
<span class=quote>
&gt; Assigning devices using VFIO allows the guest to have direct access to the</span>
<span class=quote>&gt; device, whilst filtering accesses to sensitive areas by trapping config</span>
<span class=quote>&gt; space accesses and mapping DMA with an IOMMU.</span>
<span class=quote>&gt;</span>
<span class=quote>&gt; This patch adds a new option to lkvm run: --vfio-pci=&lt;BDF&gt;. Before</span>
<span class=quote>&gt; assigning a device to a VM, some preparation is required. As described in</span>
<span class=quote>&gt; Linux Documentation/vfio.txt, the device driver needs to be changed to</span>
<span class=quote>&gt; vfio-pci:</span>
<span class=quote>&gt;</span>
<span class=quote>&gt;   $ dev=0000:00:00.0</span>
<span class=quote>&gt;</span>
<span class=quote>&gt;   $ echo $dev &gt; /sys/bus/pci/devices/$dev/driver/unbind</span>
<span class=quote>&gt;   $ echo vfio-pci &gt; /sys/bus/pci/devices/$dev/driver_override</span>
<span class=quote>&gt;   $ echo $dev &gt; /sys/bus/pci/drivers_probe</span>
<span class=quote>&gt;</span>
<span class=quote>&gt; Adding --vfio-pci=$dev to lkvm-run will pass the device to the guest.</span>
<span class=quote>&gt; Multiple devices can be passed to the guest by adding more --vfio-pci</span>
<span class=quote>&gt; parameters.</span>
<span class=quote>&gt;</span>
<span class=quote>&gt; This patch only implements PCI with INTx. MSI-X routing will be added in a</span>
<span class=quote>&gt; subsequent patch, and at some point we might add support for passing</span>
<span class=quote>&gt; platform devices to guests.</span>
<span class=quote>&gt;</span>
<span class=quote>&gt; Signed-off-by: Will Deacon &lt;will.deacon@arm.com&gt;</span>
<span class=quote>&gt; Signed-off-by: Robin Murphy &lt;robin.murphy@arm.com&gt;</span>
<span class=quote>&gt; Signed-off-by: Jean-Philippe Brucker &lt;jean-philippe.brucker@arm.com&gt;</span>
<span class=quote>&gt;</span>
<span class=quote>&gt; ---</span>
<span class=quote>&gt; Changes v3-&gt;v4</span>
<span class=quote>&gt; * Pass individual devices on the command-line instead of the whole group</span>
<span class=quote>&gt; * Handle 64-bit BARs</span>
<span class=quote>&gt; * Remove VFIO_TYPE1_NESTED which isn't supported by x86 IOMMUs and</span>
<span class=quote>&gt;   cannot be probed with VFIO_CHECK_EXTENSION (we'll have to try</span>
<span class=quote>&gt;   VFIO_SET_IOMMU instead).</span>
<span class=quote>&gt; ---</span>
<span class=quote>&gt;  Makefile                 |   2 +</span>
<span class=quote>&gt;  arm/pci.c                |   1 +</span>
<span class=quote>&gt;  builtin-run.c            |   5 +</span>
<span class=quote>&gt;  include/kvm/kvm-config.h |   3 +</span>
<span class=quote>&gt;  include/kvm/pci.h        |   3 +-</span>
<span class=quote>&gt;  include/kvm/vfio.h       |  71 +++++++</span>
<span class=quote>&gt;  vfio/core.c              | 488 +++++++++++++++++++++++++++++++++++++++++++++++</span>
<span class=quote>&gt;  vfio/pci.c               | 395 ++++++++++++++++++++++++++++++++++++++</span>
<span class=quote>&gt;  8 files changed, 967 insertions(+), 1 deletion(-)</span>
<span class=quote>&gt;  create mode 100644 include/kvm/vfio.h</span>
<span class=quote>&gt;  create mode 100644 vfio/core.c</span>
<span class=quote>&gt;  create mode 100644 vfio/pci.c</span>
<span class=quote>&gt;</span>

[...]
<span class=quote>
&gt; diff --git a/vfio/core.c b/vfio/core.c</span>
<span class=quote>&gt; new file mode 100644</span>
<span class=quote>&gt; index 000000000000..e1b7366b9eda</span>
<span class=quote>&gt; --- /dev/null</span>
<span class=quote>&gt; +++ b/vfio/core.c</span>
<span class=quote>&gt; @@ -0,0 +1,488 @@</span>
<span class=quote>&gt; +#include "kvm/kvm.h"</span>
<span class=quote>&gt; +#include "kvm/vfio.h"</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +#include &lt;linux/list.h&gt;</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +#define VFIO_DEV_DIR		"/dev/vfio"</span>
<span class=quote>&gt; +#define VFIO_DEV_NODE		VFIO_DEV_DIR "/vfio"</span>
<span class=quote>&gt; +#define IOMMU_GROUP_DIR		"/sys/kernel/iommu_groups"</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +static int vfio_container;</span>
<span class=quote>&gt; +static LIST_HEAD(vfio_groups);</span>
<span class=quote>&gt; +static struct vfio_device *vfio_devices;</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +static int vfio_device_pci_parser(const struct option *opt, char *arg,</span>
<span class=quote>&gt; +				  struct vfio_device_params *dev)</span>
<span class=quote>&gt; +{</span>
<span class=quote>&gt; +	unsigned int domain, bus, devnr, fn;</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +	int nr = sscanf(arg, "%4x:%2x:%2x.%1x", &amp;domain, &amp;bus, &amp;devnr, &amp;fn);</span>
<span class=quote>&gt; +	if (nr &lt; 4) {</span>
<span class=quote>&gt; +		domain = 0;</span>
<span class=quote>&gt; +		nr = sscanf(arg, "%2x:%2x.%1x", &amp;bus, &amp;devnr, &amp;fn);</span>
<span class=quote>&gt; +		if (nr &lt; 3) {</span>
<span class=quote>&gt; +			pr_err("Invalid device identifier %s", arg);</span>
<span class=quote>&gt; +			return -EINVAL;</span>
<span class=quote>&gt; +		}</span>
<span class=quote>&gt; +	}</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +	dev-&gt;type = VFIO_DEVICE_PCI;</span>
<span class=quote>&gt; +	dev-&gt;bus = "pci";</span>
<span class=quote>&gt; +	dev-&gt;name = malloc(13);</span>
<span class=quote>&gt; +	if (!dev-&gt;name)</span>
<span class=quote>&gt; +		return -ENOMEM;</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +	snprintf(dev-&gt;name, 13, "%04x:%02x:%02x.%x", domain, bus, devnr, fn);</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +	return 0;</span>
<span class=quote>&gt; +}</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +int vfio_device_parser(const struct option *opt, const char *arg, int unset)</span>
<span class=quote>&gt; +{</span>
<span class=quote>&gt; +	int ret = -EINVAL;</span>
<span class=quote>&gt; +	static int idx = 0;</span>
<span class=quote>&gt; +	struct kvm *kvm = opt-&gt;ptr;</span>
<span class=quote>&gt; +	struct vfio_device_params *dev, *devs;</span>
<span class=quote>&gt; +	char *cur, *buf = strdup(arg);</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +	if (!buf)</span>
<span class=quote>&gt; +		return -ENOMEM;</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +	if (idx &gt;= MAX_VFIO_DEVICES) {</span>
<span class=quote>&gt; +		pr_warning("Too many VFIO devices");</span>
<span class=quote>&gt; +		goto out_free_buf;</span>
<span class=quote>&gt; +	}</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +	devs = realloc(kvm-&gt;cfg.vfio_devices, sizeof(*dev) * (idx + 1));</span>
<span class=quote>&gt; +	if (!devs) {</span>
<span class=quote>&gt; +		ret = -ENOMEM;</span>
<span class=quote>&gt; +		goto out_free_buf;</span>
<span class=quote>&gt; +	}</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +	kvm-&gt;cfg.vfio_devices = devs;</span>

I noticed that vfio_devices never gets freed. I'm not sure if this needs
fixing as I noticed a similar pattern in virtio as well.

The previous patches in the series look fine. I'll have a look at the
rest in the next couple of days.

Thanks,
Punit
<span class=quote>
&gt; +	dev = &amp;devs[idx];</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +	cur = strtok(buf, ",");</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +	if (!strcmp(opt-&gt;long_name, "vfio-pci"))</span>
<span class=quote>&gt; +		ret = vfio_device_pci_parser(opt, cur, dev);</span>
<span class=quote>&gt; +	else</span>
<span class=quote>&gt; +		ret = -EINVAL;</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +	if (!ret)</span>
<span class=quote>&gt; +		kvm-&gt;cfg.num_vfio_devices = ++idx;</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +out_free_buf:</span>
<span class=quote>&gt; +	free(buf);</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +	return ret;</span>
<span class=quote>&gt; +}</span>
<span class=quote>&gt; +</span>

[...]
</pre>
</div>
<a name=21567593></a>
<div class=comment>
<div class=meta>
 <span><a href="https://patchwork.kernel.org/project/kvm/list/?submitter=97951">Jean-Philippe Brucker</a></span>
 <span class=pull-right>March 6, 2018, 11:37 a.m. UTC | <a href=https://patchwork.kernel.org/comment/21567593/>#2</a></span>
</div>
<pre class=content>Hi Punit,

On 05/03/18 15:11, Punit Agrawal wrote:
<span class=quote>&gt;&gt; +	devs = realloc(kvm-&gt;cfg.vfio_devices, sizeof(*dev) * (idx + 1));</span>
<span class=quote>&gt;&gt; +	if (!devs) {</span>
<span class=quote>&gt;&gt; +		ret = -ENOMEM;</span>
<span class=quote>&gt;&gt; +		goto out_free_buf;</span>
<span class=quote>&gt;&gt; +	}</span>
<span class=quote>&gt;&gt; +</span>
<span class=quote>&gt;&gt; +	kvm-&gt;cfg.vfio_devices = devs;</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; I noticed that vfio_devices never gets freed. I'm not sure if this needs</span>
<span class=quote>&gt; fixing as I noticed a similar pattern in virtio as well.</span>

I think kvmtool is pretty lax when it comes to freeing permanent objects,
or cleaning up before dying. It often relies on the kernel to clean up on
process exit. The downside is that finding runtime memory leaks with
valgrind becomes a bit more difficult (on my current setup for example, I
can see 1.4M still reachable). So it's not worth doing tree-wide, but I
don't mind fixing this one. I think it's safe to free in vfio__exit.
<span class=quote>
&gt; The previous patches in the series look fine. I'll have a look at the</span>
<span class=quote>&gt; rest in the next couple of days.</span>

Thanks!
Jean
</pre>
</div>
<a name=21587633></a>
<div class=comment>
<div class=meta>
 <span><a href="https://patchwork.kernel.org/project/kvm/list/?submitter=58591">Punit Agrawal</a></span>
 <span class=pull-right>March 9, 2018, 4:53 p.m. UTC | <a href=https://patchwork.kernel.org/comment/21587633/>#3</a></span>
</div>
<pre class=content>Jean-Philippe Brucker &lt;jean-philippe.brucker@arm.com&gt; writes:
<span class=quote>
&gt; Hi Punit,</span>
<span class=quote>&gt;</span>
<span class=quote>&gt; On 05/03/18 15:11, Punit Agrawal wrote:</span>
<span class=quote>&gt;&gt;&gt; +	devs = realloc(kvm-&gt;cfg.vfio_devices, sizeof(*dev) * (idx + 1));</span>
<span class=quote>&gt;&gt;&gt; +	if (!devs) {</span>
<span class=quote>&gt;&gt;&gt; +		ret = -ENOMEM;</span>
<span class=quote>&gt;&gt;&gt; +		goto out_free_buf;</span>
<span class=quote>&gt;&gt;&gt; +	}</span>
<span class=quote>&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt; +	kvm-&gt;cfg.vfio_devices = devs;</span>
<span class=quote>&gt;&gt; </span>
<span class=quote>&gt;&gt; I noticed that vfio_devices never gets freed. I'm not sure if this needs</span>
<span class=quote>&gt;&gt; fixing as I noticed a similar pattern in virtio as well.</span>
<span class=quote>&gt;</span>
<span class=quote>&gt; I think kvmtool is pretty lax when it comes to freeing permanent objects,</span>
<span class=quote>&gt; or cleaning up before dying. It often relies on the kernel to clean up on</span>
<span class=quote>&gt; process exit. The downside is that finding runtime memory leaks with</span>
<span class=quote>&gt; valgrind becomes a bit more difficult (on my current setup for example, I</span>
<span class=quote>&gt; can see 1.4M still reachable). So it's not worth doing tree-wide, but I</span>
<span class=quote>&gt; don't mind fixing this one.</span>

Just to be clear, I wasn't suggesting for you to fix this issue
tree-wide. :)
<span class=quote>
&gt; I think it's safe to free in vfio__exit.</span>

It would be great if you can fix it for the patch though - considering
that all the other allocations are dealt with symmetrically, it'd be a
shame to leave this one out.
<span class=quote>
&gt;</span>
<span class=quote>&gt;&gt; The previous patches in the series look fine. I'll have a look at the</span>
<span class=quote>&gt;&gt; rest in the next couple of days.</span>
<span class=quote>&gt;</span>
<span class=quote>&gt; Thanks!</span>
<span class=quote>&gt; Jean</span>
</pre>
</div>
<div>
 <div class="btn-group pull-right">
 <button type=button class="btn btn-default btn-copy" data-clipboard-text=10070771 title="Copy to Clipboard">
 10070771
 </button>
 
 <a href=https://patchwork.kernel.org/project/kvm/patch/20171122185823.7765-8-jean-philippe.brucker@arm.com/raw/ class="btn btn-default" role=button title="Download patch diff">diff</a>
 <a href=https://patchwork.kernel.org/project/kvm/patch/20171122185823.7765-8-jean-philippe.brucker@arm.com/mbox/ class="btn btn-default" role=button title="Download patch mbox">mbox</a>
 
 
</div>
 <h2>Patch</h2>
</div>
<div id=patch class=patch>
<pre class=content><span class=p_header>diff --git a/Makefile b/Makefile</span>
<span class=p_header>index 030ff4e5a6e4..93dc0673571d 100644</span>
<span class=p_header>--- a/Makefile</span>
<span class=p_header>+++ b/Makefile</span>
<span class=p_chunk>@@ -59,6 +59,8 @@</span> <span class=p_context> OBJS	+= main.o</span>
 OBJS	+= mmio.o
 OBJS	+= pci.o
 OBJS	+= term.o
<span class=p_add>+OBJS	+= vfio/core.o</span>
<span class=p_add>+OBJS	+= vfio/pci.o</span>
 OBJS	+= virtio/blk.o
 OBJS	+= virtio/scsi.o
 OBJS	+= virtio/console.o
<span class=p_header>diff --git a/arm/pci.c b/arm/pci.c</span>
<span class=p_header>index 744b14c26a84..557cfa98938d 100644</span>
<span class=p_header>--- a/arm/pci.c</span>
<span class=p_header>+++ b/arm/pci.c</span>
<span class=p_chunk>@@ -1,5 +1,6 @@</span> <span class=p_context></span>
 #include "kvm/devices.h"
 #include "kvm/fdt.h"
<span class=p_add>+#include "kvm/kvm.h"</span>
 #include "kvm/of_pci.h"
 #include "kvm/pci.h"
 #include "kvm/util.h"
<span class=p_header>diff --git a/builtin-run.c b/builtin-run.c</span>
<span class=p_header>index b56aea7d174b..443c10ba48ca 100644</span>
<span class=p_header>--- a/builtin-run.c</span>
<span class=p_header>+++ b/builtin-run.c</span>
<span class=p_chunk>@@ -146,6 +146,11 @@</span> <span class=p_context> void kvm_run_set_wrapper_sandbox(void)</span>
 	OPT_BOOLEAN('\0', "no-dhcp", &amp;(cfg)-&gt;no_dhcp, "Disable kernel"	\
 			" DHCP in rootfs mode"),			\
 									\
<span class=p_add>+	OPT_GROUP("VFIO options:"),					\</span>
<span class=p_add>+	OPT_CALLBACK('\0', "vfio-pci", NULL, "[domain:]bus:dev.fn",	\</span>
<span class=p_add>+		     "Assign a PCI device to the virtual machine",	\</span>
<span class=p_add>+		     vfio_device_parser, kvm),				\</span>
<span class=p_add>+									\</span>
 	OPT_GROUP("Debug options:"),					\
 	OPT_BOOLEAN('\0', "debug", &amp;do_debug_print,			\
 			"Enable debug messages"),			\
<span class=p_header>diff --git a/include/kvm/kvm-config.h b/include/kvm/kvm-config.h</span>
<span class=p_header>index 386fa8c5931d..a052b0bc7582 100644</span>
<span class=p_header>--- a/include/kvm/kvm-config.h</span>
<span class=p_header>+++ b/include/kvm/kvm-config.h</span>
<span class=p_chunk>@@ -2,6 +2,7 @@</span> <span class=p_context></span>
 #define KVM_CONFIG_H_
 
 #include "kvm/disk-image.h"
<span class=p_add>+#include "kvm/vfio.h"</span>
 #include "kvm/kvm-config-arch.h"
 
 #define DEFAULT_KVM_DEV		"/dev/kvm"
<span class=p_chunk>@@ -20,9 +21,11 @@</span> <span class=p_context></span>
 struct kvm_config {
 	struct kvm_config_arch arch;
 	struct disk_image_params disk_image[MAX_DISK_IMAGES];
<span class=p_add>+	struct vfio_device_params *vfio_devices;</span>
 	u64 ram_size;
 	u8  image_count;
 	u8 num_net_devices;
<span class=p_add>+	u8 num_vfio_devices;</span>
 	bool virtio_rng;
 	int active_console;
 	int debug_iodelay;
<span class=p_header>diff --git a/include/kvm/pci.h b/include/kvm/pci.h</span>
<span class=p_header>index 01c244bcfb7f..274b77ea6371 100644</span>
<span class=p_header>--- a/include/kvm/pci.h</span>
<span class=p_header>+++ b/include/kvm/pci.h</span>
<span class=p_chunk>@@ -7,7 +7,6 @@</span> <span class=p_context></span>
 #include &lt;endian.h&gt;
 
 #include "kvm/devices.h"
<span class=p_del>-#include "kvm/kvm.h"</span>
 #include "kvm/msi.h"
 #include "kvm/fdt.h"
 
<span class=p_chunk>@@ -22,6 +21,8 @@</span> <span class=p_context></span>
 #define PCI_IO_SIZE		0x100
 #define PCI_CFG_SIZE		(1ULL &lt;&lt; 24)
 
<span class=p_add>+struct kvm;</span>
<span class=p_add>+</span>
 union pci_config_address {
 	struct {
 #if __BYTE_ORDER == __LITTLE_ENDIAN
<span class=p_header>diff --git a/include/kvm/vfio.h b/include/kvm/vfio.h</span>
new file mode 100644
<span class=p_header>index 000000000000..71b012184caf</span>
<span class=p_header>--- /dev/null</span>
<span class=p_header>+++ b/include/kvm/vfio.h</span>
<span class=p_chunk>@@ -0,0 +1,71 @@</span> <span class=p_context></span>
<span class=p_add>+#ifndef KVM__VFIO_H</span>
<span class=p_add>+#define KVM__VFIO_H</span>
<span class=p_add>+</span>
<span class=p_add>+#include "kvm/parse-options.h"</span>
<span class=p_add>+#include "kvm/pci.h"</span>
<span class=p_add>+</span>
<span class=p_add>+#include &lt;linux/vfio.h&gt;</span>
<span class=p_add>+</span>
<span class=p_add>+#define dev_err(vdev, fmt, ...) \</span>
<span class=p_add>+	pr_err("%s: " fmt, (vdev)-&gt;params-&gt;name, ##__VA_ARGS__)</span>
<span class=p_add>+#define dev_warn(vdev, fmt, ...) \</span>
<span class=p_add>+	pr_warning("%s: " fmt, (vdev)-&gt;params-&gt;name, ##__VA_ARGS__)</span>
<span class=p_add>+#define dev_info(vdev, fmt, ...) \</span>
<span class=p_add>+	pr_info("%s: " fmt, (vdev)-&gt;params-&gt;name, ##__VA_ARGS__)</span>
<span class=p_add>+#define dev_dbg(vdev, fmt, ...) \</span>
<span class=p_add>+	pr_debug("%s: " fmt, (vdev)-&gt;params-&gt;name, ##__VA_ARGS__)</span>
<span class=p_add>+#define dev_die(vdev, fmt, ...) \</span>
<span class=p_add>+	die("%s: " fmt, (vdev)-&gt;params-&gt;name, ##__VA_ARGS__)</span>
<span class=p_add>+</span>
<span class=p_add>+/* Currently limited by num_vfio_devices */</span>
<span class=p_add>+#define MAX_VFIO_DEVICES		256</span>
<span class=p_add>+</span>
<span class=p_add>+enum vfio_device_type {</span>
<span class=p_add>+	VFIO_DEVICE_PCI,</span>
<span class=p_add>+};</span>
<span class=p_add>+</span>
<span class=p_add>+struct vfio_pci_device {</span>
<span class=p_add>+	struct pci_device_header	hdr;</span>
<span class=p_add>+};</span>
<span class=p_add>+</span>
<span class=p_add>+struct vfio_region {</span>
<span class=p_add>+	struct vfio_region_info		info;</span>
<span class=p_add>+	u64				guest_phys_addr;</span>
<span class=p_add>+	void				*host_addr;</span>
<span class=p_add>+};</span>
<span class=p_add>+</span>
<span class=p_add>+struct vfio_device {</span>
<span class=p_add>+	struct device_header		dev_hdr;</span>
<span class=p_add>+	struct vfio_device_params	*params;</span>
<span class=p_add>+	struct vfio_group		*group;</span>
<span class=p_add>+</span>
<span class=p_add>+	int				fd;</span>
<span class=p_add>+	struct vfio_device_info		info;</span>
<span class=p_add>+	struct vfio_region		*regions;</span>
<span class=p_add>+</span>
<span class=p_add>+	char				*sysfs_path;</span>
<span class=p_add>+</span>
<span class=p_add>+	struct vfio_pci_device		pci;</span>
<span class=p_add>+};</span>
<span class=p_add>+</span>
<span class=p_add>+struct vfio_device_params {</span>
<span class=p_add>+	char				*name;</span>
<span class=p_add>+	const char			*bus;</span>
<span class=p_add>+	enum vfio_device_type		type;</span>
<span class=p_add>+};</span>
<span class=p_add>+</span>
<span class=p_add>+struct vfio_group {</span>
<span class=p_add>+	unsigned long			id; /* iommu_group number in sysfs */</span>
<span class=p_add>+	int				fd;</span>
<span class=p_add>+	int				refs;</span>
<span class=p_add>+	struct list_head		list;</span>
<span class=p_add>+};</span>
<span class=p_add>+</span>
<span class=p_add>+int vfio_device_parser(const struct option *opt, const char *arg, int unset);</span>
<span class=p_add>+int vfio_map_region(struct kvm *kvm, struct vfio_device *vdev,</span>
<span class=p_add>+		    struct vfio_region *region);</span>
<span class=p_add>+void vfio_unmap_region(struct kvm *kvm, struct vfio_region *region);</span>
<span class=p_add>+int vfio_pci_setup_device(struct kvm *kvm, struct vfio_device *device);</span>
<span class=p_add>+void vfio_pci_teardown_device(struct kvm *kvm, struct vfio_device *vdev);</span>
<span class=p_add>+</span>
<span class=p_add>+#endif /* KVM__VFIO_H */</span>
<span class=p_header>diff --git a/vfio/core.c b/vfio/core.c</span>
new file mode 100644
<span class=p_header>index 000000000000..e1b7366b9eda</span>
<span class=p_header>--- /dev/null</span>
<span class=p_header>+++ b/vfio/core.c</span>
<span class=p_chunk>@@ -0,0 +1,488 @@</span> <span class=p_context></span>
<span class=p_add>+#include "kvm/kvm.h"</span>
<span class=p_add>+#include "kvm/vfio.h"</span>
<span class=p_add>+</span>
<span class=p_add>+#include &lt;linux/list.h&gt;</span>
<span class=p_add>+</span>
<span class=p_add>+#define VFIO_DEV_DIR		"/dev/vfio"</span>
<span class=p_add>+#define VFIO_DEV_NODE		VFIO_DEV_DIR "/vfio"</span>
<span class=p_add>+#define IOMMU_GROUP_DIR		"/sys/kernel/iommu_groups"</span>
<span class=p_add>+</span>
<span class=p_add>+static int vfio_container;</span>
<span class=p_add>+static LIST_HEAD(vfio_groups);</span>
<span class=p_add>+static struct vfio_device *vfio_devices;</span>
<span class=p_add>+</span>
<span class=p_add>+static int vfio_device_pci_parser(const struct option *opt, char *arg,</span>
<span class=p_add>+				  struct vfio_device_params *dev)</span>
<span class=p_add>+{</span>
<span class=p_add>+	unsigned int domain, bus, devnr, fn;</span>
<span class=p_add>+</span>
<span class=p_add>+	int nr = sscanf(arg, "%4x:%2x:%2x.%1x", &amp;domain, &amp;bus, &amp;devnr, &amp;fn);</span>
<span class=p_add>+	if (nr &lt; 4) {</span>
<span class=p_add>+		domain = 0;</span>
<span class=p_add>+		nr = sscanf(arg, "%2x:%2x.%1x", &amp;bus, &amp;devnr, &amp;fn);</span>
<span class=p_add>+		if (nr &lt; 3) {</span>
<span class=p_add>+			pr_err("Invalid device identifier %s", arg);</span>
<span class=p_add>+			return -EINVAL;</span>
<span class=p_add>+		}</span>
<span class=p_add>+	}</span>
<span class=p_add>+</span>
<span class=p_add>+	dev-&gt;type = VFIO_DEVICE_PCI;</span>
<span class=p_add>+	dev-&gt;bus = "pci";</span>
<span class=p_add>+	dev-&gt;name = malloc(13);</span>
<span class=p_add>+	if (!dev-&gt;name)</span>
<span class=p_add>+		return -ENOMEM;</span>
<span class=p_add>+</span>
<span class=p_add>+	snprintf(dev-&gt;name, 13, "%04x:%02x:%02x.%x", domain, bus, devnr, fn);</span>
<span class=p_add>+</span>
<span class=p_add>+	return 0;</span>
<span class=p_add>+}</span>
<span class=p_add>+</span>
<span class=p_add>+int vfio_device_parser(const struct option *opt, const char *arg, int unset)</span>
<span class=p_add>+{</span>
<span class=p_add>+	int ret = -EINVAL;</span>
<span class=p_add>+	static int idx = 0;</span>
<span class=p_add>+	struct kvm *kvm = opt-&gt;ptr;</span>
<span class=p_add>+	struct vfio_device_params *dev, *devs;</span>
<span class=p_add>+	char *cur, *buf = strdup(arg);</span>
<span class=p_add>+</span>
<span class=p_add>+	if (!buf)</span>
<span class=p_add>+		return -ENOMEM;</span>
<span class=p_add>+</span>
<span class=p_add>+	if (idx &gt;= MAX_VFIO_DEVICES) {</span>
<span class=p_add>+		pr_warning("Too many VFIO devices");</span>
<span class=p_add>+		goto out_free_buf;</span>
<span class=p_add>+	}</span>
<span class=p_add>+</span>
<span class=p_add>+	devs = realloc(kvm-&gt;cfg.vfio_devices, sizeof(*dev) * (idx + 1));</span>
<span class=p_add>+	if (!devs) {</span>
<span class=p_add>+		ret = -ENOMEM;</span>
<span class=p_add>+		goto out_free_buf;</span>
<span class=p_add>+	}</span>
<span class=p_add>+</span>
<span class=p_add>+	kvm-&gt;cfg.vfio_devices = devs;</span>
<span class=p_add>+	dev = &amp;devs[idx];</span>
<span class=p_add>+</span>
<span class=p_add>+	cur = strtok(buf, ",");</span>
<span class=p_add>+</span>
<span class=p_add>+	if (!strcmp(opt-&gt;long_name, "vfio-pci"))</span>
<span class=p_add>+		ret = vfio_device_pci_parser(opt, cur, dev);</span>
<span class=p_add>+	else</span>
<span class=p_add>+		ret = -EINVAL;</span>
<span class=p_add>+</span>
<span class=p_add>+	if (!ret)</span>
<span class=p_add>+		kvm-&gt;cfg.num_vfio_devices = ++idx;</span>
<span class=p_add>+</span>
<span class=p_add>+out_free_buf:</span>
<span class=p_add>+	free(buf);</span>
<span class=p_add>+</span>
<span class=p_add>+	return ret;</span>
<span class=p_add>+}</span>
<span class=p_add>+</span>
<span class=p_add>+int vfio_map_region(struct kvm *kvm, struct vfio_device *vdev,</span>
<span class=p_add>+		    struct vfio_region *region)</span>
<span class=p_add>+{</span>
<span class=p_add>+	void *base;</span>
<span class=p_add>+	int ret, prot = 0;</span>
<span class=p_add>+	/* KVM needs page-aligned regions */</span>
<span class=p_add>+	u64 map_size = ALIGN(region-&gt;info.size, PAGE_SIZE);</span>
<span class=p_add>+</span>
<span class=p_add>+	/*</span>
<span class=p_add>+	 * We don't want to mess about trapping config accesses, so require that</span>
<span class=p_add>+	 * they can be mmap'd. Note that for PCI, this precludes the use of I/O</span>
<span class=p_add>+	 * BARs in the guest (we will hide them from Configuration Space, which</span>
<span class=p_add>+	 * is trapped).</span>
<span class=p_add>+	 */</span>
<span class=p_add>+	if (!(region-&gt;info.flags &amp; VFIO_REGION_INFO_FLAG_MMAP)) {</span>
<span class=p_add>+		dev_info(vdev, "ignoring region %u, as it can't be mmap'd",</span>
<span class=p_add>+			 region-&gt;info.index);</span>
<span class=p_add>+		return 0;</span>
<span class=p_add>+	}</span>
<span class=p_add>+</span>
<span class=p_add>+	if (region-&gt;info.flags &amp; VFIO_REGION_INFO_FLAG_READ)</span>
<span class=p_add>+		prot |= PROT_READ;</span>
<span class=p_add>+	if (region-&gt;info.flags &amp; VFIO_REGION_INFO_FLAG_WRITE)</span>
<span class=p_add>+		prot |= PROT_WRITE;</span>
<span class=p_add>+</span>
<span class=p_add>+	base = mmap(NULL, region-&gt;info.size, prot, MAP_SHARED, vdev-&gt;fd,</span>
<span class=p_add>+		    region-&gt;info.offset);</span>
<span class=p_add>+	if (base == MAP_FAILED) {</span>
<span class=p_add>+		ret = -errno;</span>
<span class=p_add>+		dev_err(vdev, "failed to mmap region %u (0x%llx bytes)",</span>
<span class=p_add>+			region-&gt;info.index, region-&gt;info.size);</span>
<span class=p_add>+		return ret;</span>
<span class=p_add>+	}</span>
<span class=p_add>+	region-&gt;host_addr = base;</span>
<span class=p_add>+</span>
<span class=p_add>+	ret = kvm__register_dev_mem(kvm, region-&gt;guest_phys_addr, map_size,</span>
<span class=p_add>+				    region-&gt;host_addr);</span>
<span class=p_add>+	if (ret) {</span>
<span class=p_add>+		dev_err(vdev, "failed to register region with KVM");</span>
<span class=p_add>+		return ret;</span>
<span class=p_add>+	}</span>
<span class=p_add>+</span>
<span class=p_add>+	return 0;</span>
<span class=p_add>+}</span>
<span class=p_add>+</span>
<span class=p_add>+void vfio_unmap_region(struct kvm *kvm, struct vfio_region *region)</span>
<span class=p_add>+{</span>
<span class=p_add>+	munmap(region-&gt;host_addr, region-&gt;info.size);</span>
<span class=p_add>+}</span>
<span class=p_add>+</span>
<span class=p_add>+static int vfio_configure_device(struct kvm *kvm, struct vfio_device *vdev)</span>
<span class=p_add>+{</span>
<span class=p_add>+	int ret;</span>
<span class=p_add>+	struct vfio_group *group = vdev-&gt;group;</span>
<span class=p_add>+</span>
<span class=p_add>+	vdev-&gt;fd = ioctl(group-&gt;fd, VFIO_GROUP_GET_DEVICE_FD,</span>
<span class=p_add>+			 vdev-&gt;params-&gt;name);</span>
<span class=p_add>+	if (vdev-&gt;fd &lt; 0) {</span>
<span class=p_add>+		dev_warn(vdev, "failed to get fd");</span>
<span class=p_add>+</span>
<span class=p_add>+		/* The device might be a bridge without an fd */</span>
<span class=p_add>+		return 0;</span>
<span class=p_add>+	}</span>
<span class=p_add>+</span>
<span class=p_add>+	vdev-&gt;info.argsz = sizeof(vdev-&gt;info);</span>
<span class=p_add>+	if (ioctl(vdev-&gt;fd, VFIO_DEVICE_GET_INFO, &amp;vdev-&gt;info)) {</span>
<span class=p_add>+		ret = -errno;</span>
<span class=p_add>+		dev_err(vdev, "failed to get info");</span>
<span class=p_add>+		goto err_close_device;</span>
<span class=p_add>+	}</span>
<span class=p_add>+</span>
<span class=p_add>+	if (vdev-&gt;info.flags &amp; VFIO_DEVICE_FLAGS_RESET &amp;&amp;</span>
<span class=p_add>+	    ioctl(vdev-&gt;fd, VFIO_DEVICE_RESET) &lt; 0)</span>
<span class=p_add>+		dev_warn(vdev, "failed to reset device");</span>
<span class=p_add>+</span>
<span class=p_add>+	vdev-&gt;regions = calloc(vdev-&gt;info.num_regions, sizeof(*vdev-&gt;regions));</span>
<span class=p_add>+	if (!vdev-&gt;regions) {</span>
<span class=p_add>+		ret = -ENOMEM;</span>
<span class=p_add>+		goto err_close_device;</span>
<span class=p_add>+	}</span>
<span class=p_add>+</span>
<span class=p_add>+	/* Now for the bus-specific initialization... */</span>
<span class=p_add>+	switch (vdev-&gt;params-&gt;type) {</span>
<span class=p_add>+	case VFIO_DEVICE_PCI:</span>
<span class=p_add>+		BUG_ON(!(vdev-&gt;info.flags &amp; VFIO_DEVICE_FLAGS_PCI));</span>
<span class=p_add>+		ret = vfio_pci_setup_device(kvm, vdev);</span>
<span class=p_add>+		break;</span>
<span class=p_add>+	default:</span>
<span class=p_add>+		BUG_ON(1);</span>
<span class=p_add>+		ret = -EINVAL;</span>
<span class=p_add>+	}</span>
<span class=p_add>+</span>
<span class=p_add>+	if (ret)</span>
<span class=p_add>+		goto err_free_regions;</span>
<span class=p_add>+</span>
<span class=p_add>+	dev_info(vdev, "assigned to device number 0x%x in group %lu",</span>
<span class=p_add>+		 vdev-&gt;dev_hdr.dev_num, group-&gt;id);</span>
<span class=p_add>+</span>
<span class=p_add>+	return 0;</span>
<span class=p_add>+</span>
<span class=p_add>+err_free_regions:</span>
<span class=p_add>+	free(vdev-&gt;regions);</span>
<span class=p_add>+err_close_device:</span>
<span class=p_add>+	close(vdev-&gt;fd);</span>
<span class=p_add>+</span>
<span class=p_add>+	return ret;</span>
<span class=p_add>+}</span>
<span class=p_add>+</span>
<span class=p_add>+static int vfio_configure_devices(struct kvm *kvm)</span>
<span class=p_add>+{</span>
<span class=p_add>+	int i, ret;</span>
<span class=p_add>+</span>
<span class=p_add>+	for (i = 0; i &lt; kvm-&gt;cfg.num_vfio_devices; ++i) {</span>
<span class=p_add>+		ret = vfio_configure_device(kvm, &amp;vfio_devices[i]);</span>
<span class=p_add>+		if (ret)</span>
<span class=p_add>+			return ret;</span>
<span class=p_add>+	}</span>
<span class=p_add>+</span>
<span class=p_add>+	return 0;</span>
<span class=p_add>+}</span>
<span class=p_add>+</span>
<span class=p_add>+static int vfio_get_iommu_type(void)</span>
<span class=p_add>+{</span>
<span class=p_add>+	if (ioctl(vfio_container, VFIO_CHECK_EXTENSION, VFIO_TYPE1v2_IOMMU))</span>
<span class=p_add>+		return VFIO_TYPE1v2_IOMMU;</span>
<span class=p_add>+</span>
<span class=p_add>+	if (ioctl(vfio_container, VFIO_CHECK_EXTENSION, VFIO_TYPE1_IOMMU))</span>
<span class=p_add>+		return VFIO_TYPE1_IOMMU;</span>
<span class=p_add>+</span>
<span class=p_add>+	return -ENODEV;</span>
<span class=p_add>+}</span>
<span class=p_add>+</span>
<span class=p_add>+static int vfio_map_mem_bank(struct kvm *kvm, struct kvm_mem_bank *bank, void *data)</span>
<span class=p_add>+{</span>
<span class=p_add>+	int ret = 0;</span>
<span class=p_add>+	struct vfio_iommu_type1_dma_map dma_map = {</span>
<span class=p_add>+		.argsz	= sizeof(dma_map),</span>
<span class=p_add>+		.flags	= VFIO_DMA_MAP_FLAG_READ | VFIO_DMA_MAP_FLAG_WRITE,</span>
<span class=p_add>+		.vaddr	= (unsigned long)bank-&gt;host_addr,</span>
<span class=p_add>+		.iova	= (u64)bank-&gt;guest_phys_addr,</span>
<span class=p_add>+		.size	= bank-&gt;size,</span>
<span class=p_add>+	};</span>
<span class=p_add>+</span>
<span class=p_add>+	/* Map the guest memory for DMA (i.e. provide isolation) */</span>
<span class=p_add>+	if (ioctl(vfio_container, VFIO_IOMMU_MAP_DMA, &amp;dma_map)) {</span>
<span class=p_add>+		ret = -errno;</span>
<span class=p_add>+		pr_err("Failed to map 0x%llx -&gt; 0x%llx (%llu) for DMA",</span>
<span class=p_add>+		       dma_map.iova, dma_map.vaddr, dma_map.size);</span>
<span class=p_add>+	}</span>
<span class=p_add>+</span>
<span class=p_add>+	return ret;</span>
<span class=p_add>+}</span>
<span class=p_add>+</span>
<span class=p_add>+static int vfio_unmap_mem_bank(struct kvm *kvm, struct kvm_mem_bank *bank, void *data)</span>
<span class=p_add>+{</span>
<span class=p_add>+	struct vfio_iommu_type1_dma_unmap dma_unmap = {</span>
<span class=p_add>+		.argsz = sizeof(dma_unmap),</span>
<span class=p_add>+		.size = bank-&gt;size,</span>
<span class=p_add>+		.iova = bank-&gt;guest_phys_addr,</span>
<span class=p_add>+	};</span>
<span class=p_add>+</span>
<span class=p_add>+	ioctl(vfio_container, VFIO_IOMMU_UNMAP_DMA, &amp;dma_unmap);</span>
<span class=p_add>+</span>
<span class=p_add>+	return 0;</span>
<span class=p_add>+}</span>
<span class=p_add>+</span>
<span class=p_add>+static struct vfio_group *vfio_group_create(struct kvm *kvm, unsigned long id)</span>
<span class=p_add>+{</span>
<span class=p_add>+	int ret;</span>
<span class=p_add>+	struct vfio_group *group;</span>
<span class=p_add>+	char group_node[PATH_MAX];</span>
<span class=p_add>+	struct vfio_group_status group_status = {</span>
<span class=p_add>+		.argsz = sizeof(group_status),</span>
<span class=p_add>+	};</span>
<span class=p_add>+</span>
<span class=p_add>+	group = calloc(1, sizeof(*group));</span>
<span class=p_add>+	if (!group)</span>
<span class=p_add>+		return NULL;</span>
<span class=p_add>+</span>
<span class=p_add>+	group-&gt;id	= id;</span>
<span class=p_add>+	group-&gt;refs	= 1;</span>
<span class=p_add>+</span>
<span class=p_add>+	ret = snprintf(group_node, PATH_MAX, VFIO_DEV_DIR "/%lu", id);</span>
<span class=p_add>+	if (ret &lt; 0 || ret == PATH_MAX)</span>
<span class=p_add>+		return NULL;</span>
<span class=p_add>+</span>
<span class=p_add>+	group-&gt;fd = open(group_node, O_RDWR);</span>
<span class=p_add>+	if (group-&gt;fd &lt; 0) {</span>
<span class=p_add>+		pr_err("Failed to open IOMMU group %s", group_node);</span>
<span class=p_add>+		goto err_free_group;</span>
<span class=p_add>+	}</span>
<span class=p_add>+</span>
<span class=p_add>+	if (ioctl(group-&gt;fd, VFIO_GROUP_GET_STATUS, &amp;group_status)) {</span>
<span class=p_add>+		pr_err("Failed to determine status of IOMMU group %lu", id);</span>
<span class=p_add>+		goto err_close_group;</span>
<span class=p_add>+	}</span>
<span class=p_add>+</span>
<span class=p_add>+	if (!(group_status.flags &amp; VFIO_GROUP_FLAGS_VIABLE)) {</span>
<span class=p_add>+		pr_err("IOMMU group %lu is not viable", id);</span>
<span class=p_add>+		goto err_close_group;</span>
<span class=p_add>+	}</span>
<span class=p_add>+</span>
<span class=p_add>+	if (ioctl(group-&gt;fd, VFIO_GROUP_SET_CONTAINER, &amp;vfio_container)) {</span>
<span class=p_add>+		pr_err("Failed to add IOMMU group %lu to VFIO container", id);</span>
<span class=p_add>+		goto err_close_group;</span>
<span class=p_add>+	}</span>
<span class=p_add>+</span>
<span class=p_add>+	list_add(&amp;group-&gt;list, &amp;vfio_groups);</span>
<span class=p_add>+</span>
<span class=p_add>+	return group;</span>
<span class=p_add>+</span>
<span class=p_add>+err_close_group:</span>
<span class=p_add>+	close(group-&gt;fd);</span>
<span class=p_add>+err_free_group:</span>
<span class=p_add>+	free(group);</span>
<span class=p_add>+</span>
<span class=p_add>+	return NULL;</span>
<span class=p_add>+}</span>
<span class=p_add>+</span>
<span class=p_add>+static void vfio_group_exit(struct kvm *kvm, struct vfio_group *group)</span>
<span class=p_add>+{</span>
<span class=p_add>+	if (--group-&gt;refs != 0)</span>
<span class=p_add>+		return;</span>
<span class=p_add>+</span>
<span class=p_add>+	ioctl(group-&gt;fd, VFIO_GROUP_UNSET_CONTAINER);</span>
<span class=p_add>+</span>
<span class=p_add>+	list_del(&amp;group-&gt;list);</span>
<span class=p_add>+	close(group-&gt;fd);</span>
<span class=p_add>+	free(group);</span>
<span class=p_add>+}</span>
<span class=p_add>+</span>
<span class=p_add>+static struct vfio_group *</span>
<span class=p_add>+vfio_group_get_for_dev(struct kvm *kvm, struct vfio_device *vdev)</span>
<span class=p_add>+{</span>
<span class=p_add>+	int dirfd;</span>
<span class=p_add>+	ssize_t ret;</span>
<span class=p_add>+	char *group_name;</span>
<span class=p_add>+	unsigned long group_id;</span>
<span class=p_add>+	char group_path[PATH_MAX];</span>
<span class=p_add>+	struct vfio_group *group = NULL;</span>
<span class=p_add>+</span>
<span class=p_add>+	/* Find IOMMU group for this device */</span>
<span class=p_add>+	dirfd = open(vdev-&gt;sysfs_path, O_DIRECTORY | O_PATH | O_RDONLY);</span>
<span class=p_add>+	if (dirfd &lt; 0) {</span>
<span class=p_add>+		dev_err(vdev, "failed to open '%s'", vdev-&gt;sysfs_path);</span>
<span class=p_add>+		return NULL;</span>
<span class=p_add>+	}</span>
<span class=p_add>+</span>
<span class=p_add>+	ret = readlinkat(dirfd, "iommu_group", group_path, PATH_MAX);</span>
<span class=p_add>+	if (ret &lt; 0) {</span>
<span class=p_add>+		dev_err(vdev, "no iommu_group");</span>
<span class=p_add>+		goto out_close;</span>
<span class=p_add>+	}</span>
<span class=p_add>+	if (ret == PATH_MAX)</span>
<span class=p_add>+		goto out_close;</span>
<span class=p_add>+</span>
<span class=p_add>+	group_path[ret] = '\0';</span>
<span class=p_add>+</span>
<span class=p_add>+	group_name = basename(group_path);</span>
<span class=p_add>+	errno = 0;</span>
<span class=p_add>+	group_id = strtoul(group_name, NULL, 10);</span>
<span class=p_add>+	if (errno)</span>
<span class=p_add>+		goto out_close;</span>
<span class=p_add>+</span>
<span class=p_add>+	list_for_each_entry(group, &amp;vfio_groups, list) {</span>
<span class=p_add>+		if (group-&gt;id == group_id) {</span>
<span class=p_add>+			group-&gt;refs++;</span>
<span class=p_add>+			return group;</span>
<span class=p_add>+		}</span>
<span class=p_add>+	}</span>
<span class=p_add>+</span>
<span class=p_add>+	group = vfio_group_create(kvm, group_id);</span>
<span class=p_add>+</span>
<span class=p_add>+out_close:</span>
<span class=p_add>+	close(dirfd);</span>
<span class=p_add>+	return group;</span>
<span class=p_add>+}</span>
<span class=p_add>+</span>
<span class=p_add>+static int vfio_device_init(struct kvm *kvm, struct vfio_device *vdev)</span>
<span class=p_add>+{</span>
<span class=p_add>+	int ret;</span>
<span class=p_add>+	char dev_path[PATH_MAX];</span>
<span class=p_add>+	struct vfio_group *group;</span>
<span class=p_add>+</span>
<span class=p_add>+	ret = snprintf(dev_path, PATH_MAX, "/sys/bus/%s/devices/%s",</span>
<span class=p_add>+		       vdev-&gt;params-&gt;bus, vdev-&gt;params-&gt;name);</span>
<span class=p_add>+	if (ret &lt; 0 || ret == PATH_MAX)</span>
<span class=p_add>+		return -EINVAL;</span>
<span class=p_add>+</span>
<span class=p_add>+	vdev-&gt;sysfs_path = strndup(dev_path, PATH_MAX);</span>
<span class=p_add>+	if (!vdev-&gt;sysfs_path)</span>
<span class=p_add>+		return -errno;</span>
<span class=p_add>+</span>
<span class=p_add>+	group = vfio_group_get_for_dev(kvm, vdev);</span>
<span class=p_add>+	if (!group) {</span>
<span class=p_add>+		free(vdev-&gt;sysfs_path);</span>
<span class=p_add>+		return -EINVAL;</span>
<span class=p_add>+	}</span>
<span class=p_add>+</span>
<span class=p_add>+	vdev-&gt;group = group;</span>
<span class=p_add>+</span>
<span class=p_add>+	return 0;</span>
<span class=p_add>+}</span>
<span class=p_add>+</span>
<span class=p_add>+static void vfio_device_exit(struct kvm *kvm, struct vfio_device *vdev)</span>
<span class=p_add>+{</span>
<span class=p_add>+	vfio_group_exit(kvm, vdev-&gt;group);</span>
<span class=p_add>+</span>
<span class=p_add>+	switch (vdev-&gt;params-&gt;type) {</span>
<span class=p_add>+	case VFIO_DEVICE_PCI:</span>
<span class=p_add>+		vfio_pci_teardown_device(kvm, vdev);</span>
<span class=p_add>+		break;</span>
<span class=p_add>+	default:</span>
<span class=p_add>+		dev_warn(vdev, "no teardown function for device");</span>
<span class=p_add>+	}</span>
<span class=p_add>+</span>
<span class=p_add>+	close(vdev-&gt;fd);</span>
<span class=p_add>+</span>
<span class=p_add>+	free(vdev-&gt;regions);</span>
<span class=p_add>+	free(vdev-&gt;sysfs_path);</span>
<span class=p_add>+}</span>
<span class=p_add>+</span>
<span class=p_add>+static int vfio_container_init(struct kvm *kvm)</span>
<span class=p_add>+{</span>
<span class=p_add>+	int api, i, ret, iommu_type;;</span>
<span class=p_add>+</span>
<span class=p_add>+	/* Create a container for our IOMMU groups */</span>
<span class=p_add>+	vfio_container = open(VFIO_DEV_NODE, O_RDWR);</span>
<span class=p_add>+	if (vfio_container == -1) {</span>
<span class=p_add>+		ret = errno;</span>
<span class=p_add>+		pr_err("Failed to open %s", VFIO_DEV_NODE);</span>
<span class=p_add>+		return ret;</span>
<span class=p_add>+	}</span>
<span class=p_add>+</span>
<span class=p_add>+	api = ioctl(vfio_container, VFIO_GET_API_VERSION);</span>
<span class=p_add>+	if (api != VFIO_API_VERSION) {</span>
<span class=p_add>+		pr_err("Unknown VFIO API version %d", api);</span>
<span class=p_add>+		return -ENODEV;</span>
<span class=p_add>+	}</span>
<span class=p_add>+</span>
<span class=p_add>+	iommu_type = vfio_get_iommu_type();</span>
<span class=p_add>+	if (iommu_type &lt; 0) {</span>
<span class=p_add>+		pr_err("VFIO type-1 IOMMU not supported on this platform");</span>
<span class=p_add>+		return iommu_type;</span>
<span class=p_add>+	}</span>
<span class=p_add>+</span>
<span class=p_add>+	/* Create groups for our devices and add them to the container */</span>
<span class=p_add>+	for (i = 0; i &lt; kvm-&gt;cfg.num_vfio_devices; ++i) {</span>
<span class=p_add>+		vfio_devices[i].params = &amp;kvm-&gt;cfg.vfio_devices[i];</span>
<span class=p_add>+</span>
<span class=p_add>+		ret = vfio_device_init(kvm, &amp;vfio_devices[i]);</span>
<span class=p_add>+		if (ret)</span>
<span class=p_add>+			return ret;</span>
<span class=p_add>+	}</span>
<span class=p_add>+</span>
<span class=p_add>+	/* Finalise the container */</span>
<span class=p_add>+	if (ioctl(vfio_container, VFIO_SET_IOMMU, iommu_type)) {</span>
<span class=p_add>+		ret = -errno;</span>
<span class=p_add>+		pr_err("Failed to set IOMMU type %d for VFIO container",</span>
<span class=p_add>+		       iommu_type);</span>
<span class=p_add>+		return ret;</span>
<span class=p_add>+	} else {</span>
<span class=p_add>+		pr_info("Using IOMMU type %d for VFIO container", iommu_type);</span>
<span class=p_add>+	}</span>
<span class=p_add>+</span>
<span class=p_add>+	return kvm__for_each_mem_bank(kvm, KVM_MEM_TYPE_RAM, vfio_map_mem_bank,</span>
<span class=p_add>+				      NULL);</span>
<span class=p_add>+}</span>
<span class=p_add>+</span>
<span class=p_add>+static int vfio__init(struct kvm *kvm)</span>
<span class=p_add>+{</span>
<span class=p_add>+	int ret;</span>
<span class=p_add>+</span>
<span class=p_add>+	if (!kvm-&gt;cfg.num_vfio_devices)</span>
<span class=p_add>+		return 0;</span>
<span class=p_add>+</span>
<span class=p_add>+	vfio_devices = calloc(kvm-&gt;cfg.num_vfio_devices, sizeof(*vfio_devices));</span>
<span class=p_add>+	if (!vfio_devices)</span>
<span class=p_add>+		return -ENOMEM;</span>
<span class=p_add>+</span>
<span class=p_add>+	ret = vfio_container_init(kvm);</span>
<span class=p_add>+	if (ret)</span>
<span class=p_add>+		return ret;</span>
<span class=p_add>+</span>
<span class=p_add>+	ret = vfio_configure_devices(kvm);</span>
<span class=p_add>+	if (ret)</span>
<span class=p_add>+		return ret;</span>
<span class=p_add>+</span>
<span class=p_add>+	return 0;</span>
<span class=p_add>+}</span>
<span class=p_add>+dev_base_init(vfio__init);</span>
<span class=p_add>+</span>
<span class=p_add>+static int vfio__exit(struct kvm *kvm)</span>
<span class=p_add>+{</span>
<span class=p_add>+	int i;</span>
<span class=p_add>+</span>
<span class=p_add>+	if (!kvm-&gt;cfg.num_vfio_devices)</span>
<span class=p_add>+		return 0;</span>
<span class=p_add>+</span>
<span class=p_add>+	for (i = 0; i &lt; kvm-&gt;cfg.num_vfio_devices; i++)</span>
<span class=p_add>+		vfio_device_exit(kvm, &amp;vfio_devices[i]);</span>
<span class=p_add>+</span>
<span class=p_add>+	free(vfio_devices);</span>
<span class=p_add>+</span>
<span class=p_add>+	kvm__for_each_mem_bank(kvm, KVM_MEM_TYPE_RAM, vfio_unmap_mem_bank, NULL);</span>
<span class=p_add>+	return close(vfio_container);</span>
<span class=p_add>+}</span>
<span class=p_add>+dev_base_exit(vfio__exit);</span>
<span class=p_header>diff --git a/vfio/pci.c b/vfio/pci.c</span>
new file mode 100644
<span class=p_header>index 000000000000..adf6f03a9f0a</span>
<span class=p_header>--- /dev/null</span>
<span class=p_header>+++ b/vfio/pci.c</span>
<span class=p_chunk>@@ -0,0 +1,395 @@</span> <span class=p_context></span>
<span class=p_add>+#include "kvm/irq.h"</span>
<span class=p_add>+#include "kvm/kvm.h"</span>
<span class=p_add>+#include "kvm/kvm-cpu.h"</span>
<span class=p_add>+#include "kvm/vfio.h"</span>
<span class=p_add>+</span>
<span class=p_add>+#include &lt;sys/ioctl.h&gt;</span>
<span class=p_add>+#include &lt;sys/eventfd.h&gt;</span>
<span class=p_add>+</span>
<span class=p_add>+/* Wrapper around UAPI vfio_irq_set */</span>
<span class=p_add>+struct vfio_irq_eventfd {</span>
<span class=p_add>+	struct vfio_irq_set	irq;</span>
<span class=p_add>+	int			fd;</span>
<span class=p_add>+};</span>
<span class=p_add>+</span>
<span class=p_add>+static void vfio_pci_cfg_read(struct kvm *kvm, struct pci_device_header *pci_hdr,</span>
<span class=p_add>+			      u8 offset, void *data, int sz)</span>
<span class=p_add>+{</span>
<span class=p_add>+	struct vfio_region_info *info;</span>
<span class=p_add>+	struct vfio_pci_device *pdev;</span>
<span class=p_add>+	struct vfio_device *vdev;</span>
<span class=p_add>+	char base[sz];</span>
<span class=p_add>+</span>
<span class=p_add>+	pdev = container_of(pci_hdr, struct vfio_pci_device, hdr);</span>
<span class=p_add>+	vdev = container_of(pdev, struct vfio_device, pci);</span>
<span class=p_add>+	info = &amp;vdev-&gt;regions[VFIO_PCI_CONFIG_REGION_INDEX].info;</span>
<span class=p_add>+</span>
<span class=p_add>+	/* Dummy read in case of side-effects */</span>
<span class=p_add>+	if (pread(vdev-&gt;fd, base, sz, info-&gt;offset + offset) != sz)</span>
<span class=p_add>+		dev_warn(vdev, "failed to read %d bytes from Configuration Space at 0x%x",</span>
<span class=p_add>+			 sz, offset);</span>
<span class=p_add>+}</span>
<span class=p_add>+</span>
<span class=p_add>+static void vfio_pci_cfg_write(struct kvm *kvm, struct pci_device_header *pci_hdr,</span>
<span class=p_add>+			       u8 offset, void *data, int sz)</span>
<span class=p_add>+{</span>
<span class=p_add>+	struct vfio_region_info *info;</span>
<span class=p_add>+	struct vfio_pci_device *pdev;</span>
<span class=p_add>+	struct vfio_device *vdev;</span>
<span class=p_add>+	void *base = pci_hdr;</span>
<span class=p_add>+</span>
<span class=p_add>+	pdev = container_of(pci_hdr, struct vfio_pci_device, hdr);</span>
<span class=p_add>+	vdev = container_of(pdev, struct vfio_device, pci);</span>
<span class=p_add>+	info = &amp;vdev-&gt;regions[VFIO_PCI_CONFIG_REGION_INDEX].info;</span>
<span class=p_add>+</span>
<span class=p_add>+	if (pwrite(vdev-&gt;fd, data, sz, info-&gt;offset + offset) != sz)</span>
<span class=p_add>+		dev_warn(vdev, "Failed to write %d bytes to Configuration Space at 0x%x",</span>
<span class=p_add>+			 sz, offset);</span>
<span class=p_add>+</span>
<span class=p_add>+	if (pread(vdev-&gt;fd, base + offset, sz, info-&gt;offset + offset) != sz)</span>
<span class=p_add>+		dev_warn(vdev, "Failed to read %d bytes from Configuration Space at 0x%x",</span>
<span class=p_add>+			 sz, offset);</span>
<span class=p_add>+}</span>
<span class=p_add>+</span>
<span class=p_add>+static int vfio_pci_parse_caps(struct vfio_device *vdev)</span>
<span class=p_add>+{</span>
<span class=p_add>+	struct vfio_pci_device *pdev = &amp;vdev-&gt;pci;</span>
<span class=p_add>+</span>
<span class=p_add>+	if (!(pdev-&gt;hdr.status &amp; PCI_STATUS_CAP_LIST))</span>
<span class=p_add>+		return 0;</span>
<span class=p_add>+</span>
<span class=p_add>+	pdev-&gt;hdr.status &amp;= ~PCI_STATUS_CAP_LIST;</span>
<span class=p_add>+	pdev-&gt;hdr.capabilities = 0;</span>
<span class=p_add>+</span>
<span class=p_add>+	/* TODO: install virtual capabilities */</span>
<span class=p_add>+</span>
<span class=p_add>+	return 0;</span>
<span class=p_add>+}</span>
<span class=p_add>+</span>
<span class=p_add>+static int vfio_pci_parse_cfg_space(struct vfio_device *vdev)</span>
<span class=p_add>+{</span>
<span class=p_add>+	ssize_t sz = PCI_STD_HEADER_SIZEOF;</span>
<span class=p_add>+	struct vfio_region_info *info;</span>
<span class=p_add>+	struct vfio_pci_device *pdev = &amp;vdev-&gt;pci;</span>
<span class=p_add>+</span>
<span class=p_add>+	if (vdev-&gt;info.num_regions &lt; VFIO_PCI_CONFIG_REGION_INDEX) {</span>
<span class=p_add>+		dev_err(vdev, "Config Space not found");</span>
<span class=p_add>+		return -ENODEV;</span>
<span class=p_add>+	}</span>
<span class=p_add>+</span>
<span class=p_add>+	info = &amp;vdev-&gt;regions[VFIO_PCI_CONFIG_REGION_INDEX].info;</span>
<span class=p_add>+	*info = (struct vfio_region_info) {</span>
<span class=p_add>+			.argsz = sizeof(*info),</span>
<span class=p_add>+			.index = VFIO_PCI_CONFIG_REGION_INDEX,</span>
<span class=p_add>+	};</span>
<span class=p_add>+</span>
<span class=p_add>+	ioctl(vdev-&gt;fd, VFIO_DEVICE_GET_REGION_INFO, info);</span>
<span class=p_add>+	if (!info-&gt;size) {</span>
<span class=p_add>+		dev_err(vdev, "Config Space has size zero?!");</span>
<span class=p_add>+		return -EINVAL;</span>
<span class=p_add>+	}</span>
<span class=p_add>+</span>
<span class=p_add>+	if (pread(vdev-&gt;fd, &amp;pdev-&gt;hdr, sz, info-&gt;offset) != sz) {</span>
<span class=p_add>+		dev_err(vdev, "failed to read %zd bytes of Config Space", sz);</span>
<span class=p_add>+		return -EIO;</span>
<span class=p_add>+	}</span>
<span class=p_add>+</span>
<span class=p_add>+	/* Strip bit 7, that indicates multifunction */</span>
<span class=p_add>+	pdev-&gt;hdr.header_type &amp;= 0x7f;</span>
<span class=p_add>+</span>
<span class=p_add>+	if (pdev-&gt;hdr.header_type != PCI_HEADER_TYPE_NORMAL) {</span>
<span class=p_add>+		dev_err(vdev, "unsupported header type %u",</span>
<span class=p_add>+			pdev-&gt;hdr.header_type);</span>
<span class=p_add>+		return -EOPNOTSUPP;</span>
<span class=p_add>+	}</span>
<span class=p_add>+</span>
<span class=p_add>+	vfio_pci_parse_caps(vdev);</span>
<span class=p_add>+</span>
<span class=p_add>+	return 0;</span>
<span class=p_add>+}</span>
<span class=p_add>+</span>
<span class=p_add>+static int vfio_pci_fixup_cfg_space(struct vfio_device *vdev)</span>
<span class=p_add>+{</span>
<span class=p_add>+	int i;</span>
<span class=p_add>+	ssize_t hdr_sz;</span>
<span class=p_add>+	struct vfio_region_info *info;</span>
<span class=p_add>+	struct vfio_pci_device *pdev = &amp;vdev-&gt;pci;</span>
<span class=p_add>+</span>
<span class=p_add>+	/* Enable exclusively MMIO and bus mastering */</span>
<span class=p_add>+	pdev-&gt;hdr.command &amp;= ~PCI_COMMAND_IO;</span>
<span class=p_add>+	pdev-&gt;hdr.command |= PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER;</span>
<span class=p_add>+</span>
<span class=p_add>+	/* Initialise the BARs */</span>
<span class=p_add>+	for (i = VFIO_PCI_BAR0_REGION_INDEX; i &lt;= VFIO_PCI_BAR5_REGION_INDEX; ++i) {</span>
<span class=p_add>+		struct vfio_region *region = &amp;vdev-&gt;regions[i];</span>
<span class=p_add>+		u64 base = region-&gt;guest_phys_addr;</span>
<span class=p_add>+</span>
<span class=p_add>+		if (!base)</span>
<span class=p_add>+			continue;</span>
<span class=p_add>+</span>
<span class=p_add>+		pdev-&gt;hdr.bar_size[i] = region-&gt;info.size;</span>
<span class=p_add>+</span>
<span class=p_add>+		/* Construct a fake reg to match what we've mapped. */</span>
<span class=p_add>+		pdev-&gt;hdr.bar[i] = (base &amp; PCI_BASE_ADDRESS_MEM_MASK) |</span>
<span class=p_add>+					PCI_BASE_ADDRESS_SPACE_MEMORY |</span>
<span class=p_add>+					PCI_BASE_ADDRESS_MEM_TYPE_32;</span>
<span class=p_add>+	}</span>
<span class=p_add>+</span>
<span class=p_add>+	/* I really can't be bothered to support cardbus. */</span>
<span class=p_add>+	pdev-&gt;hdr.card_bus = 0;</span>
<span class=p_add>+</span>
<span class=p_add>+	/*</span>
<span class=p_add>+	 * Nuke the expansion ROM for now. If we want to do this properly,</span>
<span class=p_add>+	 * we need to save its size somewhere and map into the guest.</span>
<span class=p_add>+	 */</span>
<span class=p_add>+	pdev-&gt;hdr.exp_rom_bar = 0;</span>
<span class=p_add>+</span>
<span class=p_add>+	/* Install our fake Configuration Space */</span>
<span class=p_add>+	info = &amp;vdev-&gt;regions[VFIO_PCI_CONFIG_REGION_INDEX].info;</span>
<span class=p_add>+	hdr_sz = PCI_DEV_CFG_SIZE;</span>
<span class=p_add>+	if (pwrite(vdev-&gt;fd, &amp;pdev-&gt;hdr, hdr_sz, info-&gt;offset) != hdr_sz) {</span>
<span class=p_add>+		dev_err(vdev, "failed to write %zd bytes to Config Space",</span>
<span class=p_add>+			hdr_sz);</span>
<span class=p_add>+		return -EIO;</span>
<span class=p_add>+	}</span>
<span class=p_add>+</span>
<span class=p_add>+	/* Register callbacks for cfg accesses */</span>
<span class=p_add>+	pdev-&gt;hdr.cfg_ops = (struct pci_config_operations) {</span>
<span class=p_add>+		.read	= vfio_pci_cfg_read,</span>
<span class=p_add>+		.write	= vfio_pci_cfg_write,</span>
<span class=p_add>+	};</span>
<span class=p_add>+</span>
<span class=p_add>+	pdev-&gt;hdr.irq_type = IRQ_TYPE_LEVEL_HIGH;</span>
<span class=p_add>+</span>
<span class=p_add>+	return 0;</span>
<span class=p_add>+}</span>
<span class=p_add>+</span>
<span class=p_add>+static int vfio_pci_configure_bar(struct kvm *kvm, struct vfio_device *vdev,</span>
<span class=p_add>+				  size_t nr)</span>
<span class=p_add>+{</span>
<span class=p_add>+	int ret;</span>
<span class=p_add>+	size_t map_size;</span>
<span class=p_add>+	struct vfio_region *region = &amp;vdev-&gt;regions[nr];</span>
<span class=p_add>+</span>
<span class=p_add>+	if (nr &gt;= vdev-&gt;info.num_regions)</span>
<span class=p_add>+		return 0;</span>
<span class=p_add>+</span>
<span class=p_add>+	region-&gt;info = (struct vfio_region_info) {</span>
<span class=p_add>+		.argsz = sizeof(*region),</span>
<span class=p_add>+		.index = nr,</span>
<span class=p_add>+	};</span>
<span class=p_add>+</span>
<span class=p_add>+	ret = ioctl(vdev-&gt;fd, VFIO_DEVICE_GET_REGION_INFO, &amp;region-&gt;info);</span>
<span class=p_add>+	if (ret) {</span>
<span class=p_add>+		ret = -errno;</span>
<span class=p_add>+		dev_err(vdev, "cannot get info for BAR %zu", nr);</span>
<span class=p_add>+		return ret;</span>
<span class=p_add>+	}</span>
<span class=p_add>+</span>
<span class=p_add>+	/* Ignore invalid or unimplemented regions */</span>
<span class=p_add>+	if (!region-&gt;info.size)</span>
<span class=p_add>+		return 0;</span>
<span class=p_add>+</span>
<span class=p_add>+	/* Grab some MMIO space in the guest */</span>
<span class=p_add>+	map_size = ALIGN(region-&gt;info.size, PAGE_SIZE);</span>
<span class=p_add>+	region-&gt;guest_phys_addr = pci_get_io_space_block(map_size);</span>
<span class=p_add>+</span>
<span class=p_add>+	/*</span>
<span class=p_add>+	 * Map the BARs into the guest. We'll later need to update</span>
<span class=p_add>+	 * configuration space to reflect our allocation.</span>
<span class=p_add>+	 */</span>
<span class=p_add>+	ret = vfio_map_region(kvm, vdev, region);</span>
<span class=p_add>+	if (ret)</span>
<span class=p_add>+		return ret;</span>
<span class=p_add>+</span>
<span class=p_add>+	return 0;</span>
<span class=p_add>+}</span>
<span class=p_add>+</span>
<span class=p_add>+static int vfio_pci_configure_dev_regions(struct kvm *kvm,</span>
<span class=p_add>+					  struct vfio_device *vdev)</span>
<span class=p_add>+{</span>
<span class=p_add>+	int ret;</span>
<span class=p_add>+	u32 bar;</span>
<span class=p_add>+	size_t i;</span>
<span class=p_add>+	bool is_64bit = false;</span>
<span class=p_add>+	struct vfio_pci_device *pdev = &amp;vdev-&gt;pci;</span>
<span class=p_add>+</span>
<span class=p_add>+	ret = vfio_pci_parse_cfg_space(vdev);</span>
<span class=p_add>+	if (ret)</span>
<span class=p_add>+		return ret;</span>
<span class=p_add>+</span>
<span class=p_add>+	for (i = VFIO_PCI_BAR0_REGION_INDEX; i &lt;= VFIO_PCI_BAR5_REGION_INDEX; ++i) {</span>
<span class=p_add>+		/* Ignore top half of 64-bit BAR */</span>
<span class=p_add>+		if (i % 2 &amp;&amp; is_64bit)</span>
<span class=p_add>+			continue;</span>
<span class=p_add>+</span>
<span class=p_add>+		ret = vfio_pci_configure_bar(kvm, vdev, i);</span>
<span class=p_add>+		if (ret)</span>
<span class=p_add>+			return ret;</span>
<span class=p_add>+</span>
<span class=p_add>+		bar = pdev-&gt;hdr.bar[i];</span>
<span class=p_add>+		is_64bit = (bar &amp; PCI_BASE_ADDRESS_SPACE) ==</span>
<span class=p_add>+			   PCI_BASE_ADDRESS_SPACE_MEMORY &amp;&amp;</span>
<span class=p_add>+			   bar &amp; PCI_BASE_ADDRESS_MEM_TYPE_64;</span>
<span class=p_add>+	}</span>
<span class=p_add>+</span>
<span class=p_add>+	/* We've configured the BARs, fake up a Configuration Space */</span>
<span class=p_add>+	return vfio_pci_fixup_cfg_space(vdev);</span>
<span class=p_add>+}</span>
<span class=p_add>+</span>
<span class=p_add>+static int vfio_pci_enable_intx(struct kvm *kvm, struct vfio_device *vdev)</span>
<span class=p_add>+{</span>
<span class=p_add>+	int ret;</span>
<span class=p_add>+	int trigger_fd, unmask_fd;</span>
<span class=p_add>+	struct vfio_irq_eventfd	trigger;</span>
<span class=p_add>+	struct vfio_irq_eventfd	unmask;</span>
<span class=p_add>+	struct vfio_pci_device *pdev = &amp;vdev-&gt;pci;</span>
<span class=p_add>+	int gsi = pdev-&gt;hdr.irq_line - KVM_IRQ_OFFSET;</span>
<span class=p_add>+</span>
<span class=p_add>+	struct vfio_irq_info irq_info = {</span>
<span class=p_add>+		.argsz = sizeof(irq_info),</span>
<span class=p_add>+		.index = VFIO_PCI_INTX_IRQ_INDEX,</span>
<span class=p_add>+	};</span>
<span class=p_add>+</span>
<span class=p_add>+	ret = ioctl(vdev-&gt;fd, VFIO_DEVICE_GET_IRQ_INFO, &amp;irq_info);</span>
<span class=p_add>+	if (ret || irq_info.count == 0) {</span>
<span class=p_add>+		dev_err(vdev, "no INTx reported by VFIO");</span>
<span class=p_add>+		return -ENODEV;</span>
<span class=p_add>+	}</span>
<span class=p_add>+</span>
<span class=p_add>+	if (!(irq_info.flags &amp; VFIO_IRQ_INFO_EVENTFD)) {</span>
<span class=p_add>+		dev_err(vdev, "interrupt not eventfd capable");</span>
<span class=p_add>+		return -EINVAL;</span>
<span class=p_add>+	}</span>
<span class=p_add>+</span>
<span class=p_add>+	if (!(irq_info.flags &amp; VFIO_IRQ_INFO_AUTOMASKED)) {</span>
<span class=p_add>+		dev_err(vdev, "INTx interrupt not AUTOMASKED");</span>
<span class=p_add>+		return -EINVAL;</span>
<span class=p_add>+	}</span>
<span class=p_add>+</span>
<span class=p_add>+	/*</span>
<span class=p_add>+	 * PCI IRQ is level-triggered, so we use two eventfds. trigger_fd</span>
<span class=p_add>+	 * signals an interrupt from host to guest, and unmask_fd signals the</span>
<span class=p_add>+	 * deassertion of the line from guest to host.</span>
<span class=p_add>+	 */</span>
<span class=p_add>+	trigger_fd = eventfd(0, 0);</span>
<span class=p_add>+	if (trigger_fd &lt; 0) {</span>
<span class=p_add>+		pr_err("Failed to create trigger eventfd");</span>
<span class=p_add>+		return trigger_fd;</span>
<span class=p_add>+	}</span>
<span class=p_add>+</span>
<span class=p_add>+	unmask_fd = eventfd(0, 0);</span>
<span class=p_add>+	if (unmask_fd &lt; 0) {</span>
<span class=p_add>+		pr_err("Failed to create unmask eventfd");</span>
<span class=p_add>+		close(trigger_fd);</span>
<span class=p_add>+		return unmask_fd;</span>
<span class=p_add>+	}</span>
<span class=p_add>+</span>
<span class=p_add>+	ret = irq__add_irqfd(kvm, gsi, trigger_fd, unmask_fd);</span>
<span class=p_add>+	if (ret)</span>
<span class=p_add>+		goto err_close;</span>
<span class=p_add>+</span>
<span class=p_add>+	trigger.irq = (struct vfio_irq_set) {</span>
<span class=p_add>+		.argsz	= sizeof(trigger),</span>
<span class=p_add>+		.flags	= VFIO_IRQ_SET_DATA_EVENTFD | VFIO_IRQ_SET_ACTION_TRIGGER,</span>
<span class=p_add>+		.index	= VFIO_PCI_INTX_IRQ_INDEX,</span>
<span class=p_add>+		.start	= 0,</span>
<span class=p_add>+		.count	= 1,</span>
<span class=p_add>+	};</span>
<span class=p_add>+	trigger.fd = trigger_fd;</span>
<span class=p_add>+</span>
<span class=p_add>+	ret = ioctl(vdev-&gt;fd, VFIO_DEVICE_SET_IRQS, &amp;trigger);</span>
<span class=p_add>+	if (ret &lt; 0) {</span>
<span class=p_add>+		pr_err("Failed to setup VFIO IRQ");</span>
<span class=p_add>+		goto err_delete_line;</span>
<span class=p_add>+	}</span>
<span class=p_add>+</span>
<span class=p_add>+	unmask.irq = (struct vfio_irq_set) {</span>
<span class=p_add>+		.argsz	= sizeof(unmask),</span>
<span class=p_add>+		.flags	= VFIO_IRQ_SET_DATA_EVENTFD | VFIO_IRQ_SET_ACTION_UNMASK,</span>
<span class=p_add>+		.index	= VFIO_PCI_INTX_IRQ_INDEX,</span>
<span class=p_add>+		.start	= 0,</span>
<span class=p_add>+		.count	= 1,</span>
<span class=p_add>+	};</span>
<span class=p_add>+	unmask.fd = unmask_fd;</span>
<span class=p_add>+</span>
<span class=p_add>+	ret = ioctl(vdev-&gt;fd, VFIO_DEVICE_SET_IRQS, &amp;unmask);</span>
<span class=p_add>+	if (ret &lt; 0) {</span>
<span class=p_add>+		pr_err("Failed to setup unmask IRQ");</span>
<span class=p_add>+		goto err_remove_event;</span>
<span class=p_add>+	}</span>
<span class=p_add>+</span>
<span class=p_add>+	return 0;</span>
<span class=p_add>+</span>
<span class=p_add>+err_remove_event:</span>
<span class=p_add>+	/* Remove trigger event */</span>
<span class=p_add>+	trigger.irq.flags = VFIO_IRQ_SET_DATA_NONE | VFIO_IRQ_SET_ACTION_TRIGGER;</span>
<span class=p_add>+	trigger.irq.count = 0;</span>
<span class=p_add>+	ioctl(vdev-&gt;fd, VFIO_DEVICE_SET_IRQS, &amp;trigger);</span>
<span class=p_add>+</span>
<span class=p_add>+err_delete_line:</span>
<span class=p_add>+	irq__del_irqfd(kvm, gsi, trigger_fd);</span>
<span class=p_add>+</span>
<span class=p_add>+err_close:</span>
<span class=p_add>+	close(trigger_fd);</span>
<span class=p_add>+	close(unmask_fd);</span>
<span class=p_add>+	return ret;</span>
<span class=p_add>+}</span>
<span class=p_add>+</span>
<span class=p_add>+static int vfio_pci_configure_dev_irqs(struct kvm *kvm, struct vfio_device *vdev)</span>
<span class=p_add>+{</span>
<span class=p_add>+	struct vfio_pci_device *pdev = &amp;vdev-&gt;pci;</span>
<span class=p_add>+</span>
<span class=p_add>+	struct vfio_irq_info irq_info = {</span>
<span class=p_add>+		.argsz = sizeof(irq_info),</span>
<span class=p_add>+		.index = VFIO_PCI_INTX_IRQ_INDEX,</span>
<span class=p_add>+	};</span>
<span class=p_add>+</span>
<span class=p_add>+	if (!pdev-&gt;hdr.irq_pin) {</span>
<span class=p_add>+		/* TODO: add MSI support */</span>
<span class=p_add>+		dev_err(vdev, "INTx not available, MSI-X not implemented");</span>
<span class=p_add>+		return -ENOSYS;</span>
<span class=p_add>+	}</span>
<span class=p_add>+</span>
<span class=p_add>+	return vfio_pci_enable_intx(kvm, vdev);</span>
<span class=p_add>+}</span>
<span class=p_add>+</span>
<span class=p_add>+int vfio_pci_setup_device(struct kvm *kvm, struct vfio_device *vdev)</span>
<span class=p_add>+{</span>
<span class=p_add>+	int ret;</span>
<span class=p_add>+</span>
<span class=p_add>+	ret = vfio_pci_configure_dev_regions(kvm, vdev);</span>
<span class=p_add>+	if (ret) {</span>
<span class=p_add>+		dev_err(vdev, "failed to configure regions");</span>
<span class=p_add>+		return ret;</span>
<span class=p_add>+	}</span>
<span class=p_add>+</span>
<span class=p_add>+	vdev-&gt;dev_hdr = (struct device_header) {</span>
<span class=p_add>+		.bus_type	= DEVICE_BUS_PCI,</span>
<span class=p_add>+		.data		= &amp;vdev-&gt;pci.hdr,</span>
<span class=p_add>+	};</span>
<span class=p_add>+</span>
<span class=p_add>+	ret = device__register(&amp;vdev-&gt;dev_hdr);</span>
<span class=p_add>+	if (ret) {</span>
<span class=p_add>+		dev_err(vdev, "failed to register VFIO device");</span>
<span class=p_add>+		return ret;</span>
<span class=p_add>+	}</span>
<span class=p_add>+</span>
<span class=p_add>+	ret = vfio_pci_configure_dev_irqs(kvm, vdev);</span>
<span class=p_add>+	if (ret) {</span>
<span class=p_add>+		dev_err(vdev, "failed to configure IRQs");</span>
<span class=p_add>+		return ret;</span>
<span class=p_add>+	}</span>
<span class=p_add>+</span>
<span class=p_add>+	return 0;</span>
<span class=p_add>+}</span>
<span class=p_add>+</span>
<span class=p_add>+void vfio_pci_teardown_device(struct kvm *kvm, struct vfio_device *vdev)</span>
<span class=p_add>+{</span>
<span class=p_add>+	size_t i;</span>
<span class=p_add>+</span>
<span class=p_add>+	for (i = 0; i &lt; vdev-&gt;info.num_regions; i++)</span>
<span class=p_add>+		vfio_unmap_region(kvm, &amp;vdev-&gt;regions[i]);</span>
<span class=p_add>+</span>
<span class=p_add>+	device__unregister(&amp;vdev-&gt;dev_hdr);</span>
<span class=p_add>+}</span>

</pre>
</div>
 </div>
 <div id=footer>
 <a href=http://jk.ozlabs.org/projects/patchwork/>patchwork</a>
 patch tracking system | version v2.2.6 | <a href=https://patchwork.kernel.org/about/>about patchwork</a>
 </div>
 
<div style=all:initial><div style=all:initial id=__hcfy__><template shadowrootmode=open><style class=sf-hidden>#root{-webkit-text-size-adjust:100%;box-sizing:border-box;font-size:14px;font-weight:400;letter-spacing:0;line-height:1.28581;text-transform:none;color:#182026;font-family:-apple-system,"BlinkMacSystemFont","Segoe UI","Roboto","Oxygen","Ubuntu","Cantarell","Open Sans","Helvetica Neue","Icons16",sans-serif;touch-action:manipulation}#root>.bp5-portal{z-index:9999999999}</style><style class=sf-hidden>#translate-panel{background-color:#f6f7f9;display:flex;flex-direction:column;padding-bottom:8px}.bp5-dark #translate-panel{background-color:#252a31}#translate-panel .fixed{flex-shrink:0;margin-bottom:10px}#translate-panel .body{flex-grow:1;overflow:auto;overscroll-behavior:contain}#translate-panel .body::-webkit-scrollbar{width:8px;background-color:rgba(0,0,0,0);-webkit-border-radius:100px}#translate-panel .body::-webkit-scrollbar:hover{background-color:rgba(0,0,0,.09)}#translate-panel .body::-webkit-scrollbar-thumb:vertical{background:rgba(0,0,0,.5);-webkit-border-radius:100px}#translate-panel .body::-webkit-scrollbar-thumb:vertical:active{background:rgba(0,0,0,.61);-webkit-border-radius:100px}#translate-panel.size-small,#translate-panel.size-small h6.bp5-heading,#translate-panel.size-small .bp5-control.bp5-large,#translate-panel.size-small textarea.bp5-input.bp5-small{font-size:14px}#translate-panel.size-small .phonetic-item,#translate-panel.size-small .quick-settings a{font-size:12px}#translate-panel.size-middle,#translate-panel.size-middle h6.bp5-heading,#translate-panel.size-middle .bp5-control.bp5-large,#translate-panel.size-middle textarea.bp5-input{font-size:18px}#translate-panel.size-middle .phonetic-item,#translate-panel.size-middle .quick-settings a{font-size:14px}#translate-panel.size-large,#translate-panel.size-large h6.bp5-heading,#translate-panel.size-large .bp5-control.bp5-large,#translate-panel.size-large textarea.bp5-input.bp5-large{font-size:22px}#translate-panel.size-large .source,#translate-panel.size-large .phonetic-item,#translate-panel.size-large .quick-settings a{font-size:18px}#translate-panel .bp5-button.bp5-small,#translate-panel .bp5-small .bp5-button{min-height:20px;min-width:20px}#translate-panel .header{display:flex;align-items:center;padding:4px 6px 4px 10px;border-bottom:1px solid #d1d1d1}.bp5-dark #translate-panel .header{border-bottom-color:rgba(17,20,24,.4)}#translate-panel .header .drag-block{min-width:5px;flex-shrink:0;flex-grow:1;align-self:stretch}#translate-panel .header .left{flex-shrink:0;display:flex}#translate-panel .header .right{flex-shrink:0;display:flex;align-items:center}#translate-panel .header .right .bp5-icon-arrow-right{flex-shrink:0;margin:0 5px}#translate-panel .header .right>.bp5-button{flex-shrink:0;margin:0 1px}#translate-panel .header .right>.bp5-button:last-child{margin-right:0}#translate-panel .quick-settings{padding:4px 9px;margin:0 1px}#translate-panel .quick-settings>div{margin-bottom:5px}#translate-panel .quick-settings .bp5-control{margin-bottom:0}#translate-panel .query-text{position:relative;padding:10px 10px 2px 10px}#translate-panel .query-text textarea.bp5-input{min-height:44px;font-family:system-ui,-apple-system,"Segoe UI","Roboto","Ubuntu","Cantarell","Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";overscroll-behavior:contain}#translate-panel .query-text .translate-btn{position:absolute;opacity:.6}#translate-panel .query-text .translate-btn:hover{opacity:1}#translate-panel .body{padding:0 10px}#translate-panel .body .bp5-card:first-child{margin-top:1px}#translate-panel .body .bp5-card:last-child{margin-bottom:1px}#translate-panel .body .no-api{margin:20px 0}.result-block{margin:8px 0;padding:2px 5px}.result-block .bp5-button{visibility:hidden}.result-block .error .bp5-button,.result-block:hover .bp5-button{visibility:visible}.result-block .legend{display:flex;align-items:center;justify-content:space-between}.result-block .legend .legend-left{display:flex;align-items:center}.result-block .legend .api-ico,.result-block .legend .bp5-heading{flex-shrink:0;white-space:nowrap}.result-block .legend .api-ico{display:inline-block;width:14px;height:14px;background-size:contain;margin-right:3px}.result-block .legend .bp5-heading{margin-bottom:0;margin-right:10px}.result-block .legend .source{cursor:pointer;font-size:12px;display:inline-flex;align-items:center}.result-block .legend .source .source-text{overflow:hidden}.result-block .legend .source .bp5-icon{position:relative;top:-1px;margin-left:1px}.result-block .phonetic{display:flex;flex-wrap:wrap}.result-block .phonetic .phonetic-item{display:flex;align-items:center;font-size:12px}.result-block .phonetic .phonetic-item:not(:last-child){margin-right:12px}.result-block .common-result p{line-height:1.3;margin:2px 0;overflow-wrap:break-word}.result-block .common-result .dict a{text-decoration:underline}.result-block .error{font-size:12px;padding:5px 10px}.result-block .dict-pos{margin-right:5px}.external-translators{margin-bottom:3px;padding:0;display:flex;flex-wrap:wrap}.external-translators>div{margin:0 5px 5px 0}.quick-links a{margin:0 5px 5px 0}#popper-container{width:250px;max-width:100%;position:absolute;left:0;top:0;z-index:9999999998;touch-action:none;transition:opacity .2s;background-color:#f6f7f9}.bp5-dark #popper-container{background-color:#252a31}#popper-container.show{opacity:1;pointer-events:auto;-moz-user-select:auto;user-select:auto}#popper-container,#popper-container[data-popper-reference-hidden=true]{opacity:0;pointer-events:none;-moz-user-select:none;user-select:none}#popper-container .drag-block{cursor:-webkit-grab;cursor:grab}#popper-container.pin{position:fixed}#popper-container.pin .arrow{display:none}#popper-container .arrow,#popper-container .arrow::before{position:absolute;width:8px;height:8px;z-index:-1}#popper-container .arrow::before{content:"";transform:rotate(45deg);background:#f6f7f9}.bp5-dark #popper-container .arrow::before{background-color:#252a31}#popper-container .arrow{display:none}#popper-container.show[data-popper-placement]:not([data-popper-reference-hidden=true]) .arrow{display:block}#popper-container[data-popper-placement^=top] .arrow{bottom:-5px}#popper-container[data-popper-placement^=top] .arrow::before{border-right:1px solid #d1d1d1;border-bottom:1px solid #d1d1d1}#popper-container[data-popper-placement^=bottom] .arrow{top:-5px}#popper-container[data-popper-placement^=bottom] .arrow::before{border-left:1px solid #d1d1d1;border-top:1px solid #d1d1d1}#popper-container[data-popper-placement^=left] .arrow{right:-5px}#popper-container[data-popper-placement^=left] .arrow::before{border-right:1px solid #d1d1d1;border-top:1px solid #d1d1d1}#popper-container[data-popper-placement^=right] .arrow{left:-5px}#popper-container[data-popper-placement^=right] .arrow::before{border-left:1px solid #d1d1d1;border-bottom:1px solid #d1d1d1}#translate-btn{display:none;position:absolute;z-index:9999999999;left:0;top:0}#translate-btn .bp5-button{padding:2px;min-width:0;min-height:0}#translate-btn .btn-icon{width:18px;height:18px;background-image:url(moz-extension://19651fe5-a2eb-4315-b2c9-0ae3c022c917/logo.png);background-size:contain}.bp5-dark #translate-btn .btn-icon{background-image:url(moz-extension://19651fe5-a2eb-4315-b2c9-0ae3c022c917/logowhite36.png)}#translate-btn.show{display:block}.translate-type-selector .bp5-label{display:inline}.translate-type-selector .bp5-radio{margin-bottom:0}#ocr-container{position:fixed;z-index:99999999999999;left:0;top:0;right:0;bottom:0}#ocr-container .toolbar{display:none;position:absolute;z-index:1}#ocr-container img{max-width:100%}#app{cursor:default}.switch-pin{flex-shrink:0;cursor:pointer}.switch-pin .bp5-icon-pin{transition:transform .2s,color .2s;transform:rotate(-45deg)}.pin .switch-pin .bp5-icon-pin{transform:rotate(-70deg)}.cut-btn{margin-left:2px}.app-toaster-container{position:fixed!important;z-index:9999999999!important}.app-toaster-container .bp5-toast{min-width:auto}#web-trs-panel .app-toaster-container{padding-right:0;padding-left:0}#web-trs-panel .page-trs-form-group{margin:0 0 0 0;align-items:center}#web-trs-panel .page-trs-form-group>label{width:70px}</style><div id=root dir=ltr><div id=app><div id=translate-btn class=sf-hidden></div><div id=popper-container style=width:290px;transform:translate(0px) class=bp5-elevation-4><div id=translate-panel class=size-small><div class=fixed><div class=header><div class=left><div class=switch-pin><button type=button class="bp5-button bp5-minimal bp5-small"><span aria-hidden=true class="bp5-icon bp5-icon-pin"><svg data-icon=pin height=14 role=img viewBox="0 0 16 16" width=14><path d="M9.41.92c-.51.51-.41 1.5.15 2.56L4.34 7.54C2.8 6.48 1.45 6.05.92 6.58l3.54 3.54-3.54 4.95 4.95-3.54 3.54 3.54c.53-.53.1-1.88-.96-3.42l4.06-5.22c1.06.56 2.04.66 2.55.15L9.41.92z" fill-rule=evenodd></path></svg></span></button></div><button type=button title=图片翻译 class="bp5-button bp5-minimal bp5-small"><span aria-hidden=true class="bp5-icon bp5-icon-media"><svg data-icon=media height=14 role=img viewBox="0 0 16 16" width=14><path d="M11.99 6.99c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm3-5h-14c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h14c.55 0 1-.45 1-1v-10c0-.55-.45-1-1-1zm-1 9l-5-3-1 2-3-4-3 5v-7h12v7z" fill-rule=evenodd></path></svg></span></button><button type=button title=语音翻译 class="bp5-button bp5-minimal bp5-small"><span class=bp5-icon><svg version=1.1 id=Capa_1 width=14 height=14 xmlns=http://www.w3.org/2000/svg xmlns:xlink=http://www.w3.org/1999/xlink x=0px y=0px viewBox="0 0 490.9 490.9" xml:space=preserve><g><g><path d="M245.5,322.9c53,0,96.2-43.2,96.2-96.2V96.2c0-53-43.2-96.2-96.2-96.2s-96.2,43.2-96.2,96.2v130.5 C149.3,279.8,192.5,322.9,245.5,322.9z M173.8,96.2c0-39.5,32.2-71.7,71.7-71.7s71.7,32.2,71.7,71.7v130.5 c0,39.5-32.2,71.7-71.7,71.7s-71.7-32.2-71.7-71.7V96.2z"></path><path d="M94.4,214.5c-6.8,0-12.3,5.5-12.3,12.3c0,85.9,66.7,156.6,151.1,162.8v76.7h-63.9c-6.8,0-12.3,5.5-12.3,12.3 s5.5,12.3,12.3,12.3h152.3c6.8,0,12.3-5.5,12.3-12.3s-5.5-12.3-12.3-12.3h-63.9v-76.7c84.4-6.3,151.1-76.9,151.1-162.8 c0-6.8-5.5-12.3-12.3-12.3s-12.3,5.5-12.3,12.3c0,76.6-62.3,138.9-138.9,138.9s-138.9-62.3-138.9-138.9 C106.6,220,101.2,214.5,94.4,214.5z"></path></g></g></svg></span></button></div><div class=drag-block title=按住不放可以拖动></div><div class=right><button type=button disabled title=添加到收藏夹 class="bp5-button bp5-disabled bp5-minimal bp5-small" tabindex=-1><span aria-hidden=true class="bp5-icon bp5-icon-star-empty"><svg data-icon=star-empty height=14 role=img viewBox="0 0 16 16" width=14><path d="M16 6.11l-5.53-.84L8 0 5.53 5.27 0 6.11l4 4.1L3.06 16 8 13.27 12.94 16 12 10.21l4-4.1zM4.91 13.2l.59-3.62L3 7.02l3.45-.53L8 3.2l1.55 3.29 3.45.53-2.5 2.56.59 3.62L8 11.49 4.91 13.2z" fill-rule=evenodd></path></svg></span></button><button type=button class="bp5-button bp5-minimal bp5-small settings" title=快捷设置><span aria-hidden=true class="bp5-icon bp5-icon-cog"><svg data-icon=cog height=14 role=img viewBox="0 0 16 16" width=14><path d="M15.19 6.39h-1.85c-.11-.37-.27-.71-.45-1.04l1.36-1.36c.31-.31.31-.82 0-1.13l-1.13-1.13a.803.803 0 00-1.13 0l-1.36 1.36c-.33-.17-.67-.33-1.04-.44V.79c0-.44-.36-.8-.8-.8h-1.6c-.44 0-.8.36-.8.8v1.86c-.39.12-.75.28-1.1.47l-1.3-1.3c-.3-.3-.79-.3-1.09 0L1.82 2.91c-.3.3-.3.79 0 1.09l1.3 1.3c-.2.34-.36.7-.48 1.09H.79c-.44 0-.8.36-.8.8v1.6c0 .44.36.8.8.8h1.85c.11.37.27.71.45 1.04l-1.36 1.36c-.31.31-.31.82 0 1.13l1.13 1.13c.31.31.82.31 1.13 0l1.36-1.36c.33.18.67.33 1.04.44v1.86c0 .44.36.8.8.8h1.6c.44 0 .8-.36.8-.8v-1.86c.39-.12.75-.28 1.1-.47l1.3 1.3c.3.3.79.3 1.09 0l1.09-1.09c.3-.3.3-.79 0-1.09l-1.3-1.3c.19-.35.36-.71.48-1.1h1.85c.44 0 .8-.36.8-.8v-1.6a.816.816 0 00-.81-.79zm-7.2 4.6c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3z" fill-rule=evenodd></path></svg></span></button><button type=button title=关闭(Esc) class="bp5-button bp5-minimal bp5-small"><span aria-hidden=true class="bp5-icon bp5-icon-cross"><svg data-icon=cross height=18 role=img viewBox="0 0 16 16" width=18><path d="M9.41 8l3.29-3.29c.19-.18.3-.43.3-.71a1.003 1.003 0 00-1.71-.71L8 6.59l-3.29-3.3a1.003 1.003 0 00-1.42 1.42L6.59 8 3.3 11.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71L8 9.41l3.29 3.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71L9.41 8z" fill-rule=evenodd></path></svg></span></button></div></div><div class=bp5-collapse><div class="bp5-collapse-body sf-hidden" aria-hidden=true></div></div></div><div class=body><p>请输入需要翻译的文本。</p></div></div><div class="arrow sf-hidden"></div></div><div id=web-trs-panel></div></div></div></template></div></div><script data-template-shadow-root>(()=>{document.currentScript.remove();processNode(document);function processNode(node){node.querySelectorAll("template[shadowrootmode]").forEach(element=>{let shadowRoot = element.parentElement.shadowRoot;if (!shadowRoot) {try {shadowRoot=element.parentElement.attachShadow({mode:element.getAttribute("shadowrootmode"),delegatesFocus:element.getAttribute("shadowrootdelegatesfocus")!=null,clonable:element.getAttribute("shadowrootclonable")!=null,serializable:element.getAttribute("shadowrootserializable")!=null});shadowRoot.innerHTML=element.innerHTML;element.remove()} catch (error) {} if (shadowRoot) {processNode(shadowRoot)}}})}})()</script>