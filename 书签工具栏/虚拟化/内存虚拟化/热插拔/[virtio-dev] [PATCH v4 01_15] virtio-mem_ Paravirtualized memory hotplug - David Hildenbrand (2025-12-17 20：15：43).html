<!-- Filename: 书签工具栏/虚拟化/内存虚拟化/热插拔/[virtio-dev] [PATCH v4 01_15] virtio-mem_ Paravirtualized memory hotplug - David Hildenbrand (2025-12-17 20：15：43).html
 Page saved with X-Webpage-Conserve 
 url: https://lore.kernel.org/all/20200507140139.17083-2-david@redhat.com/
 Summary: 
-->
<html><head><title>[virtio-dev] [PATCH v4 01/15] virtio-mem: Paravirtualized memory hotplug - David Hildenbrand</title><link rel="alternate" title="Atom feed" href="../new.atom" type="application/atom+xml"><style>pre{white-space:pre-wrap}*{font-size:100%;font-family:monospace}</style><link type="text/css" rel="stylesheet" media="screen,print" href="../216light.css?6914e0a5"><link type="text/css" rel="stylesheet" href="../216dark.css?6914e0a5" media="screen and (prefers-color-scheme:dark)"><style data-id="immersive-translate-input-injected-css">.immersive-translate-input {
  position: absolute;
  top: 0;
  right: 0;
  left: 0;
  bottom: 0;
  z-index: 2147483647;
  display: flex;
  justify-content: center;
  align-items: center;
}
.immersive-translate-attach-loading::after {
  content: " ";

  --loading-color: #f78fb6;
  width: 6px;
  height: 6px;
  border-radius: 50%;
  display: block;
  margin: 12px auto;
  position: relative;
  color: white;
  left: -100px;
  box-sizing: border-box;
  animation: immersiveTranslateShadowRolling 1.5s linear infinite;

  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-2000%, -50%);
  z-index: 100;
}

.immersive-translate-loading-spinner {
  vertical-align: middle !important;
  width: 10px !important;
  height: 10px !important;
  display: inline-block !important;
  margin: 0 4px !important;
  border: 2px rgba(221, 244, 255, 0.6) solid !important;
  border-top: 2px rgba(0, 0, 0, 0.375) solid !important;
  border-left: 2px rgba(0, 0, 0, 0.375) solid !important;
  border-radius: 50% !important;
  padding: 0 !important;
  -webkit-animation: immersive-translate-loading-animation 0.6s infinite linear !important;
  animation: immersive-translate-loading-animation 0.6s infinite linear !important;
}

@-webkit-keyframes immersive-translate-loading-animation {
  from {
    -webkit-transform: rotate(0deg);
  }

  to {
    -webkit-transform: rotate(359deg);
  }
}

@keyframes immersive-translate-loading-animation {
  from {
    transform: rotate(0deg);
  }

  to {
    transform: rotate(359deg);
  }
}

.immersive-translate-input-loading {
  --loading-color: #f78fb6;
  width: 6px;
  height: 6px;
  border-radius: 50%;
  display: block;
  margin: 12px auto;
  position: relative;
  color: white;
  left: -100px;
  box-sizing: border-box;
  animation: immersiveTranslateShadowRolling 1.5s linear infinite;
}

@keyframes immersiveTranslateShadowRolling {
  0% {
    box-shadow: 0px 0 rgba(255, 255, 255, 0), 0px 0 rgba(255, 255, 255, 0),
      0px 0 rgba(255, 255, 255, 0), 0px 0 rgba(255, 255, 255, 0);
  }

  12% {
    box-shadow: 100px 0 var(--loading-color), 0px 0 rgba(255, 255, 255, 0),
      0px 0 rgba(255, 255, 255, 0), 0px 0 rgba(255, 255, 255, 0);
  }

  25% {
    box-shadow: 110px 0 var(--loading-color), 100px 0 var(--loading-color),
      0px 0 rgba(255, 255, 255, 0), 0px 0 rgba(255, 255, 255, 0);
  }

  36% {
    box-shadow: 120px 0 var(--loading-color), 110px 0 var(--loading-color),
      100px 0 var(--loading-color), 0px 0 rgba(255, 255, 255, 0);
  }

  50% {
    box-shadow: 130px 0 var(--loading-color), 120px 0 var(--loading-color),
      110px 0 var(--loading-color), 100px 0 var(--loading-color);
  }

  62% {
    box-shadow: 200px 0 rgba(255, 255, 255, 0), 130px 0 var(--loading-color),
      120px 0 var(--loading-color), 110px 0 var(--loading-color);
  }

  75% {
    box-shadow: 200px 0 rgba(255, 255, 255, 0), 200px 0 rgba(255, 255, 255, 0),
      130px 0 var(--loading-color), 120px 0 var(--loading-color);
  }

  87% {
    box-shadow: 200px 0 rgba(255, 255, 255, 0), 200px 0 rgba(255, 255, 255, 0),
      200px 0 rgba(255, 255, 255, 0), 130px 0 var(--loading-color);
  }

  100% {
    box-shadow: 200px 0 rgba(255, 255, 255, 0), 200px 0 rgba(255, 255, 255, 0),
      200px 0 rgba(255, 255, 255, 0), 200px 0 rgba(255, 255, 255, 0);
  }
}

.immersive-translate-toast {
  display: flex;
  position: fixed;
  z-index: 2147483647;
  left: 0;
  right: 0;
  top: 1%;
  width: fit-content;
  padding: 12px 20px;
  margin: auto;
  overflow: auto;
  background: #fef6f9;
  box-shadow: 0px 4px 10px 0px rgba(0, 10, 30, 0.06);
  font-size: 15px;
  border-radius: 8px;
  color: #333;
}

.immersive-translate-toast-content {
  display: flex;
  flex-direction: row;
  align-items: center;
}

.immersive-translate-toast-hidden {
  margin: 0 20px 0 72px;
  text-decoration: underline;
  cursor: pointer;
}

.immersive-translate-toast-close {
  color: #666666;
  font-size: 20px;
  font-weight: bold;
  padding: 0 10px;
  cursor: pointer;
}

@media screen and (max-width: 768px) {
  .immersive-translate-toast {
    top: 0;
    padding: 12px 0px 0 10px;
  }
  .immersive-translate-toast-content {
    flex-direction: column;
    text-align: center;
  }
  .immersive-translate-toast-hidden {
    margin: 10px auto;
  }
}

.immersive-translate-dialog {
  position: fixed;
  z-index: 2147483647;
  left: 0;
  top: 0;
  display: flex;
  width: 300px;
  flex-direction: column;
  align-items: center;
  font-size: 15px;
  left: 0;
  right: 0;
  top: 0;
  bottom: 0;
  margin: auto;
  height: fit-content;
  border-radius: 20px;
  background-color: #fff;
}

.immersive-translate-modal {
  display: none;
  position: fixed;
  z-index: 2147483647;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  overflow: auto;
  background-color: rgb(0, 0, 0);
  background-color: rgba(0, 0, 0, 0.4);
  font-size: 15px;
}

.immersive-translate-modal-content {
  background-color: #fefefe;
  margin: 10% auto;
  padding: 40px 24px 24px;
  border-radius: 12px;
  width: 350px;
  font-family: system-ui, -apple-system, "Segoe UI", "Roboto", "Ubuntu",
    "Cantarell", "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji",
    "Segoe UI Symbol", "Noto Color Emoji";
  position: relative;
}

@media screen and (max-width: 768px) {
  .immersive-translate-modal-content {
    margin: 25% auto !important;
  }
}

@media screen and (max-width: 480px) {
  .immersive-translate-modal-content {
    width: 80vw !important;
    margin: 20vh auto !important;
    padding: 20px 12px 12px !important;
  }

  .immersive-translate-modal-title {
    font-size: 14px !important;
  }

  .immersive-translate-modal-body {
    font-size: 13px !important;
    max-height: 60vh !important;
  }

  .immersive-translate-btn {
    font-size: 13px !important;
    padding: 8px 16px !important;
    margin: 0 4px !important;
  }

  .immersive-translate-modal-footer {
    gap: 6px !important;
    margin-top: 16px !important;
  }
}

.immersive-translate-modal .immersive-translate-modal-content-in-input {
  max-width: 500px;
}
.immersive-translate-modal-content-in-input .immersive-translate-modal-body {
  text-align: left;
  max-height: unset;
}

.immersive-translate-modal-title {
  text-align: center;
  font-size: 16px;
  font-weight: 700;
  color: #333333;
}

.immersive-translate-modal-body {
  text-align: center;
  font-size: 14px;
  font-weight: 400;
  color: #333333;
  margin-top: 24px;
  word-break: break-all;
}

@media screen and (max-width: 768px) {
  .immersive-translate-modal-body {
    max-height: 250px;
    overflow-y: auto;
  }
}

.immersive-translate-close {
  color: #666666;
  position: absolute;
  right: 16px;
  top: 16px;
  font-size: 20px;
  font-weight: bold;
}

.immersive-translate-close:hover,
.immersive-translate-close:focus {
  text-decoration: none;
  cursor: pointer;
}

.immersive-translate-modal-footer {
  display: flex;
  justify-content: center;
  flex-wrap: wrap;
  margin-top: 24px;
}

.immersive-translate-btn {
  width: fit-content;
  color: #fff;
  background-color: #ea4c89;
  border: none;
  font-size: 14px;
  margin: 0 8px;
  padding: 9px 30px;
  border-radius: 5px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: background-color 0.3s ease;
}

.immersive-translate-btn-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

.immersive-translate-btn:hover {
  background-color: #f082ac;
}
.immersive-translate-btn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}
.immersive-translate-btn:disabled:hover {
  background-color: #ea4c89;
}

.immersive-translate-link-btn {
  background-color: transparent;
  color: #ea4c89;
  border: none;
  cursor: pointer;
  height: 30px;
  line-height: 30px;
}

.immersive-translate-cancel-btn {
  /* gray color */
  background-color: rgb(89, 107, 120);
}

.immersive-translate-cancel-btn:hover {
  background-color: hsl(205, 20%, 32%);
}

.immersive-translate-action-btn {
  background-color: transparent;
  color: #ea4c89;
  border: 1px solid #ea4c89;
}

.immersive-translate-btn svg {
  margin-right: 5px;
}

.immersive-translate-link {
  cursor: pointer;
  user-select: none;
  -webkit-user-drag: none;
  text-decoration: none;
  color: #ea4c89;
  -webkit-tap-highlight-color: rgba(0, 0, 0, 0.1);
}

.immersive-translate-primary-link {
  cursor: pointer;
  user-select: none;
  -webkit-user-drag: none;
  text-decoration: none;
  color: #ea4c89;
  -webkit-tap-highlight-color: rgba(0, 0, 0, 0.1);
}

.immersive-translate-modal input[type="radio"] {
  margin: 0 6px;
  cursor: pointer;
}

.immersive-translate-modal label {
  cursor: pointer;
}

.immersive-translate-close-action {
  position: absolute;
  top: 2px;
  right: 0px;
  cursor: pointer;
}

.imt-image-status {
  background-color: rgba(0, 0, 0, 0.5) !important;
  display: flex !important;
  flex-direction: column !important;
  align-items: center !important;
  justify-content: center !important;
  border-radius: 16px !important;
}
.imt-image-status img,
.imt-image-status svg,
.imt-img-loading {
  width: 28px !important;
  height: 28px !important;
  margin: 0 0 8px 0 !important;
  min-height: 28px !important;
  min-width: 28px !important;
  position: relative !important;
}
.imt-img-loading {
  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAA4CAMAAACfWMssAAAAtFBMVEUAAAD////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////oK74hAAAAPHRSTlMABBMIDyQXHwyBfFdDMSw+OjXCb+5RG51IvV/k0rOqlGRM6KKMhdvNyZBz9MaupmxpWyj437iYd/yJVNZeuUC7AAACt0lEQVRIx53T2XKiUBCA4QYOiyCbiAsuuGBcYtxiYtT3f6/pbqoYHVFO5r+iivpo6DpAWYpqeoFfr9f90DsYAuRSWkFnPO50OgR9PwiCUFcl2GEcx+N/YBh6pvKaefHlUgZd1zVe0NbYcQjGBfzrPE8Xz8aF+71D8gG6DHFPpc4a7xFiCDuhaWgKgGIJQ3d5IMGDrpS4S5KgpIm+en9f6PlAhKby4JwEIxlYJV9h5k5nee9GoxHJ2IDSNB0dwdad1NAxDJ/uXDHYmebdk4PdbkS58CIVHdYSUHTYYRWOJblWSyu2lmy3KNFVJNBhxcuGW4YBVCbYGRZwIooipHsNqjM4FbgOQqQqSKQQU9V8xmi1QlgHqQQ6DDBvRUVCDirs+EzGDGOQTCATgtYTnbCVLgsVgRE0T1QE0qHCFAht2z6dLvJQs3Lo2FQoDxWNUiBhaP4eRgwNkI+dAjVOA/kUrIDwf3CG8NfNOE0eiFotSuo+rBiq8tD9oY4Qzc6YJw99hl1wzpQvD7ef2M8QgnOGJfJw+EltQc+oX2yn907QB22WZcvlUpd143dqQu+8pCJZuGE4xCuPXJqqcs5sNpsI93Rmzym1k4Npk+oD1SH3/a3LOK/JpUBpWfqNySxWzCfNCUITuDG5dtuphrUJ1myeIE9bIsPiKrfqTai5WZxbhtNphYx6GEIHihyGFTI69lje/rxajdh0s0msZ0zYxyPLhYCb1CyHm9Qsd2H37Y3lugVwL9kNh8Ot8cha6fUNQ8nuXi5z9/ExsAO4zQrb/ev1yrCB7lGyQzgYDGuxq1toDN/JGvN+HyWNHKB7zEoK+PX11e12G431erGYzwmytAWU56fkMHY5JJnDRR2eZji3AwtIcrEV8Cojat/BdQ7XOwGV1e1hDjGGjXbdArm8uJZtCH5MbcctVX8A1WpqumJHwckAAAAASUVORK5CYII=");
  background-size: 28px 28px;
  animation: image-loading-rotate 1s linear infinite !important;
}

.imt-image-status span {
  color: var(--bg-2, #fff) !important;
  font-size: 14px !important;
  line-height: 14px !important;
  font-weight: 500 !important;
  font-family: "PingFang SC", Arial, sans-serif !important;
}

.imt-primary-button {
  display: flex;
  padding: 12px 80px;
  justify-content: center;
  align-items: center;
  gap: 8px;
  border-radius: 8px;
  background: #ea4c89;
  color: #fff;
  font-size: 16px;
  font-style: normal;
  font-weight: 700;
  line-height: 24px;
  border: none;
  cursor: pointer;
}

.imt-retry-text {
  color: #999;
  text-align: center;
  font-size: 14px;
  font-style: normal;
  font-weight: 400;
  line-height: 21px;
  cursor: pointer;
}

.imt-action-container {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.imt-modal-content-text {
  text-align: left;
  color: #333;
  font-size: 16px;
  font-weight: 400;
  line-height: 24px;
}

@keyframes image-loading-rotate {
  from {
    transform: rotate(360deg);
  }
  to {
    transform: rotate(0deg);
  }
}

.imt-linear-gradient-text {
  background: linear-gradient(90deg, #00a6ff 0%, #c369ff 52.4%, #ff4590 100%);
  background-clip: text;
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

.imt-flex-center {
  display: flex;
  align-items: center;
  justify-content: center;
}

.imt-linear-black-btn {
  border-radius: 50px;
  background: linear-gradient(66deg, #222 19%, #696969 94.25%);
  height: 48px;
  width: 100%;
  color: #fff;
  font-size: 16px;
  font-weight: 700;
  display: flex;
  align-items: center;
  cursor: pointer;
  justify-content: center;
}
</style><style>pre { white-space: pre-wrap; }* { font-size: 100%; font-family: monospace; }</style><style>* { font-size: 100%; font-family: monospace; background: rgb(255, 255, 255); color: rgb(0, 0, 51); }pre { white-space: pre-wrap; }a:link { color: rgb(0, 0, 255); text-decoration: none; }a:visited { color: rgb(136, 0, 136); }.q { color: rgb(0, 0, 102); }.add { color: rgb(0, 102, 0); }.del { color: rgb(153, 0, 0); }.head { color: rgb(0, 0, 0); }.hunk { color: rgb(153, 102, 0); }.hl.num { color: rgb(255, 51, 0); }.hl.esc { color: rgb(255, 0, 255); }.hl.str { color: rgb(255, 51, 0); }.hl.ppc { color: rgb(204, 51, 204); }.hl.pps { color: rgb(255, 51, 0); }.hl.slc { color: rgb(0, 153, 153); }.hl.com { color: rgb(0, 153, 153); }.hl.kwa { color: rgb(255, 153, 0); }.hl.kwb { color: rgb(0, 102, 0); }.hl.kwc { color: rgb(255, 153, 0); }</style><style>* { font-size: 100%; font-family: monospace; background: rgb(0, 0, 0); color: rgb(204, 204, 204); }pre { white-space: pre-wrap; }a:link { color: rgb(102, 153, 255); text-decoration: none; }a:visited { color: rgb(153, 102, 255); }.q { color: rgb(0, 153, 255); }.add { color: rgb(0, 255, 255); }.del { color: rgb(255, 0, 255); }.head { color: rgb(255, 255, 255); }.hunk { color: rgb(204, 153, 51); }.hl.num { color: rgb(255, 51, 0); }.hl.esc { color: rgb(255, 0, 255); }.hl.str { color: rgb(255, 51, 0); }.hl.ppc { color: rgb(255, 0, 255); }.hl.pps { color: rgb(255, 51, 0); }.hl.slc { color: rgb(0, 153, 255); }.hl.com { color: rgb(0, 153, 255); }.hl.kwa { color: rgb(255, 255, 0); }.hl.kwb { color: rgb(0, 255, 0); }.hl.kwc { color: rgb(255, 255, 0); }</style></head><body><form action="../"><pre><a href="../?t=20200507140224"><b>All of lore.kernel.org</b></a>
<input name="q" type="text"><input type="submit" value="search"> <a href="../_/text/help/">help</a> / <a href="../_/text/color/">color</a> / <a id="mirror" href="../_/text/mirror/">mirror</a> / <a href="../new.atom">Atom feed</a></pre></form><pre id="b">From: David Hildenbrand &lt;david@redhat.com&gt;
To: <a href="../../lkml/?t=20200507140224">linux-kernel@vger.kernel.org</a>
Cc: <a href="../../linux-mm/?t=20200507140224">linux-mm@kvack.org</a>, virtio-dev@lists.oasis-open.org,
	<a href="../../virtualization/?t=20200507140224">virtualization@lists.linux-foundation.org</a>, <a href="../../kvm/?t=20200507140224">kvm@vger.kernel.org</a>,
	Michal Hocko &lt;mhocko@kernel.org&gt;,
	Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	"Michael S . Tsirkin" &lt;mst@redhat.com&gt;,
	David Hildenbrand &lt;david@redhat.com&gt;,
	Pankaj Gupta &lt;pankaj.gupta.linux@gmail.com&gt;,
	Jason Wang &lt;jasowang@redhat.com&gt;,
	Oscar Salvador &lt;osalvador@suse.de&gt;,
	Igor Mammedov &lt;imammedo@redhat.com&gt;,
	Dave Young &lt;dyoung@redhat.com&gt;,
	Dan Williams &lt;dan.j.williams@intel.com&gt;,
	Pavel Tatashin &lt;pasha.tatashin@soleen.com&gt;,
	Stefan Hajnoczi &lt;stefanha@redhat.com&gt;,
	Vlastimil Babka &lt;vbabka@suse.cz&gt;,
	"Rafael J. Wysocki" &lt;rjw@rjwysocki.net&gt;,
	Len Brown &lt;lenb@kernel.org&gt;,
	<a href="../../linux-acpi/?t=20200507140224">linux-acpi@vger.kernel.org</a>
Subject: <a href="#r" id="t">[virtio-dev] [PATCH v4 01/15] virtio-mem: Paravirtualized memory hotplug</a>
Date: Thu,  7 May 2020 16:01:25 +0200	<a href="#r">[thread overview]</a>
Message-ID: &lt;20200507140139.17083-2-david@redhat.com&gt; (<a href="raw">raw</a>)
In-Reply-To: &lt;<a href="../20200507140139.17083-1-david@redhat.com/">20200507140139.17083-1-david@redhat.com</a>&gt;

Each virtio-mem device owns exactly one memory region. It is responsible
for adding/removing memory from that memory region on request.

When the device driver starts up, the requested amount of memory is
queried and then plugged to Linux. On request, further memory can be
plugged or unplugged. This patch only implements the plugging part.

On x86-64, memory can currently be plugged in 4MB ("subblock") granularity.
When required, a new memory block will be added (e.g., usually 128MB on
x86-64) in order to plug more subblocks. Only x86-64 was tested for now.

The online_page callback is used to keep unplugged subblocks offline
when onlining memory - similar to the Hyper-V balloon driver. Unplugged
pages are marked PG_offline, to tell dump tools (e.g., makedumpfile) to
skip them.

User space is usually responsible for onlining the added memory. The
memory hotplug notifier is used to synchronize virtio-mem activity
against memory onlining/offlining.

Each virtio-mem device can belong to a NUMA node, which allows us to
easily add/remove small chunks of memory to/from a specific NUMA node by
using multiple virtio-mem devices. Something that works even when the
guest has no idea about the NUMA topology.

One way to view virtio-mem is as a "resizable DIMM" or a DIMM with many
"sub-DIMMS".

This patch directly introduces the basic infrastructure to implement memory
unplug. Especially the memory block states and subblock bitmaps will be
heavily used there.

Notes:
- In case memory is to be onlined by user space, we limit the amount of
  offline memory blocks, to not run out of memory. This is esp. an
  issue if memory is added faster than it is getting onlined.
- Suspend/Hibernate is not supported due to the way virtio-mem devices
  behave. Limited support might be possible in the future.
- Reloading the device driver is not supported.

Reviewed-by: Pankaj Gupta &lt;pankaj.gupta.linux@gmail.com&gt;
Tested-by: Pankaj Gupta &lt;pankaj.gupta.linux@gmail.com&gt;
Cc: "Michael S. Tsirkin" &lt;mst@redhat.com&gt;
Cc: Jason Wang &lt;jasowang@redhat.com&gt;
Cc: Oscar Salvador &lt;osalvador@suse.de&gt;
Cc: Michal Hocko &lt;mhocko@kernel.org&gt;
Cc: Igor Mammedov &lt;imammedo@redhat.com&gt;
Cc: Dave Young &lt;dyoung@redhat.com&gt;
Cc: Andrew Morton &lt;akpm@linux-foundation.org&gt;
Cc: Dan Williams &lt;dan.j.williams@intel.com&gt;
Cc: Pavel Tatashin &lt;pasha.tatashin@soleen.com&gt;
Cc: Stefan Hajnoczi &lt;stefanha@redhat.com&gt;
Cc: Vlastimil Babka &lt;vbabka@suse.cz&gt;
Cc: "Rafael J. Wysocki" &lt;rjw@rjwysocki.net&gt;
Cc: Len Brown &lt;lenb@kernel.org&gt;
Cc: linux-acpi@vger.kernel.org
Signed-off-by: David Hildenbrand &lt;david@redhat.com&gt;
---
 <a id="iZ2e.:20200507140139.17083-2-david::40redhat.com:1drivers:virtio:Kconfig" href="#Z2e.:20200507140139.17083-2-david::40redhat.com:1drivers:virtio:Kconfig">drivers/virtio/Kconfig</a>          |   16 +
 <a id="iZ2e.:20200507140139.17083-2-david::40redhat.com:1drivers:virtio:Makefile" href="#Z2e.:20200507140139.17083-2-david::40redhat.com:1drivers:virtio:Makefile">drivers/virtio/Makefile</a>         |    1 +
 <a id="iZ2e.:20200507140139.17083-2-david::40redhat.com:1drivers:virtio:virtio_mem.c" href="#Z2e.:20200507140139.17083-2-david::40redhat.com:1drivers:virtio:virtio_mem.c">drivers/virtio/virtio_mem.c</a>     | 1533 +++++++++++++++++++++++++++++++
 <a id="iZ2e.:20200507140139.17083-2-david::40redhat.com:1include:uapi:linux:virtio_ids.h" href="#Z2e.:20200507140139.17083-2-david::40redhat.com:1include:uapi:linux:virtio_ids.h">include/uapi/linux/virtio_ids.h</a> |    1 +
 <a id="iZ2e.:20200507140139.17083-2-david::40redhat.com:1include:uapi:linux:virtio_mem.h" href="#Z2e.:20200507140139.17083-2-david::40redhat.com:1include:uapi:linux:virtio_mem.h">include/uapi/linux/virtio_mem.h</a> |  200 ++++
 5 files <a href="#related">changed</a>, 1751 insertions(+)
 create mode 100644 drivers/virtio/virtio_mem.c
 create mode 100644 include/uapi/linux/virtio_mem.h

<span class="head"><a href="#iZ2e.:20200507140139.17083-2-david::40redhat.com:1drivers:virtio:Kconfig" id="Z2e.:20200507140139.17083-2-david::40redhat.com:1drivers:virtio:Kconfig">diff</a> --git a/drivers/virtio/Kconfig b/drivers/virtio/Kconfig
index 69a32dfc318a..d6dde7d2cf76 100644
--- a/drivers/virtio/Kconfig
+++ b/drivers/virtio/Kconfig
</span><span class="hunk">@@ -78,6 +78,22 @@ config VIRTIO_BALLOON
</span> 
 	 If unsure, say M.
 
<span class="add">+config VIRTIO_MEM
+	tristate "Virtio mem driver"
+	default m
+	depends on X86_64
+	depends on VIRTIO
+	depends on MEMORY_HOTPLUG_SPARSE
+	depends on MEMORY_HOTREMOVE
+	help
+	 This driver provides access to virtio-mem paravirtualized memory
+	 devices, allowing to hotplug and hotunplug memory.
+
+	 This driver was only tested under x86-64, but should theoretically
+	 work on all architectures that support memory hotplug and hotremove.
+
+	 If unsure, say M.
+
</span> config VIRTIO_INPUT
 	tristate "Virtio input driver"
 	depends on VIRTIO
<span class="head"><a href="#iZ2e.:20200507140139.17083-2-david::40redhat.com:1drivers:virtio:Makefile" id="Z2e.:20200507140139.17083-2-david::40redhat.com:1drivers:virtio:Makefile">diff</a> --git a/drivers/virtio/Makefile b/drivers/virtio/Makefile
index 29a1386ecc03..4d993791f2d7 100644
--- a/drivers/virtio/Makefile
+++ b/drivers/virtio/Makefile
</span><span class="hunk">@@ -7,3 +7,4 @@ virtio_pci-$(CONFIG_VIRTIO_PCI_LEGACY) += virtio_pci_legacy.o
</span> obj-$(CONFIG_VIRTIO_BALLOON) += virtio_balloon.o
 obj-$(CONFIG_VIRTIO_INPUT) += virtio_input.o
 obj-$(CONFIG_VIRTIO_VDPA) += virtio_vdpa.o
<span class="add">+obj-$(CONFIG_VIRTIO_MEM) += virtio_mem.o
</span><span class="head"><a href="#iZ2e.:20200507140139.17083-2-david::40redhat.com:1drivers:virtio:virtio_mem.c" id="Z2e.:20200507140139.17083-2-david::40redhat.com:1drivers:virtio:virtio_mem.c">diff</a> --git a/drivers/virtio/virtio_mem.c b/drivers/virtio/virtio_mem.c
new file mode 100644
index 000000000000..5d1dcaa6fc42
--- /dev/null
+++ b/drivers/virtio/virtio_mem.c
</span><span class="hunk">@@ -0,0 +1,1533 @@
</span><span class="add">+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Virtio-mem device driver.
+ *
+ * Copyright Red Hat, Inc. 2020
+ *
+ * Author(s): David Hildenbrand &lt;david@redhat.com&gt;
+ */
+
+#include &lt;linux/virtio.h&gt;
+#include &lt;linux/virtio_mem.h&gt;
+#include &lt;linux/workqueue.h&gt;
+#include &lt;linux/slab.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/mm.h&gt;
+#include &lt;linux/memory_hotplug.h&gt;
+#include &lt;linux/memory.h&gt;
+#include &lt;linux/hrtimer.h&gt;
+#include &lt;linux/crash_dump.h&gt;
+#include &lt;linux/mutex.h&gt;
+#include &lt;linux/bitmap.h&gt;
+#include &lt;linux/lockdep.h&gt;
+
+enum virtio_mem_mb_state {
+	/* Unplugged, not added to Linux. Can be reused later. */
+	VIRTIO_MEM_MB_STATE_UNUSED = 0,
+	/* (Partially) plugged, not added to Linux. Error on add_memory(). */
+	VIRTIO_MEM_MB_STATE_PLUGGED,
+	/* Fully plugged, fully added to Linux, offline. */
+	VIRTIO_MEM_MB_STATE_OFFLINE,
+	/* Partially plugged, fully added to Linux, offline. */
+	VIRTIO_MEM_MB_STATE_OFFLINE_PARTIAL,
+	/* Fully plugged, fully added to Linux, online (!ZONE_MOVABLE). */
+	VIRTIO_MEM_MB_STATE_ONLINE,
+	/* Partially plugged, fully added to Linux, online (!ZONE_MOVABLE). */
+	VIRTIO_MEM_MB_STATE_ONLINE_PARTIAL,
+	/*
+	 * Fully plugged, fully added to Linux, online (ZONE_MOVABLE).
+	 * We are not allowed to allocate (unplug) parts of this block that
+	 * are not movable (similar to gigantic pages). We will never allow
+	 * to online OFFLINE_PARTIAL to ZONE_MOVABLE (as they would contain
+	 * unmovable parts).
+	 */
+	VIRTIO_MEM_MB_STATE_ONLINE_MOVABLE,
+	VIRTIO_MEM_MB_STATE_COUNT
+};
+
+struct virtio_mem {
+	struct virtio_device *vdev;
+
+	/* We might first have to unplug all memory when starting up. */
+	bool unplug_all_required;
+
+	/* Workqueue that processes the plug/unplug requests. */
+	struct work_struct wq;
+	atomic_t config_changed;
+
+	/* Virtqueue for guest-&gt;host requests. */
+	struct virtqueue *vq;
+
+	/* Wait for a host response to a guest request. */
+	wait_queue_head_t host_resp;
+
+	/* Space for one guest request and the host response. */
+	struct virtio_mem_req req;
+	struct virtio_mem_resp resp;
+
+	/* The current size of the device. */
+	uint64_t plugged_size;
+	/* The requested size of the device. */
+	uint64_t requested_size;
+
+	/* The device block size (for communicating with the device). */
+	uint32_t device_block_size;
+	/* Physical start address of the memory region. */
+	uint64_t addr;
+	/* Maximum region size in bytes. */
+	uint64_t region_size;
+
+	/* The subblock size. */
+	uint32_t subblock_size;
+	/* The number of subblocks per memory block. */
+	uint32_t nb_sb_per_mb;
+
+	/* Id of the first memory block of this device. */
+	unsigned long first_mb_id;
+	/* Id of the last memory block of this device. */
+	unsigned long last_mb_id;
+	/* Id of the last usable memory block of this device. */
+	unsigned long last_usable_mb_id;
+	/* Id of the next memory bock to prepare when needed. */
+	unsigned long next_mb_id;
+
+	/* Summary of all memory block states. */
+	unsigned long nb_mb_state[VIRTIO_MEM_MB_STATE_COUNT];
+#define VIRTIO_MEM_NB_OFFLINE_THRESHOLD		10
+
+	/*
+	 * One byte state per memory block.
+	 *
+	 * Allocated via vmalloc(). When preparing new blocks, resized
+	 * (alloc+copy+free) when needed (crossing pages with the next mb).
+	 * (when crossing pages).
+	 *
+	 * With 128MB memory blocks, we have states for 512GB of memory in one
+	 * page.
+	 */
+	uint8_t *mb_state;
+
+	/*
+	 * $nb_sb_per_mb bit per memory block. Handled similar to mb_state.
+	 *
+	 * With 4MB subblocks, we manage 128GB of memory in one page.
+	 */
+	unsigned long *sb_bitmap;
+
+	/*
+	 * Mutex that protects the nb_mb_state, mb_state, and sb_bitmap.
+	 *
+	 * When this lock is held the pointers can't change, ONLINE and
+	 * OFFLINE blocks can't change the state and no subblocks will get
+	 * plugged.
+	 */
+	struct mutex hotplug_mutex;
+	bool hotplug_active;
+
+	/* An error occurred we cannot handle - stop processing requests. */
+	bool broken;
+
+	/* The driver is being removed. */
+	spinlock_t removal_lock;
+	bool removing;
+
+	/* Timer for retrying to plug/unplug memory. */
+	struct hrtimer retry_timer;
+#define VIRTIO_MEM_RETRY_TIMER_MS		30000
+
+	/* Memory notifier (online/offline events). */
+	struct notifier_block memory_notifier;
+
+	/* Next device in the list of virtio-mem devices. */
+	struct list_head next;
+};
+
+/*
+ * We have to share a single online_page callback among all virtio-mem
+ * devices. We use RCU to iterate the list in the callback.
+ */
+static DEFINE_MUTEX(virtio_mem_mutex);
+static LIST_HEAD(virtio_mem_devices);
+
+static void virtio_mem_online_page_cb(struct page *page, unsigned int order);
+
+/*
+ * Register a virtio-mem device so it will be considered for the online_page
+ * callback.
+ */
+static int register_virtio_mem_device(struct virtio_mem *vm)
+{
+	int rc = 0;
+
+	/* First device registers the callback. */
+	mutex_lock(&amp;virtio_mem_mutex);
+	if (list_empty(&amp;virtio_mem_devices))
+		rc = set_online_page_callback(&amp;virtio_mem_online_page_cb);
+	if (!rc)
+		list_add_rcu(&amp;vm-&gt;next, &amp;virtio_mem_devices);
+	mutex_unlock(&amp;virtio_mem_mutex);
+
+	return rc;
+}
+
+/*
+ * Unregister a virtio-mem device so it will no longer be considered for the
+ * online_page callback.
+ */
+static void unregister_virtio_mem_device(struct virtio_mem *vm)
+{
+	/* Last device unregisters the callback. */
+	mutex_lock(&amp;virtio_mem_mutex);
+	list_del_rcu(&amp;vm-&gt;next);
+	if (list_empty(&amp;virtio_mem_devices))
+		restore_online_page_callback(&amp;virtio_mem_online_page_cb);
+	mutex_unlock(&amp;virtio_mem_mutex);
+
+	synchronize_rcu();
+}
+
+/*
+ * Calculate the memory block id of a given address.
+ */
+static unsigned long virtio_mem_phys_to_mb_id(unsigned long addr)
+{
+	return addr / memory_block_size_bytes();
+}
+
+/*
+ * Calculate the physical start address of a given memory block id.
+ */
+static unsigned long virtio_mem_mb_id_to_phys(unsigned long mb_id)
+{
+	return mb_id * memory_block_size_bytes();
+}
+
+/*
+ * Calculate the subblock id of a given address.
+ */
+static unsigned long virtio_mem_phys_to_sb_id(struct virtio_mem *vm,
+					      unsigned long addr)
+{
+	const unsigned long mb_id = virtio_mem_phys_to_mb_id(addr);
+	const unsigned long mb_addr = virtio_mem_mb_id_to_phys(mb_id);
+
+	return (addr - mb_addr) / vm-&gt;subblock_size;
+}
+
+/*
+ * Set the state of a memory block, taking care of the state counter.
+ */
+static void virtio_mem_mb_set_state(struct virtio_mem *vm, unsigned long mb_id,
+				    enum virtio_mem_mb_state state)
+{
+	const unsigned long idx = mb_id - vm-&gt;first_mb_id;
+	enum virtio_mem_mb_state old_state;
+
+	old_state = vm-&gt;mb_state[idx];
+	vm-&gt;mb_state[idx] = state;
+
+	BUG_ON(vm-&gt;nb_mb_state[old_state] == 0);
+	vm-&gt;nb_mb_state[old_state]--;
+	vm-&gt;nb_mb_state[state]++;
+}
+
+/*
+ * Get the state of a memory block.
+ */
+static enum virtio_mem_mb_state virtio_mem_mb_get_state(struct virtio_mem *vm,
+							unsigned long mb_id)
+{
+	const unsigned long idx = mb_id - vm-&gt;first_mb_id;
+
+	return vm-&gt;mb_state[idx];
+}
+
+/*
+ * Prepare the state array for the next memory block.
+ */
+static int virtio_mem_mb_state_prepare_next_mb(struct virtio_mem *vm)
+{
+	unsigned long old_bytes = vm-&gt;next_mb_id - vm-&gt;first_mb_id + 1;
+	unsigned long new_bytes = vm-&gt;next_mb_id - vm-&gt;first_mb_id + 2;
+	int old_pages = PFN_UP(old_bytes);
+	int new_pages = PFN_UP(new_bytes);
+	uint8_t *new_mb_state;
+
+	if (vm-&gt;mb_state &amp;&amp; old_pages == new_pages)
+		return 0;
+
+	new_mb_state = vzalloc(new_pages * PAGE_SIZE);
+	if (!new_mb_state)
+		return -ENOMEM;
+
+	mutex_lock(&amp;vm-&gt;hotplug_mutex);
+	if (vm-&gt;mb_state)
+		memcpy(new_mb_state, vm-&gt;mb_state, old_pages * PAGE_SIZE);
+	vfree(vm-&gt;mb_state);
+	vm-&gt;mb_state = new_mb_state;
+	mutex_unlock(&amp;vm-&gt;hotplug_mutex);
+
+	return 0;
+}
+
+#define virtio_mem_for_each_mb_state(_vm, _mb_id, _state) \n+	for (_mb_id = _vm-&gt;first_mb_id; \n+	     _mb_id &lt; _vm-&gt;next_mb_id &amp;&amp; _vm-&gt;nb_mb_state[_state]; \n+	     _mb_id++) \n+		if (virtio_mem_mb_get_state(_vm, _mb_id) == _state)
+
+/*
+ * Mark all selected subblocks plugged.
+ *
+ * Will not modify the state of the memory block.
+ */
+static void virtio_mem_mb_set_sb_plugged(struct virtio_mem *vm,
+					 unsigned long mb_id, int sb_id,
+					 int count)
+{
+	const int bit = (mb_id - vm-&gt;first_mb_id) * vm-&gt;nb_sb_per_mb + sb_id;
+
+	__bitmap_set(vm-&gt;sb_bitmap, bit, count);
+}
+
+/*
+ * Mark all selected subblocks unplugged.
+ *
+ * Will not modify the state of the memory block.
+ */
+static void virtio_mem_mb_set_sb_unplugged(struct virtio_mem *vm,
+					   unsigned long mb_id, int sb_id,
+					   int count)
+{
+	const int bit = (mb_id - vm-&gt;first_mb_id) * vm-&gt;nb_sb_per_mb + sb_id;
+
+	__bitmap_clear(vm-&gt;sb_bitmap, bit, count);
+}
+
+/*
+ * Test if all selected subblocks are plugged.
+ */
+static bool virtio_mem_mb_test_sb_plugged(struct virtio_mem *vm,
+					  unsigned long mb_id, int sb_id,
+					  int count)
+{
+	const int bit = (mb_id - vm-&gt;first_mb_id) * vm-&gt;nb_sb_per_mb + sb_id;
+
+	if (count == 1)
+		return test_bit(bit, vm-&gt;sb_bitmap);
+
+	/* TODO: Helper similar to bitmap_set() */
+	return find_next_zero_bit(vm-&gt;sb_bitmap, bit + count, bit) &gt;=
+	       bit + count;
+}
+
+/*
+ * Find the first plugged subblock. Returns vm-&gt;nb_sb_per_mb in case there is
+ * none.
+ */
+static int virtio_mem_mb_first_plugged_sb(struct virtio_mem *vm,
+					  unsigned long mb_id)
+{
+	const int bit = (mb_id - vm-&gt;first_mb_id) * vm-&gt;nb_sb_per_mb;
+
+	return find_next_bit(vm-&gt;sb_bitmap, bit + vm-&gt;nb_sb_per_mb, bit) - bit;
+}
+
+/*
+ * Find the first unplugged subblock. Returns vm-&gt;nb_sb_per_mb in case there is
+ * none.
+ */
+static int virtio_mem_mb_first_unplugged_sb(struct virtio_mem *vm,
+					    unsigned long mb_id)
+{
+	const int bit = (mb_id - vm-&gt;first_mb_id) * vm-&gt;nb_sb_per_mb;
+
+	return find_next_zero_bit(vm-&gt;sb_bitmap, bit + vm-&gt;nb_sb_per_mb, bit) -
+	       bit;
+}
+
+/*
+ * Prepare the subblock bitmap for the next memory block.
+ */
+static int virtio_mem_sb_bitmap_prepare_next_mb(struct virtio_mem *vm)
+{
+	const unsigned long old_nb_mb = vm-&gt;next_mb_id - vm-&gt;first_mb_id;
+	const unsigned long old_nb_bits = old_nb_mb * vm-&gt;nb_sb_per_mb;
+	const unsigned long new_nb_bits = (old_nb_mb + 1) * vm-&gt;nb_sb_per_mb;
+	int old_pages = PFN_UP(BITS_TO_LONGS(old_nb_bits) * sizeof(long));
+	int new_pages = PFN_UP(BITS_TO_LONGS(new_nb_bits) * sizeof(long));
+	unsigned long *new_sb_bitmap, *old_sb_bitmap;
+
+	if (vm-&gt;sb_bitmap &amp;&amp; old_pages == new_pages)
+		return 0;
+
+	new_sb_bitmap = vzalloc(new_pages * PAGE_SIZE);
+	if (!new_sb_bitmap)
+		return -ENOMEM;
+
+	mutex_lock(&amp;vm-&gt;hotplug_mutex);
+	if (new_sb_bitmap)
+		memcpy(new_sb_bitmap, vm-&gt;sb_bitmap, old_pages * PAGE_SIZE);
+
+	old_sb_bitmap = vm-&gt;sb_bitmap;
+	vm-&gt;sb_bitmap = new_sb_bitmap;
+	mutex_unlock(&amp;vm-&gt;hotplug_mutex);
+
+	vfree(old_sb_bitmap);
+	return 0;
+}
+
+/*
+ * Try to add a memory block to Linux. This will usually only fail
+ * if out of memory.
+ *
+ * Must not be called with the vm-&gt;hotplug_mutex held (possible deadlock with
+ * onlining code).
+ *
+ * Will not modify the state of the memory block.
+ */
+static int virtio_mem_mb_add(struct virtio_mem *vm, unsigned long mb_id)
+{
+	const uint64_t addr = virtio_mem_mb_id_to_phys(mb_id);
+	int nid = memory_add_physaddr_to_nid(addr);
+
+	dev_dbg(&amp;vm-&gt;vdev-&gt;dev, "adding memory block: %lu
", mb_id);
+	return add_memory(nid, addr, memory_block_size_bytes());
+}
+
+/*
+ * Try to remove a memory block from Linux. Will only fail if the memory block
+ * is not offline.
+ *
+ * Must not be called with the vm-&gt;hotplug_mutex held (possible deadlock with
+ * onlining code).
+ *
+ * Will not modify the state of the memory block.
+ */
+static int virtio_mem_mb_remove(struct virtio_mem *vm, unsigned long mb_id)
+{
+	const uint64_t addr = virtio_mem_mb_id_to_phys(mb_id);
+	int nid = memory_add_physaddr_to_nid(addr);
+
+	dev_dbg(&amp;vm-&gt;vdev-&gt;dev, "removing memory block: %lu
", mb_id);
+	return remove_memory(nid, addr, memory_block_size_bytes());
+}
+
+/*
+ * Trigger the workqueue so the device can perform its magic.
+ */
+static void virtio_mem_retry(struct virtio_mem *vm)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&amp;vm-&gt;removal_lock, flags);
+	if (!vm-&gt;removing)
+		queue_work(system_freezable_wq, &amp;vm-&gt;wq);
+	spin_unlock_irqrestore(&amp;vm-&gt;removal_lock, flags);
+}
+
+/*
+ * Test if a virtio-mem device overlaps with the given range. Can be called
+ * from (notifier) callbacks lockless.
+ */
+static bool virtio_mem_overlaps_range(struct virtio_mem *vm,
+				      unsigned long start, unsigned long size)
+{
+	unsigned long dev_start = virtio_mem_mb_id_to_phys(vm-&gt;first_mb_id);
+	unsigned long dev_end = virtio_mem_mb_id_to_phys(vm-&gt;last_mb_id) +
+				memory_block_size_bytes();
+
+	return start &lt; dev_end &amp;&amp; dev_start &lt; start + size;
+}
+
+/*
+ * Test if a virtio-mem device owns a memory block. Can be called from
+ * (notifier) callbacks lockless.
+ */
+static bool virtio_mem_owned_mb(struct virtio_mem *vm, unsigned long mb_id)
+{
+	return mb_id &gt;= vm-&gt;first_mb_id &amp;&amp; mb_id &lt;= vm-&gt;last_mb_id;
+}
+
+static int virtio_mem_notify_going_online(struct virtio_mem *vm,
+					  unsigned long mb_id,
+					  enum zone_type zone)
+{
+	switch (virtio_mem_mb_get_state(vm, mb_id)) {
+	case VIRTIO_MEM_MB_STATE_OFFLINE_PARTIAL:
+		/*
+		 * We won't allow to online a partially plugged memory block
+		 * to the MOVABLE zone - it would contain unmovable parts.
+		 */
+		if (zone == ZONE_MOVABLE) {
+			dev_warn_ratelimited(&amp;vm-&gt;vdev-&gt;dev,
+					     "memory block has holes, MOVABLE not supported
");
+			return NOTIFY_BAD;
+		}
+		return NOTIFY_OK;
+	case VIRTIO_MEM_MB_STATE_OFFLINE:
+		return NOTIFY_OK;
+	default:
+		break;
+	}
+	dev_warn_ratelimited(&amp;vm-&gt;vdev-&gt;dev,
+			     "memory block onlining denied
");
+	return NOTIFY_BAD;
+}
+
+static void virtio_mem_notify_offline(struct virtio_mem *vm,
+				      unsigned long mb_id)
+{
+	switch (virtio_mem_mb_get_state(vm, mb_id)) {
+	case VIRTIO_MEM_MB_STATE_ONLINE_PARTIAL:
+		virtio_mem_mb_set_state(vm, mb_id,
+					VIRTIO_MEM_MB_STATE_OFFLINE_PARTIAL);
+		break;
+	case VIRTIO_MEM_MB_STATE_ONLINE:
+	case VIRTIO_MEM_MB_STATE_ONLINE_MOVABLE:
+		virtio_mem_mb_set_state(vm, mb_id,
+					VIRTIO_MEM_MB_STATE_OFFLINE);
+		break;
+	default:
+		BUG();
+		break;
+	}
+}
+
+static void virtio_mem_notify_online(struct virtio_mem *vm, unsigned long mb_id,
+				     enum zone_type zone)
+{
+	unsigned long nb_offline;
+
+	switch (virtio_mem_mb_get_state(vm, mb_id)) {
+	case VIRTIO_MEM_MB_STATE_OFFLINE_PARTIAL:
+		BUG_ON(zone == ZONE_MOVABLE);
+		virtio_mem_mb_set_state(vm, mb_id,
+					VIRTIO_MEM_MB_STATE_ONLINE_PARTIAL);
+		break;
+	case VIRTIO_MEM_MB_STATE_OFFLINE:
+		if (zone == ZONE_MOVABLE)
+			virtio_mem_mb_set_state(vm, mb_id,
+					    VIRTIO_MEM_MB_STATE_ONLINE_MOVABLE);
+		else
+			virtio_mem_mb_set_state(vm, mb_id,
+						VIRTIO_MEM_MB_STATE_ONLINE);
+		break;
+	default:
+		BUG();
+		break;
+	}
+	nb_offline = vm-&gt;nb_mb_state[VIRTIO_MEM_MB_STATE_OFFLINE] +
+		     vm-&gt;nb_mb_state[VIRTIO_MEM_MB_STATE_OFFLINE_PARTIAL];
+
+	/* see if we can add new blocks now that we onlined one block */
+	if (nb_offline == VIRTIO_MEM_NB_OFFLINE_THRESHOLD - 1)
+		virtio_mem_retry(vm);
+}
+
+/*
+ * This callback will either be called synchronously from add_memory() or
+ * asynchronously (e.g., triggered via user space). We have to be careful
+ * with locking when calling add_memory().
+ */
+static int virtio_mem_memory_notifier_cb(struct notifier_block *nb,
+					 unsigned long action, void *arg)
+{
+	struct virtio_mem *vm = container_of(nb, struct virtio_mem,
+					     memory_notifier);
+	struct memory_notify *mhp = arg;
+	const unsigned long start = PFN_PHYS(mhp-&gt;start_pfn);
+	const unsigned long size = PFN_PHYS(mhp-&gt;nr_pages);
+	const unsigned long mb_id = virtio_mem_phys_to_mb_id(start);
+	enum zone_type zone;
+	int rc = NOTIFY_OK;
+
+	if (!virtio_mem_overlaps_range(vm, start, size))
+		return NOTIFY_DONE;
+
+	/*
+	 * Memory is onlined/offlined in memory block granularity. We cannot
+	 * cross virtio-mem device boundaries and memory block boundaries. Bail
+	 * out if this ever changes.
+	 */
+	if (WARN_ON_ONCE(size != memory_block_size_bytes() ||
+			 !IS_ALIGNED(start, memory_block_size_bytes())))
+		return NOTIFY_BAD;
+
+	/*
+	 * Avoid circular locking lockdep warnings. We lock the mutex
+	 * e.g., in MEM_GOING_ONLINE and unlock it in MEM_ONLINE. The
+	 * blocking_notifier_call_chain() has it's own lock, which gets unlocked
+	 * between both notifier calls and will bail out. False positive.
+	 */
+	lockdep_off();
+
+	switch (action) {
+	case MEM_GOING_OFFLINE:
+		mutex_lock(&amp;vm-&gt;hotplug_mutex);
+		if (vm-&gt;removing) {
+			rc = notifier_from_errno(-EBUSY);
+			mutex_unlock(&amp;vm-&gt;hotplug_mutex);
+			break;
+		}
+		vm-&gt;hotplug_active = true;
+		break;
+	case MEM_GOING_ONLINE:
+		mutex_lock(&amp;vm-&gt;hotplug_mutex);
+		if (vm-&gt;removing) {
+			rc = notifier_from_errno(-EBUSY);
+			mutex_unlock(&amp;vm-&gt;hotplug_mutex);
+			break;
+		}
+		vm-&gt;hotplug_active = true;
+		zone = page_zonenum(pfn_to_page(mhp-&gt;start_pfn));
+		rc = virtio_mem_notify_going_online(vm, mb_id, zone);
+		break;
+	case MEM_OFFLINE:
+		virtio_mem_notify_offline(vm, mb_id);
+		vm-&gt;hotplug_active = false;
+		mutex_unlock(&amp;vm-&gt;hotplug_mutex);
+		break;
+	case MEM_ONLINE:
+		zone = page_zonenum(pfn_to_page(mhp-&gt;start_pfn));
+		virtio_mem_notify_online(vm, mb_id, zone);
+		vm-&gt;hotplug_active = false;
+		mutex_unlock(&amp;vm-&gt;hotplug_mutex);
+		break;
+	case MEM_CANCEL_OFFLINE:
+	case MEM_CANCEL_ONLINE:
+		if (!vm-&gt;hotplug_active)
+			break;
+		vm-&gt;hotplug_active = false;
+		mutex_unlock(&amp;vm-&gt;hotplug_mutex);
+		break;
+	default:
+		break;
+	}
+
+	lockdep_on();
+
+	return rc;
+}
+
+/*
+ * Set a range of pages PG_offline.
+ */
+static void virtio_mem_set_fake_offline(unsigned long pfn,
+					unsigned int nr_pages)
+{
+	for (; nr_pages--; pfn++)
+		__SetPageOffline(pfn_to_page(pfn));
+}
+
+/*
+ * Clear PG_offline from a range of pages.
+ */
+static void virtio_mem_clear_fake_offline(unsigned long pfn,
+					  unsigned int nr_pages)
+{
+	for (; nr_pages--; pfn++)
+		__ClearPageOffline(pfn_to_page(pfn));
+}
+
+/*
+ * Release a range of fake-offline pages to the buddy, effectively
+ * fake-onlining them.
+ */
+static void virtio_mem_fake_online(unsigned long pfn, unsigned int nr_pages)
+{
+	const int order = MAX_ORDER - 1;
+	int i;
+
+	/*
+	 * We are always called with subblock granularity, which is at least
+	 * aligned to MAX_ORDER - 1.
+	 */
+	virtio_mem_clear_fake_offline(pfn, nr_pages);
+
+	for (i = 0; i &lt; nr_pages; i += 1 &lt;&lt; order)
+		generic_online_page(pfn_to_page(pfn + i), order);
+}
+
+static void virtio_mem_online_page_cb(struct page *page, unsigned int order)
+{
+	const unsigned long addr = page_to_phys(page);
+	const unsigned long mb_id = virtio_mem_phys_to_mb_id(addr);
+	struct virtio_mem *vm;
+	int sb_id;
+
+	/*
+	 * We exploit here that subblocks have at least MAX_ORDER - 1
+	 * size/alignment and that this callback is is called with such a
+	 * size/alignment. So we cannot cross subblocks and therefore
+	 * also not memory blocks.
+	 */
+	rcu_read_lock();
+	list_for_each_entry_rcu(vm, &amp;virtio_mem_devices, next) {
+		if (!virtio_mem_owned_mb(vm, mb_id))
+			continue;
+
+		sb_id = virtio_mem_phys_to_sb_id(vm, addr);
+		/*
+		 * If plugged, online the pages, otherwise, set them fake
+		 * offline (PageOffline).
+		 */
+		if (virtio_mem_mb_test_sb_plugged(vm, mb_id, sb_id, 1))
+			generic_online_page(page, order);
+		else
+			virtio_mem_set_fake_offline(PFN_DOWN(addr), 1 &lt;&lt; order);
+		rcu_read_unlock();
+		return;
+	}
+	rcu_read_unlock();
+
+	/* not virtio-mem memory, but e.g., a DIMM. online it */
+	generic_online_page(page, order);
+}
+
+static uint64_t virtio_mem_send_request(struct virtio_mem *vm,
+					const struct virtio_mem_req *req)
+{
+	struct scatterlist *sgs[2], sg_req, sg_resp;
+	unsigned int len;
+	int rc;
+
+	/* don't use the request residing on the stack (vaddr) */
+	vm-&gt;req = *req;
+
+	/* out: buffer for request */
+	sg_init_one(&amp;sg_req, &amp;vm-&gt;req, sizeof(vm-&gt;req));
+	sgs[0] = &amp;sg_req;
+
+	/* in: buffer for response */
+	sg_init_one(&amp;sg_resp, &amp;vm-&gt;resp, sizeof(vm-&gt;resp));
+	sgs[1] = &amp;sg_resp;
+
+	rc = virtqueue_add_sgs(vm-&gt;vq, sgs, 1, 1, vm, GFP_KERNEL);
+	if (rc &lt; 0)
+		return rc;
+
+	virtqueue_kick(vm-&gt;vq);
+
+	/* wait for a response */
+	wait_event(vm-&gt;host_resp, virtqueue_get_buf(vm-&gt;vq, &amp;len));
+
+	return virtio16_to_cpu(vm-&gt;vdev, vm-&gt;resp.type);
+}
+
+static int virtio_mem_send_plug_request(struct virtio_mem *vm, uint64_t addr,
+					uint64_t size)
+{
+	const uint64_t nb_vm_blocks = size / vm-&gt;device_block_size;
+	const struct virtio_mem_req req = {
+		.type = cpu_to_virtio16(vm-&gt;vdev, VIRTIO_MEM_REQ_PLUG),
+		.u.plug.addr = cpu_to_virtio64(vm-&gt;vdev, addr),
+		.u.plug.nb_blocks = cpu_to_virtio16(vm-&gt;vdev, nb_vm_blocks),
+	};
+
+	if (atomic_read(&amp;vm-&gt;config_changed))
+		return -EAGAIN;
+
+	switch (virtio_mem_send_request(vm, &amp;req)) {
+	case VIRTIO_MEM_RESP_ACK:
+		vm-&gt;plugged_size += size;
+		return 0;
+	case VIRTIO_MEM_RESP_NACK:
+		return -EAGAIN;
+	case VIRTIO_MEM_RESP_BUSY:
+		return -EBUSY;
+	case VIRTIO_MEM_RESP_ERROR:
+		return -EINVAL;
+	default:
+		return -ENOMEM;
+	}
+}
+
+static int virtio_mem_send_unplug_request(struct virtio_mem *vm, uint64_t addr,
+					  uint64_t size)
+{
+	const uint64_t nb_vm_blocks = size / vm-&gt;device_block_size;
+	const struct virtio_mem_req req = {
+		.type = cpu_to_virtio16(vm-&gt;vdev, VIRTIO_MEM_REQ_UNPLUG),
+		.u.unplug.addr = cpu_to_virtio64(vm-&gt;vdev, addr),
+		.u.unplug.nb_blocks = cpu_to_virtio16(vm-&gt;vdev, nb_vm_blocks),
+	};
+
+	if (atomic_read(&amp;vm-&gt;config_changed))
+		return -EAGAIN;
+
+	switch (virtio_mem_send_request(vm, &amp;req)) {
+	case VIRTIO_MEM_RESP_ACK:
+		vm-&gt;plugged_size -= size;
+		return 0;
+	case VIRTIO_MEM_RESP_BUSY:
+		return -EBUSY;
+	case VIRTIO_MEM_RESP_ERROR:
+		return -EINVAL;
+	default:
+		return -ENOMEM;
+	}
+}
+
+static int virtio_mem_send_unplug_all_request(struct virtio_mem *vm)
+{
+	const struct virtio_mem_req req = {
+		.type = cpu_to_virtio16(vm-&gt;vdev, VIRTIO_MEM_REQ_UNPLUG_ALL),
+	};
+
+	switch (virtio_mem_send_request(vm, &amp;req)) {
+	case VIRTIO_MEM_RESP_ACK:
+		vm-&gt;unplug_all_required = false;
+		vm-&gt;plugged_size = 0;
+		/* usable region might have shrunk */
+		atomic_set(&amp;vm-&gt;config_changed, 1);
+		return 0;
+	case VIRTIO_MEM_RESP_BUSY:
+		return -EBUSY;
+	default:
+		return -ENOMEM;
+	}
+}
+
+/*
+ * Plug selected subblocks. Updates the plugged state, but not the state
+ * of the memory block.
+ */
+static int virtio_mem_mb_plug_sb(struct virtio_mem *vm, unsigned long mb_id,
+				 int sb_id, int count)
+{
+	const uint64_t addr = virtio_mem_mb_id_to_phys(mb_id) +
+			      sb_id * vm-&gt;subblock_size;
+	const uint64_t size = count * vm-&gt;subblock_size;
+	int rc;
+
+	dev_dbg(&amp;vm-&gt;vdev-&gt;dev, "plugging memory block: %lu : %i - %i
", mb_id,
+		sb_id, sb_id + count - 1);
+
+	rc = virtio_mem_send_plug_request(vm, addr, size);
+	if (!rc)
+		virtio_mem_mb_set_sb_plugged(vm, mb_id, sb_id, count);
+	return rc;
+}
+
+/*
+ * Unplug selected subblocks. Updates the plugged state, but not the state
+ * of the memory block.
+ */
+static int virtio_mem_mb_unplug_sb(struct virtio_mem *vm, unsigned long mb_id,
+				   int sb_id, int count)
+{
+	const uint64_t addr = virtio_mem_mb_id_to_phys(mb_id) +
+			      sb_id * vm-&gt;subblock_size;
+	const uint64_t size = count * vm-&gt;subblock_size;
+	int rc;
+
+	dev_dbg(&amp;vm-&gt;vdev-&gt;dev, "unplugging memory block: %lu : %i - %i
",
+		mb_id, sb_id, sb_id + count - 1);
+
+	rc = virtio_mem_send_unplug_request(vm, addr, size);
+	if (!rc)
+		virtio_mem_mb_set_sb_unplugged(vm, mb_id, sb_id, count);
+	return rc;
+}
+
+/*
+ * Unplug the desired number of plugged subblocks of a offline or not-added
+ * memory block. Will fail if any subblock cannot get unplugged (instead of
+ * skipping it).
+ *
+ * Will not modify the state of the memory block.
+ *
+ * Note: can fail after some subblocks were unplugged.
+ */
+static int virtio_mem_mb_unplug_any_sb(struct virtio_mem *vm,
+				       unsigned long mb_id, uint64_t *nb_sb)
+{
+	int sb_id, count;
+	int rc;
+
+	while (*nb_sb) {
+		sb_id = virtio_mem_mb_first_plugged_sb(vm, mb_id);
+		if (sb_id &gt;= vm-&gt;nb_sb_per_mb)
+			break;
+		count = 1;
+		while (count &lt; *nb_sb &amp;&amp;
+		       sb_id + count  &lt; vm-&gt;nb_sb_per_mb &amp;&amp;
+		       virtio_mem_mb_test_sb_plugged(vm, mb_id, sb_id + count,
+						     1))
+			count++;
+
+		rc = virtio_mem_mb_unplug_sb(vm, mb_id, sb_id, count);
+		if (rc)
+			return rc;
+		*nb_sb -= count;
+	}
+
+	return 0;
+}
+
+/*
+ * Unplug all plugged subblocks of an offline or not-added memory block.
+ *
+ * Will not modify the state of the memory block.
+ *
+ * Note: can fail after some subblocks were unplugged.
+ */
+static int virtio_mem_mb_unplug(struct virtio_mem *vm, unsigned long mb_id)
+{
+	uint64_t nb_sb = vm-&gt;nb_sb_per_mb;
+
+	return virtio_mem_mb_unplug_any_sb(vm, mb_id, &amp;nb_sb);
+}
+
+/*
+ * Prepare tracking data for the next memory block.
+ */
+static int virtio_mem_prepare_next_mb(struct virtio_mem *vm,
+				      unsigned long *mb_id)
+{
+	int rc;
+
+	if (vm-&gt;next_mb_id &gt; vm-&gt;last_usable_mb_id)
+		return -ENOSPC;
+
+	/* Resize the state array if required. */
+	rc = virtio_mem_mb_state_prepare_next_mb(vm);
+	if (rc)
+		return rc;
+
+	/* Resize the subblock bitmap if required. */
+	rc = virtio_mem_sb_bitmap_prepare_next_mb(vm);
+	if (rc)
+		return rc;
+
+	vm-&gt;nb_mb_state[VIRTIO_MEM_MB_STATE_UNUSED]++;
+	*mb_id = vm-&gt;next_mb_id++;
+	return 0;
+}
+
+/*
+ * Don't add too many blocks that are not onlined yet to avoid running OOM.
+ */
+static bool virtio_mem_too_many_mb_offline(struct virtio_mem *vm)
+{
+	unsigned long nb_offline;
+
+	nb_offline = vm-&gt;nb_mb_state[VIRTIO_MEM_MB_STATE_OFFLINE] +
+		     vm-&gt;nb_mb_state[VIRTIO_MEM_MB_STATE_OFFLINE_PARTIAL];
+	return nb_offline &gt;= VIRTIO_MEM_NB_OFFLINE_THRESHOLD;
+}
+
+/*
+ * Try to plug the desired number of subblocks and add the memory block
+ * to Linux.
+ *
+ * Will modify the state of the memory block.
+ */
+static int virtio_mem_mb_plug_and_add(struct virtio_mem *vm,
+				      unsigned long mb_id,
+				      uint64_t *nb_sb)
+{
+	const int count = min_t(int, *nb_sb, vm-&gt;nb_sb_per_mb);
+	int rc, rc2;
+
+	if (WARN_ON_ONCE(!count))
+		return -EINVAL;
+
+	/*
+	 * Plug the requested number of subblocks before adding it to linux,
+	 * so that onlining will directly online all plugged subblocks.
+	 */
+	rc = virtio_mem_mb_plug_sb(vm, mb_id, 0, count);
+	if (rc)
+		return rc;
+
+	/*
+	 * Mark the block properly offline before adding it to Linux,
+	 * so the memory notifiers will find the block in the right state.
+	 */
+	if (count == vm-&gt;nb_sb_per_mb)
+		virtio_mem_mb_set_state(vm, mb_id,
+					VIRTIO_MEM_MB_STATE_OFFLINE);
+	else
+		virtio_mem_mb_set_state(vm, mb_id,
+					VIRTIO_MEM_MB_STATE_OFFLINE_PARTIAL);
+
+	/* Add the memory block to linux - if that fails, try to unplug. */
+	rc = virtio_mem_mb_add(vm, mb_id);
+	if (rc) {
+		enum virtio_mem_mb_state new_state = VIRTIO_MEM_MB_STATE_UNUSED;
+
+		dev_err(&amp;vm-&gt;vdev-&gt;dev,
+			"adding memory block %lu failed with %d
", mb_id, rc);
+		rc2 = virtio_mem_mb_unplug_sb(vm, mb_id, 0, count);
+
+		/*
+		 * TODO: Linux MM does not properly clean up yet in all cases
+		 * where adding of memory failed - especially on -ENOMEM.
+		 */
+		if (rc2)
+			new_state = VIRTIO_MEM_MB_STATE_PLUGGED;
+		virtio_mem_mb_set_state(vm, mb_id, new_state);
+		return rc;
+	}
+
+	*nb_sb -= count;
+	return 0;
+}
+
+/*
+ * Try to plug the desired number of subblocks of a memory block that
+ * is already added to Linux.
+ *
+ * Will modify the state of the memory block.
+ *
+ * Note: Can fail after some subblocks were successfully plugged.
+ */
+static int virtio_mem_mb_plug_any_sb(struct virtio_mem *vm, unsigned long mb_id,
+				     uint64_t *nb_sb, bool online)
+{
+	unsigned long pfn, nr_pages;
+	int sb_id, count;
+	int rc;
+
+	if (WARN_ON_ONCE(!*nb_sb))
+		return -EINVAL;
+
+	while (*nb_sb) {
+		sb_id = virtio_mem_mb_first_unplugged_sb(vm, mb_id);
+		if (sb_id &gt;= vm-&gt;nb_sb_per_mb)
+			break;
+		count = 1;
+		while (count &lt; *nb_sb &amp;&amp;
+		       sb_id + count &lt; vm-&gt;nb_sb_per_mb &amp;&amp;
+		       !virtio_mem_mb_test_sb_plugged(vm, mb_id, sb_id + count,
+						      1))
+			count++;
+
+		rc = virtio_mem_mb_plug_sb(vm, mb_id, sb_id, count);
+		if (rc)
+			return rc;
+		*nb_sb -= count;
+		if (!online)
+			continue;
+
+		/* fake-online the pages if the memory block is online */
+		pfn = PFN_DOWN(virtio_mem_mb_id_to_phys(mb_id) +
+			       sb_id * vm-&gt;subblock_size);
+		nr_pages = PFN_DOWN(count * vm-&gt;subblock_size);
+		virtio_mem_fake_online(pfn, nr_pages);
+	}
+
+	if (virtio_mem_mb_test_sb_plugged(vm, mb_id, 0, vm-&gt;nb_sb_per_mb)) {
+		if (online)
+			virtio_mem_mb_set_state(vm, mb_id,
+						VIRTIO_MEM_MB_STATE_ONLINE);
+		else
+			virtio_mem_mb_set_state(vm, mb_id,
+						VIRTIO_MEM_MB_STATE_OFFLINE);
+	}
+
+	return rc;
+}
+
+/*
+ * Try to plug the requested amount of memory.
+ */
+static int virtio_mem_plug_request(struct virtio_mem *vm, uint64_t diff)
+{
+	uint64_t nb_sb = diff / vm-&gt;subblock_size;
+	unsigned long mb_id;
+	int rc;
+
+	if (!nb_sb)
+		return 0;
+
+	/* Don't race with onlining/offlining */
+	mutex_lock(&amp;vm-&gt;hotplug_mutex);
+
+	/* Try to plug subblocks of partially plugged online blocks. */
+	virtio_mem_for_each_mb_state(vm, mb_id,
+				     VIRTIO_MEM_MB_STATE_ONLINE_PARTIAL) {
+		rc = virtio_mem_mb_plug_any_sb(vm, mb_id, &amp;nb_sb, true);
+		if (rc || !nb_sb)
+			goto out_unlock;
+		cond_resched();
+	}
+
+	/* Try to plug subblocks of partially plugged offline blocks. */
+	virtio_mem_for_each_mb_state(vm, mb_id,
+				     VIRTIO_MEM_MB_STATE_OFFLINE_PARTIAL) {
+		rc = virtio_mem_mb_plug_any_sb(vm, mb_id, &amp;nb_sb, false);
+		if (rc || !nb_sb)
+			goto out_unlock;
+		cond_resched();
+	}
+
+	/*
+	 * We won't be working on online/offline memory blocks from this point,
+	 * so we can't race with memory onlining/offlining. Drop the mutex.
+	 */
+	mutex_unlock(&amp;vm-&gt;hotplug_mutex);
+
+	/* Try to plug and add unused blocks */
+	virtio_mem_for_each_mb_state(vm, mb_id, VIRTIO_MEM_MB_STATE_UNUSED) {
+		if (virtio_mem_too_many_mb_offline(vm))
+			return -ENOSPC;
+
+		rc = virtio_mem_mb_plug_and_add(vm, mb_id, &amp;nb_sb);
+		if (rc || !nb_sb)
+			return rc;
+		cond_resched();
+	}
+
+	/* Try to prepare, plug and add new blocks */
+	while (nb_sb) {
+		if (virtio_mem_too_many_mb_offline(vm))
+			return -ENOSPC;
+
+		rc = virtio_mem_prepare_next_mb(vm, &amp;mb_id);
+		if (rc)
+			return rc;
+		rc = virtio_mem_mb_plug_and_add(vm, mb_id, &amp;nb_sb);
+		if (rc)
+			return rc;
+		cond_resched();
+	}
+
+	return 0;
+out_unlock:
+	mutex_unlock(&amp;vm-&gt;hotplug_mutex);
+	return rc;
+}
+
+/*
+ * Try to unplug all blocks that couldn't be unplugged before, for example,
+ * because the hypervisor was busy.
+ */
+static int virtio_mem_unplug_pending_mb(struct virtio_mem *vm)
+{
+	unsigned long mb_id;
+	int rc;
+
+	virtio_mem_for_each_mb_state(vm, mb_id, VIRTIO_MEM_MB_STATE_PLUGGED) {
+		rc = virtio_mem_mb_unplug(vm, mb_id);
+		if (rc)
+			return rc;
+		virtio_mem_mb_set_state(vm, mb_id, VIRTIO_MEM_MB_STATE_UNUSED);
+	}
+
+	return 0;
+}
+
+/*
+ * Update all parts of the config that could have changed.
+ */
+static void virtio_mem_refresh_config(struct virtio_mem *vm)
+{
+	const uint64_t phys_limit = 1UL &lt;&lt; MAX_PHYSMEM_BITS;
+	uint64_t new_plugged_size, usable_region_size, end_addr;
+
+	/* the plugged_size is just a reflection of what _we_ did previously */
+	virtio_cread(vm-&gt;vdev, struct virtio_mem_config, plugged_size,
+		     &amp;new_plugged_size);
+	if (WARN_ON_ONCE(new_plugged_size != vm-&gt;plugged_size))
+		vm-&gt;plugged_size = new_plugged_size;
+
+	/* calculate the last usable memory block id */
+	virtio_cread(vm-&gt;vdev, struct virtio_mem_config,
+		     usable_region_size, &amp;usable_region_size);
+	end_addr = vm-&gt;addr + usable_region_size;
+	end_addr = min(end_addr, phys_limit);
+	vm-&gt;last_usable_mb_id = virtio_mem_phys_to_mb_id(end_addr) - 1;
+
+	/* see if there is a request to change the size */
+	virtio_cread(vm-&gt;vdev, struct virtio_mem_config, requested_size,
+		     &amp;vm-&gt;requested_size);
+
+	dev_info(&amp;vm-&gt;vdev-&gt;dev, "plugged size: 0x%llx", vm-&gt;plugged_size);
+	dev_info(&amp;vm-&gt;vdev-&gt;dev, "requested size: 0x%llx", vm-&gt;requested_size);
+}
+
+/*
+ * Workqueue function for handling plug/unplug requests and config updates.
+ */
+static void virtio_mem_run_wq(struct work_struct *work)
+{
+	struct virtio_mem *vm = container_of(work, struct virtio_mem, wq);
+	uint64_t diff;
+	int rc;
+
+	hrtimer_cancel(&amp;vm-&gt;retry_timer);
+
+	if (vm-&gt;broken)
+		return;
+
+retry:
+	rc = 0;
+
+	/* Make sure we start with a clean state if there are leftovers. */
+	if (unlikely(vm-&gt;unplug_all_required))
+		rc = virtio_mem_send_unplug_all_request(vm);
+
+	if (atomic_read(&amp;vm-&gt;config_changed)) {
+		atomic_set(&amp;vm-&gt;config_changed, 0);
+		virtio_mem_refresh_config(vm);
+	}
+
+	/* Unplug any leftovers from previous runs */
+	if (!rc)
+		rc = virtio_mem_unplug_pending_mb(vm);
+
+	if (!rc &amp;&amp; vm-&gt;requested_size != vm-&gt;plugged_size) {
+		if (vm-&gt;requested_size &gt; vm-&gt;plugged_size) {
+			diff = vm-&gt;requested_size - vm-&gt;plugged_size;
+			rc = virtio_mem_plug_request(vm, diff);
+		}
+		/* TODO: try to unplug memory */
+	}
+
+	switch (rc) {
+	case 0:
+		break;
+	case -ENOSPC:
+		/*
+		 * We cannot add any more memory (alignment, physical limit)
+		 * or we have too many offline memory blocks.
+		 */
+		break;
+	case -EBUSY:
+		/*
+		 * The hypervisor cannot process our request right now
+		 * (e.g., out of memory, migrating).
+		 */
+	case -ENOMEM:
+		/* Out of memory, try again later. */
+		hrtimer_start(&amp;vm-&gt;retry_timer,
+			      ms_to_ktime(VIRTIO_MEM_RETRY_TIMER_MS),
+			      HRTIMER_MODE_REL);
+		break;
+	case -EAGAIN:
+		/* Retry immediately (e.g., the config changed). */
+		goto retry;
+	default:
+		/* Unknown error, mark as broken */
+		dev_err(&amp;vm-&gt;vdev-&gt;dev,
+			"unknown error, marking device broken: %d
", rc);
+		vm-&gt;broken = true;
+	}
+}
+
+static enum hrtimer_restart virtio_mem_timer_expired(struct hrtimer *timer)
+{
+	struct virtio_mem *vm = container_of(timer, struct virtio_mem,
+					     retry_timer);
+
+	virtio_mem_retry(vm);
+	return HRTIMER_NORESTART;
+}
+
+static void virtio_mem_handle_response(struct virtqueue *vq)
+{
+	struct virtio_mem *vm = vq-&gt;vdev-&gt;priv;
+
+	wake_up(&amp;vm-&gt;host_resp);
+}
+
+static int virtio_mem_init_vq(struct virtio_mem *vm)
+{
+	struct virtqueue *vq;
+
+	vq = virtio_find_single_vq(vm-&gt;vdev, virtio_mem_handle_response,
+				   "guest-request");
+	if (IS_ERR(vq))
+		return PTR_ERR(vq);
+	vm-&gt;vq = vq;
+
+	return 0;
+}
+
+/*
+ * Test if any memory in the range is present in Linux.
+ */
+static bool virtio_mem_any_memory_present(unsigned long start,
+					  unsigned long size)
+{
+	const unsigned long start_pfn = PFN_DOWN(start);
+	const unsigned long end_pfn = PFN_UP(start + size);
+	unsigned long pfn;
+
+	for (pfn = start_pfn; pfn != end_pfn; pfn++)
+		if (present_section_nr(pfn_to_section_nr(pfn)))
+			return true;
+
+	return false;
+}
+
+static int virtio_mem_init(struct virtio_mem *vm)
+{
+	const uint64_t phys_limit = 1UL &lt;&lt; MAX_PHYSMEM_BITS;
+
+	if (!vm-&gt;vdev-&gt;config-&gt;get) {
+		dev_err(&amp;vm-&gt;vdev-&gt;dev, "config access disabled
");
+		return -EINVAL;
+	}
+
+	/*
+	 * We don't want to (un)plug or reuse any memory when in kdump. The
+	 * memory is still accessible (but not mapped).
+	 */
+	if (is_kdump_kernel()) {
+		dev_warn(&amp;vm-&gt;vdev-&gt;dev, "disabled in kdump kernel
");
+		return -EBUSY;
+	}
+
+	/* Fetch all properties that can't change. */
+	virtio_cread(vm-&gt;vdev, struct virtio_mem_config, plugged_size,
+		     &amp;vm-&gt;plugged_size);
+	virtio_cread(vm-&gt;vdev, struct virtio_mem_config, block_size,
+		     &amp;vm-&gt;device_block_size);
+	virtio_cread(vm-&gt;vdev, struct virtio_mem_config, addr, &amp;vm-&gt;addr);
+	virtio_cread(vm-&gt;vdev, struct virtio_mem_config, region_size,
+		     &amp;vm-&gt;region_size);
+
+	/*
+	 * If we still have memory plugged, we might have to unplug all
+	 * memory first. However, if somebody simply unloaded the driver
+	 * we would have to reinitialize the old state - something we don't
+	 * support yet. Detect if we have any memory in the area present.
+	 */
+	if (vm-&gt;plugged_size) {
+		uint64_t usable_region_size;
+
+		virtio_cread(vm-&gt;vdev, struct virtio_mem_config,
+			     usable_region_size, &amp;usable_region_size);
+
+		if (virtio_mem_any_memory_present(vm-&gt;addr,
+						  usable_region_size)) {
+			dev_err(&amp;vm-&gt;vdev-&gt;dev,
+				"reloading the driver is not supported
");
+			return -EINVAL;
+		}
+		/*
+		 * Note: it might happen that the device is busy and
+		 * unplugging all memory might take some time.
+		 */
+		dev_info(&amp;vm-&gt;vdev-&gt;dev, "unplugging all memory required
");
+		vm-&gt;unplug_all_required = 1;
+	}
+
+	/*
+	 * We always hotplug memory in memory block granularity. This way,
+	 * we have to wait for exactly one memory block to online.
+	 */
+	if (vm-&gt;device_block_size &gt; memory_block_size_bytes()) {
+		dev_err(&amp;vm-&gt;vdev-&gt;dev,
+			"The block size is not supported (too big).
");
+		return -EINVAL;
+	}
+
+	/* bad device setup - warn only */
+	if (!IS_ALIGNED(vm-&gt;addr, memory_block_size_bytes()))
+		dev_warn(&amp;vm-&gt;vdev-&gt;dev,
+			 "The alignment of the physical start address can make some memory unusable.
");
+	if (!IS_ALIGNED(vm-&gt;addr + vm-&gt;region_size, memory_block_size_bytes()))
+		dev_warn(&amp;vm-&gt;vdev-&gt;dev,
+			 "The alignment of the physical end address can make some memory unusable.
");
+	if (vm-&gt;addr + vm-&gt;region_size &gt; phys_limit)
+		dev_warn(&amp;vm-&gt;vdev-&gt;dev,
+			 "Some memory is not addressable. This can make some memory unusable.
");
+
+	/*
+	 * Calculate the subblock size:
+	 * - At least MAX_ORDER - 1 / pageblock_order.
+	 * - At least the device block size.
+	 * In the worst case, a single subblock per memory block.
+	 */
+	vm-&gt;subblock_size = PAGE_SIZE * 1u &lt;&lt; max_t(uint32_t, MAX_ORDER - 1,
+						    pageblock_order);
+	vm-&gt;subblock_size = max_t(uint32_t, vm-&gt;device_block_size,
+				  vm-&gt;subblock_size);
+	vm-&gt;nb_sb_per_mb = memory_block_size_bytes() / vm-&gt;subblock_size;
+
+	/* Round up to the next full memory block */
+	vm-&gt;first_mb_id = virtio_mem_phys_to_mb_id(vm-&gt;addr - 1 +
+						   memory_block_size_bytes());
+	vm-&gt;next_mb_id = vm-&gt;first_mb_id;
+	vm-&gt;last_mb_id = virtio_mem_phys_to_mb_id(vm-&gt;addr +
+			 vm-&gt;region_size) - 1;
+
+	dev_info(&amp;vm-&gt;vdev-&gt;dev, "start address: 0x%llx", vm-&gt;addr);
+	dev_info(&amp;vm-&gt;vdev-&gt;dev, "region size: 0x%llx", vm-&gt;region_size);
+	dev_info(&amp;vm-&gt;vdev-&gt;dev, "device block size: 0x%x",
+		 vm-&gt;device_block_size);
+	dev_info(&amp;vm-&gt;vdev-&gt;dev, "memory block size: 0x%lx",
+		 memory_block_size_bytes());
+	dev_info(&amp;vm-&gt;vdev-&gt;dev, "subblock size: 0x%x",
+		 vm-&gt;subblock_size);
+
+	return 0;
+}
+
+static int virtio_mem_probe(struct virtio_device *vdev)
+{
+	struct virtio_mem *vm;
+	int rc = -EINVAL;
+
+	vdev-&gt;priv = vm = kzalloc(sizeof(*vm), GFP_KERNEL);
+	if (!vm)
+		return -ENOMEM;
+
+	init_waitqueue_head(&amp;vm-&gt;host_resp);
+	vm-&gt;vdev = vdev;
+	INIT_WORK(&amp;vm-&gt;wq, virtio_mem_run_wq);
+	mutex_init(&amp;vm-&gt;hotplug_mutex);
+	INIT_LIST_HEAD(&amp;vm-&gt;next);
+	spin_lock_init(&amp;vm-&gt;removal_lock);
+	hrtimer_init(&amp;vm-&gt;retry_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	vm-&gt;retry_timer.function = virtio_mem_timer_expired;
+
+	/* register the virtqueue */
+	rc = virtio_mem_init_vq(vm);
+	if (rc)
+		goto out_free_vm;
+
+	/* initialize the device by querying the config */
+	rc = virtio_mem_init(vm);
+	if (rc)
+		goto out_del_vq;
+
+	/* register callbacks */
+	vm-&gt;memory_notifier.notifier_call = virtio_mem_memory_notifier_cb;
+	rc = register_memory_notifier(&amp;vm-&gt;memory_notifier);
+	if (rc)
+		goto out_del_vq;
+	rc = register_virtio_mem_device(vm);
+	if (rc)
+		goto out_unreg_mem;
+
+	virtio_device_ready(vdev);
+
+	/* trigger a config update to start processing the requested_size */
+	atomic_set(&amp;vm-&gt;config_changed, 1);
+	queue_work(system_freezable_wq, &amp;vm-&gt;wq);
+
+	return 0;
+out_unreg_mem:
+	unregister_memory_notifier(&amp;vm-&gt;memory_notifier);
+out_del_vq:
+	vdev-&gt;config-&gt;del_vqs(vdev);
+out_free_vm:
+	kfree(vm);
+	vdev-&gt;priv = NULL;
+
+	return rc;
+}
+
+static void virtio_mem_remove(struct virtio_device *vdev)
+{
+	struct virtio_mem *vm = vdev-&gt;priv;
+	unsigned long mb_id;
+	int rc;
+
+	/*
+	 * Make sure the workqueue won't be triggered anymore and no memory
+	 * blocks can be onlined/offlined until we're finished here.
+	 */
+	mutex_lock(&amp;vm-&gt;hotplug_mutex);
+	spin_lock_irq(&amp;vm-&gt;removal_lock);
+	vm-&gt;removing = true;
+	spin_unlock_irq(&amp;vm-&gt;removal_lock);
+	mutex_unlock(&amp;vm-&gt;hotplug_mutex);
+
+	/* wait until the workqueue stopped */
+	cancel_work_sync(&amp;vm-&gt;wq);
+	hrtimer_cancel(&amp;vm-&gt;retry_timer);
+
+	/*
+	 * After we unregistered our callbacks, user space can online partially
+	 * plugged offline blocks. Make sure to remove them.
+	 */
+	virtio_mem_for_each_mb_state(vm, mb_id,
+				     VIRTIO_MEM_MB_STATE_OFFLINE_PARTIAL) {
+		rc = virtio_mem_mb_remove(vm, mb_id);
+		BUG_ON(rc);
+		virtio_mem_mb_set_state(vm, mb_id, VIRTIO_MEM_MB_STATE_UNUSED);
+	}
+
+	/* unregister callbacks */
+	unregister_virtio_mem_device(vm);
+	unregister_memory_notifier(&amp;vm-&gt;memory_notifier);
+
+	/*
+	 * There is no way we could reliably remove all memory we have added to
+	 * the system. And there is no way to stop the driver/device from going
+	 * away. Warn at least.
+	 */
+	if (vm-&gt;nb_mb_state[VIRTIO_MEM_MB_STATE_OFFLINE] ||
+	    vm-&gt;nb_mb_state[VIRTIO_MEM_MB_STATE_OFFLINE_PARTIAL] ||
+	    vm-&gt;nb_mb_state[VIRTIO_MEM_MB_STATE_ONLINE] ||
+	    vm-&gt;nb_mb_state[VIRTIO_MEM_MB_STATE_ONLINE_PARTIAL] ||
+	    vm-&gt;nb_mb_state[VIRTIO_MEM_MB_STATE_ONLINE_MOVABLE])
+		dev_warn(&amp;vdev-&gt;dev, "device still has system memory added
");
+
+	/* remove all tracking data - no locking needed */
+	vfree(vm-&gt;mb_state);
+	vfree(vm-&gt;sb_bitmap);
+
+	/* reset the device and cleanup the queues */
+	vdev-&gt;config-&gt;reset(vdev);
+	vdev-&gt;config-&gt;del_vqs(vdev);
+
+	kfree(vm);
+	vdev-&gt;priv = NULL;
+}
+
+static void virtio_mem_config_changed(struct virtio_device *vdev)
+{
+	struct virtio_mem *vm = vdev-&gt;priv;
+
+	atomic_set(&amp;vm-&gt;config_changed, 1);
+	virtio_mem_retry(vm);
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int virtio_mem_freeze(struct virtio_device *vdev)
+{
+	/*
+	 * When restarting the VM, all memory is usually unplugged. Don't
+	 * allow to suspend/hibernate.
+	 */
+	dev_err(&amp;vdev-&gt;dev, "save/restore not supported.
");
+	return -EPERM;
+}
+
+static int virtio_mem_restore(struct virtio_device *vdev)
+{
+	return -EPERM;
+}
+#endif
+
+static struct virtio_device_id virtio_mem_id_table[] = {
+	{ VIRTIO_ID_MEM, VIRTIO_DEV_ANY_ID },
+	{ 0 },
+};
+
+static struct virtio_driver virtio_mem_driver = {
+	.driver.name = KBUILD_MODNAME,
+	.driver.owner = THIS_MODULE,
+	.id_table = virtio_mem_id_table,
+	.probe = virtio_mem_probe,
+	.remove = virtio_mem_remove,
+	.config_changed = virtio_mem_config_changed,
+#ifdef CONFIG_PM_SLEEP
+	.freeze	=	virtio_mem_freeze,
+	.restore =	virtio_mem_restore,
+#endif
+};
+
+module_virtio_driver(virtio_mem_driver);
+MODULE_DEVICE_TABLE(virtio, virtio_mem_id_table);
+MODULE_AUTHOR("David Hildenbrand &lt;david@redhat.com&gt;");
+MODULE_DESCRIPTION("Virtio-mem driver");
+MODULE_LICENSE("GPL");
</span><span class="head"><a href="#iZ2e.:20200507140139.17083-2-david::40redhat.com:1include:uapi:linux:virtio_ids.h" id="Z2e.:20200507140139.17083-2-david::40redhat.com:1include:uapi:linux:virtio_ids.h">diff</a> --git a/include/uapi/linux/virtio_ids.h b/include/uapi/linux/virtio_ids.h
index ecc27a17401a..b052355ac7a3 100644
--- a/include/uapi/linux/virtio_ids.h
+++ b/include/uapi/linux/virtio_ids.h
</span><span class="hunk">@@ -44,6 +44,7 @@
</span> #define VIRTIO_ID_VSOCK        19 /* virtio vsock transport */
 #define VIRTIO_ID_CRYPTO       20 /* virtio crypto */
 #define VIRTIO_ID_IOMMU        23 /* virtio IOMMU */
<span class="add">+#define VIRTIO_ID_MEM          24 /* virtio mem */
</span> #define VIRTIO_ID_FS           26 /* virtio filesystem */
 #define VIRTIO_ID_PMEM         27 /* virtio pmem */
 #define VIRTIO_ID_MAC80211_HWSIM 29 /* virtio mac80211-hwsim */
<span class="head"><a href="#iZ2e.:20200507140139.17083-2-david::40redhat.com:1include:uapi:linux:virtio_mem.h" id="Z2e.:20200507140139.17083-2-david::40redhat.com:1include:uapi:linux:virtio_mem.h">diff</a> --git a/include/uapi/linux/virtio_mem.h b/include/uapi/linux/virtio_mem.h
new file mode 100644
index 000000000000..1bfade78bdfd
--- /dev/null
+++ b/include/uapi/linux/virtio_mem.h
</span><span class="hunk">@@ -0,0 +1,200 @@
</span><span class="add">+/* SPDX-License-Identifier: BSD-3-Clause */
+/*
+ * Virtio Mem Device
+ *
+ * Copyright Red Hat, Inc. 2020
+ *
+ * Authors:
+ *     David Hildenbrand &lt;david@redhat.com&gt;
+ *
+ * This header is BSD licensed so anyone can use the definitions
+ * to implement compatible drivers/servers:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of IBM nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL IBM OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef _LINUX_VIRTIO_MEM_H
+#define _LINUX_VIRTIO_MEM_H
+
+#include &lt;linux/types.h&gt;
+#include &lt;linux/virtio_types.h&gt;
+#include &lt;linux/virtio_ids.h&gt;
+#include &lt;linux/virtio_config.h&gt;
+
+/*
+ * Each virtio-mem device manages a dedicated region in physical address
+ * space. Each device can belong to a single NUMA node, multiple devices
+ * for a single NUMA node are possible. A virtio-mem device is like a
+ * "resizable DIMM" consisting of small memory blocks that can be plugged
+ * or unplugged. The device driver is responsible for (un)plugging memory
+ * blocks on demand.
+ *
+ * Virtio-mem devices can only operate on their assigned memory region in
+ * order to (un)plug memory. A device cannot (un)plug memory belonging to
+ * other devices.
+ *
+ * The "region_size" corresponds to the maximum amount of memory that can
+ * be provided by a device. The "size" corresponds to the amount of memory
+ * that is currently plugged. "requested_size" corresponds to a request
+ * from the device to the device driver to (un)plug blocks. The
+ * device driver should try to (un)plug blocks in order to reach the
+ * "requested_size". It is impossible to plug more memory than requested.
+ *
+ * The "usable_region_size" represents the memory region that can actually
+ * be used to (un)plug memory. It is always at least as big as the
+ * "requested_size" and will grow dynamically. It will only shrink when
+ * explicitly triggered (VIRTIO_MEM_REQ_UNPLUG).
+ *
+ * There are no guarantees what will happen if unplugged memory is
+ * read/written. Such memory should, in general, not be touched. E.g.,
+ * even writing might succeed, but the values will simply be discarded at
+ * random points in time.
+ *
+ * It can happen that the device cannot process a request, because it is
+ * busy. The device driver has to retry later.
+ *
+ * Usually, during system resets all memory will get unplugged, so the
+ * device driver can start with a clean state. However, in specific
+ * scenarios (if the device is busy) it can happen that the device still
+ * has memory plugged. The device driver can request to unplug all memory
+ * (VIRTIO_MEM_REQ_UNPLUG) - which might take a while to succeed if the
+ * device is busy.
+ */
+
+/* --- virtio-mem: guest -&gt; host requests --- */
+
+/* request to plug memory blocks */
+#define VIRTIO_MEM_REQ_PLUG			0
+/* request to unplug memory blocks */
+#define VIRTIO_MEM_REQ_UNPLUG			1
+/* request to unplug all blocks and shrink the usable size */
+#define VIRTIO_MEM_REQ_UNPLUG_ALL		2
+/* request information about the plugged state of memory blocks */
+#define VIRTIO_MEM_REQ_STATE			3
+
+struct virtio_mem_req_plug {
+	__virtio64 addr;
+	__virtio16 nb_blocks;
+};
+
+struct virtio_mem_req_unplug {
+	__virtio64 addr;
+	__virtio16 nb_blocks;
+};
+
+struct virtio_mem_req_state {
+	__virtio64 addr;
+	__virtio16 nb_blocks;
+};
+
+struct virtio_mem_req {
+	__virtio16 type;
+	__virtio16 padding[3];
+
+	union {
+		struct virtio_mem_req_plug plug;
+		struct virtio_mem_req_unplug unplug;
+		struct virtio_mem_req_state state;
+	} u;
+};
+
+
+/* --- virtio-mem: host -&gt; guest response --- */
+
+/*
+ * Request processed successfully, applicable for
+ * - VIRTIO_MEM_REQ_PLUG
+ * - VIRTIO_MEM_REQ_UNPLUG
+ * - VIRTIO_MEM_REQ_UNPLUG_ALL
+ * - VIRTIO_MEM_REQ_STATE
+ */
+#define VIRTIO_MEM_RESP_ACK			0
+/*
+ * Request denied - e.g. trying to plug more than requested, applicable for
+ * - VIRTIO_MEM_REQ_PLUG
+ */
+#define VIRTIO_MEM_RESP_NACK			1
+/*
+ * Request cannot be processed right now, try again later, applicable for
+ * - VIRTIO_MEM_REQ_PLUG
+ * - VIRTIO_MEM_REQ_UNPLUG
+ * - VIRTIO_MEM_REQ_UNPLUG_ALL
+ */
+#define VIRTIO_MEM_RESP_BUSY			2
+/*
+ * Error in request (e.g. addresses/alignment), applicable for
+ * - VIRTIO_MEM_REQ_PLUG
+ * - VIRTIO_MEM_REQ_UNPLUG
+ * - VIRTIO_MEM_REQ_STATE
+ */
+#define VIRTIO_MEM_RESP_ERROR			3
+
+
+/* State of memory blocks is "plugged" */
+#define VIRTIO_MEM_STATE_PLUGGED		0
+/* State of memory blocks is "unplugged" */
+#define VIRTIO_MEM_STATE_UNPLUGGED		1
+/* State of memory blocks is "mixed" */
+#define VIRTIO_MEM_STATE_MIXED			2
+
+struct virtio_mem_resp_state {
+	__virtio16 state;
+};
+
+struct virtio_mem_resp {
+	__virtio16 type;
+	__virtio16 padding[3];
+
+	union {
+		struct virtio_mem_resp_state state;
+	} u;
+};
+
+/* --- virtio-mem: configuration --- */
+
+struct virtio_mem_config {
+	/* Block size and alignment. Cannot change. */
+	__u32 block_size;
+	__u32 padding;
+	/* Start address of the memory region. Cannot change. */
+	__u64 addr;
+	/* Region size (maximum). Cannot change. */
+	__u64 region_size;
+	/*
+	 * Currently usable region size. Can grow up to region_size. Can
+	 * shrink due to VIRTIO_MEM_REQ_UNPLUG_ALL (in which case no config
+	 * update will be sent).
+	 */
+	__u64 usable_region_size;
+	/*
+	 * Currently used size. Changes due to plug/unplug requests, but no
+	 * config updates will be sent.
+	 */
+	__u64 plugged_size;
+	/* Requested size. New plug requests cannot exceed it. Can change. */
+	__u64 requested_size;
+};
+
+#endif /* _LINUX_VIRTIO_MEM_H */
</span>-- 
2.25.3


---------------------------------------------------------------------
To unsubscribe, e-mail: virtio-dev-unsubscribe@lists.oasis-open.org
For additional commands, e-mail: virtio-dev-help@lists.oasis-open.org

</pre><hr><pre>WARNING: multiple messages have this Message-ID (<a href="d/">diff</a>)</pre><pre>From: David Hildenbrand &lt;david@redhat.com&gt;
To: <a href="../../lkml/?t=20200507140239">linux-kernel@vger.kernel.org</a>
Cc: <a href="../../linux-mm/?t=20200507140239">linux-mm@kvack.org</a>, virtio-dev@lists.oasis-open.org,
	<a href="../../virtualization/?t=20200507140239">virtualization@lists.linux-foundation.org</a>, <a href="../../kvm/?t=20200507140239">kvm@vger.kernel.org</a>,
	Michal Hocko &lt;mhocko@kernel.org&gt;,
	Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	"Michael S . Tsirkin" &lt;mst@redhat.com&gt;,
	David Hildenbrand &lt;david@redhat.com&gt;,
	Pankaj Gupta &lt;pankaj.gupta.linux@gmail.com&gt;,
	Jason Wang &lt;jasowang@redhat.com&gt;,
	Oscar Salvador &lt;osalvador@suse.de&gt;,
	Igor Mammedov &lt;imammedo@redhat.com&gt;,
	Dave Young &lt;dyoung@redhat.com&gt;,
	Dan Williams &lt;dan.j.williams@intel.com&gt;,
	Pavel Tatashin &lt;pasha.tatashin@soleen.com&gt;,
	Stefan Hajnoczi &lt;stefanha@redhat.com&gt;,
	Vlastimil Babka &lt;vbabka@suse.cz&gt;,
	"Rafael J. Wysocki" &lt;rjw@rjwysocki.net&gt;,
	Len Brown &lt;lenb@kernel.org&gt;,
	<a href="../../linux-acpi/?t=20200507140239">linux-acpi@vger.kernel.org</a>
Subject: <a href="#r" id="t">[PATCH v4 01/15] virtio-mem: Paravirtualized memory hotplug</a>
Date: Thu,  7 May 2020 16:01:25 +0200	<a href="#r">[thread overview]</a>
Message-ID: &lt;20200507140139.17083-2-david@redhat.com&gt; (<a href="raw">raw</a>)
In-Reply-To: &lt;<a href="../20200507140139.17083-1-david@redhat.com/">20200507140139.17083-1-david@redhat.com</a>&gt;

Each virtio-mem device owns exactly one memory region. It is responsible
for adding/removing memory from that memory region on request.

When the device driver starts up, the requested amount of memory is
queried and then plugged to Linux. On request, further memory can be
plugged or unplugged. This patch only implements the plugging part.

On x86-64, memory can currently be plugged in 4MB ("subblock") granularity.
When required, a new memory block will be added (e.g., usually 128MB on
x86-64) in order to plug more subblocks. Only x86-64 was tested for now.

The online_page callback is used to keep unplugged subblocks offline
when onlining memory - similar to the Hyper-V balloon driver. Unplugged
pages are marked PG_offline, to tell dump tools (e.g., makedumpfile) to
skip them.

User space is usually responsible for onlining the added memory. The
memory hotplug notifier is used to synchronize virtio-mem activity
against memory onlining/offlining.

Each virtio-mem device can belong to a NUMA node, which allows us to
easily add/remove small chunks of memory to/from a specific NUMA node by
using multiple virtio-mem devices. Something that works even when the
guest has no idea about the NUMA topology.

One way to view virtio-mem is as a "resizable DIMM" or a DIMM with many
"sub-DIMMS".

This patch directly introduces the basic infrastructure to implement memory
unplug. Especially the memory block states and subblock bitmaps will be
heavily used there.

Notes:
- In case memory is to be onlined by user space, we limit the amount of
  offline memory blocks, to not run out of memory. This is esp. an
  issue if memory is added faster than it is getting onlined.
- Suspend/Hibernate is not supported due to the way virtio-mem devices
  behave. Limited support might be possible in the future.
- Reloading the device driver is not supported.

Reviewed-by: Pankaj Gupta &lt;pankaj.gupta.linux@gmail.com&gt;
Tested-by: Pankaj Gupta &lt;pankaj.gupta.linux@gmail.com&gt;
Cc: "Michael S. Tsirkin" &lt;mst@redhat.com&gt;
Cc: Jason Wang &lt;jasowang@redhat.com&gt;
Cc: Oscar Salvador &lt;osalvador@suse.de&gt;
Cc: Michal Hocko &lt;mhocko@kernel.org&gt;
Cc: Igor Mammedov &lt;imammedo@redhat.com&gt;
Cc: Dave Young &lt;dyoung@redhat.com&gt;
Cc: Andrew Morton &lt;akpm@linux-foundation.org&gt;
Cc: Dan Williams &lt;dan.j.williams@intel.com&gt;
Cc: Pavel Tatashin &lt;pasha.tatashin@soleen.com&gt;
Cc: Stefan Hajnoczi &lt;stefanha@redhat.com&gt;
Cc: Vlastimil Babka &lt;vbabka@suse.cz&gt;
Cc: "Rafael J. Wysocki" &lt;rjw@rjwysocki.net&gt;
Cc: Len Brown &lt;lenb@kernel.org&gt;
Cc: linux-acpi@vger.kernel.org
Signed-off-by: David Hildenbrand &lt;david@redhat.com&gt;
---
 <a id="iZ2e.:20200507140139.17083-2-david::40redhat.com:1drivers:virtio:Kconfig" href="#Z2e.:20200507140139.17083-2-david::40redhat.com:1drivers:virtio:Kconfig">drivers/virtio/Kconfig</a>          |   16 +
 <a id="iZ2e.:20200507140139.17083-2-david::40redhat.com:1drivers:virtio:Makefile" href="#Z2e.:20200507140139.17083-2-david::40redhat.com:1drivers:virtio:Makefile">drivers/virtio/Makefile</a>         |    1 +
 <a id="iZ2e.:20200507140139.17083-2-david::40redhat.com:1drivers:virtio:virtio_mem.c" href="#Z2e.:20200507140139.17083-2-david::40redhat.com:1drivers:virtio:virtio_mem.c">drivers/virtio/virtio_mem.c</a>     | 1533 +++++++++++++++++++++++++++++++
 <a id="iZ2e.:20200507140139.17083-2-david::40redhat.com:1include:uapi:linux:virtio_ids.h" href="#Z2e.:20200507140139.17083-2-david::40redhat.com:1include:uapi:linux:virtio_ids.h">include/uapi/linux/virtio_ids.h</a> |    1 +
 <a id="iZ2e.:20200507140139.17083-2-david::40redhat.com:1include:uapi:linux:virtio_mem.h" href="#Z2e.:20200507140139.17083-2-david::40redhat.com:1include:uapi:linux:virtio_mem.h">include/uapi/linux/virtio_mem.h</a> |  200 ++++
 5 files <a href="#related">changed</a>, 1751 insertions(+)
 create mode 100644 drivers/virtio/virtio_mem.c
 create mode 100644 include/uapi/linux/virtio_mem.h

<span class="head"><a href="#iZ2e.:20200507140139.17083-2-david::40redhat.com:1drivers:virtio:Kconfig" id="Z2e.:20200507140139.17083-2-david::40redhat.com:1drivers:virtio:Kconfig">diff</a> --git a/drivers/virtio/Kconfig b/drivers/virtio/Kconfig
index 69a32dfc318a..d6dde7d2cf76 100644
--- a/drivers/virtio/Kconfig
+++ b/drivers/virtio/Kconfig
</span><span class="hunk">@@ -78,6 +78,22 @@ config VIRTIO_BALLOON
</span> 
 	 If unsure, say M.
 
<span class="add">+config VIRTIO_MEM
+	tristate "Virtio mem driver"
+	default m
+	depends on X86_64
+	depends on VIRTIO
+	depends on MEMORY_HOTPLUG_SPARSE
+	depends on MEMORY_HOTREMOVE
+	help
+	 This driver provides access to virtio-mem paravirtualized memory
+	 devices, allowing to hotplug and hotunplug memory.
+
+	 This driver was only tested under x86-64, but should theoretically
+	 work on all architectures that support memory hotplug and hotremove.
+
+	 If unsure, say M.
+
</span> config VIRTIO_INPUT
 	tristate "Virtio input driver"
 	depends on VIRTIO
<span class="head"><a href="#iZ2e.:20200507140139.17083-2-david::40redhat.com:1drivers:virtio:Makefile" id="Z2e.:20200507140139.17083-2-david::40redhat.com:1drivers:virtio:Makefile">diff</a> --git a/drivers/virtio/Makefile b/drivers/virtio/Makefile
index 29a1386ecc03..4d993791f2d7 100644
--- a/drivers/virtio/Makefile
+++ b/drivers/virtio/Makefile
</span><span class="hunk">@@ -7,3 +7,4 @@ virtio_pci-$(CONFIG_VIRTIO_PCI_LEGACY) += virtio_pci_legacy.o
</span> obj-$(CONFIG_VIRTIO_BALLOON) += virtio_balloon.o
 obj-$(CONFIG_VIRTIO_INPUT) += virtio_input.o
 obj-$(CONFIG_VIRTIO_VDPA) += virtio_vdpa.o
<span class="add">+obj-$(CONFIG_VIRTIO_MEM) += virtio_mem.o
</span><span class="head"><a href="#iZ2e.:20200507140139.17083-2-david::40redhat.com:1drivers:virtio:virtio_mem.c" id="Z2e.:20200507140139.17083-2-david::40redhat.com:1drivers:virtio:virtio_mem.c">diff</a> --git a/drivers/virtio/virtio_mem.c b/drivers/virtio/virtio_mem.c
new file mode 100644
index 000000000000..5d1dcaa6fc42
--- /dev/null
+++ b/drivers/virtio/virtio_mem.c
</span><span class="hunk">@@ -0,0 +1,1533 @@
</span><span class="add">+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Virtio-mem device driver.
+ *
+ * Copyright Red Hat, Inc. 2020
+ *
+ * Author(s): David Hildenbrand &lt;david@redhat.com&gt;
+ */
+
+#include &lt;linux/virtio.h&gt;
+#include &lt;linux/virtio_mem.h&gt;
+#include &lt;linux/workqueue.h&gt;
+#include &lt;linux/slab.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/mm.h&gt;
+#include &lt;linux/memory_hotplug.h&gt;
+#include &lt;linux/memory.h&gt;
+#include &lt;linux/hrtimer.h&gt;
+#include &lt;linux/crash_dump.h&gt;
+#include &lt;linux/mutex.h&gt;
+#include &lt;linux/bitmap.h&gt;
+#include &lt;linux/lockdep.h&gt;
+
+enum virtio_mem_mb_state {
+	/* Unplugged, not added to Linux. Can be reused later. */
+	VIRTIO_MEM_MB_STATE_UNUSED = 0,
+	/* (Partially) plugged, not added to Linux. Error on add_memory(). */
+	VIRTIO_MEM_MB_STATE_PLUGGED,
+	/* Fully plugged, fully added to Linux, offline. */
+	VIRTIO_MEM_MB_STATE_OFFLINE,
+	/* Partially plugged, fully added to Linux, offline. */
+	VIRTIO_MEM_MB_STATE_OFFLINE_PARTIAL,
+	/* Fully plugged, fully added to Linux, online (!ZONE_MOVABLE). */
+	VIRTIO_MEM_MB_STATE_ONLINE,
+	/* Partially plugged, fully added to Linux, online (!ZONE_MOVABLE). */
+	VIRTIO_MEM_MB_STATE_ONLINE_PARTIAL,
+	/*
+	 * Fully plugged, fully added to Linux, online (ZONE_MOVABLE).
+	 * We are not allowed to allocate (unplug) parts of this block that
+	 * are not movable (similar to gigantic pages). We will never allow
+	 * to online OFFLINE_PARTIAL to ZONE_MOVABLE (as they would contain
+	 * unmovable parts).
+	 */
+	VIRTIO_MEM_MB_STATE_ONLINE_MOVABLE,
+	VIRTIO_MEM_MB_STATE_COUNT
+};
+
+struct virtio_mem {
+	struct virtio_device *vdev;
+
+	/* We might first have to unplug all memory when starting up. */
+	bool unplug_all_required;
+
+	/* Workqueue that processes the plug/unplug requests. */
+	struct work_struct wq;
+	atomic_t config_changed;
+
+	/* Virtqueue for guest-&gt;host requests. */
+	struct virtqueue *vq;
+
+	/* Wait for a host response to a guest request. */
+	wait_queue_head_t host_resp;
+
+	/* Space for one guest request and the host response. */
+	struct virtio_mem_req req;
+	struct virtio_mem_resp resp;
+
+	/* The current size of the device. */
+	uint64_t plugged_size;
+	/* The requested size of the device. */
+	uint64_t requested_size;
+
+	/* The device block size (for communicating with the device). */
+	uint32_t device_block_size;
+	/* Physical start address of the memory region. */
+	uint64_t addr;
+	/* Maximum region size in bytes. */
+	uint64_t region_size;
+
+	/* The subblock size. */
+	uint32_t subblock_size;
+	/* The number of subblocks per memory block. */
+	uint32_t nb_sb_per_mb;
+
+	/* Id of the first memory block of this device. */
+	unsigned long first_mb_id;
+	/* Id of the last memory block of this device. */
+	unsigned long last_mb_id;
+	/* Id of the last usable memory block of this device. */
+	unsigned long last_usable_mb_id;
+	/* Id of the next memory bock to prepare when needed. */
+	unsigned long next_mb_id;
+
+	/* Summary of all memory block states. */
+	unsigned long nb_mb_state[VIRTIO_MEM_MB_STATE_COUNT];
+#define VIRTIO_MEM_NB_OFFLINE_THRESHOLD		10
+
+	/*
+	 * One byte state per memory block.
+	 *
+	 * Allocated via vmalloc(). When preparing new blocks, resized
+	 * (alloc+copy+free) when needed (crossing pages with the next mb).
+	 * (when crossing pages).
+	 *
+	 * With 128MB memory blocks, we have states for 512GB of memory in one
+	 * page.
+	 */
+	uint8_t *mb_state;
+
+	/*
+	 * $nb_sb_per_mb bit per memory block. Handled similar to mb_state.
+	 *
+	 * With 4MB subblocks, we manage 128GB of memory in one page.
+	 */
+	unsigned long *sb_bitmap;
+
+	/*
+	 * Mutex that protects the nb_mb_state, mb_state, and sb_bitmap.
+	 *
+	 * When this lock is held the pointers can't change, ONLINE and
+	 * OFFLINE blocks can't change the state and no subblocks will get
+	 * plugged.
+	 */
+	struct mutex hotplug_mutex;
+	bool hotplug_active;
+
+	/* An error occurred we cannot handle - stop processing requests. */
+	bool broken;
+
+	/* The driver is being removed. */
+	spinlock_t removal_lock;
+	bool removing;
+
+	/* Timer for retrying to plug/unplug memory. */
+	struct hrtimer retry_timer;
+#define VIRTIO_MEM_RETRY_TIMER_MS		30000
+
+	/* Memory notifier (online/offline events). */
+	struct notifier_block memory_notifier;
+
+	/* Next device in the list of virtio-mem devices. */
+	struct list_head next;
+};
+
+/*
+ * We have to share a single online_page callback among all virtio-mem
+ * devices. We use RCU to iterate the list in the callback.
+ */
+static DEFINE_MUTEX(virtio_mem_mutex);
+static LIST_HEAD(virtio_mem_devices);
+
+static void virtio_mem_online_page_cb(struct page *page, unsigned int order);
+
+/*
+ * Register a virtio-mem device so it will be considered for the online_page
+ * callback.
+ */
+static int register_virtio_mem_device(struct virtio_mem *vm)
+{
+	int rc = 0;
+
+	/* First device registers the callback. */
+	mutex_lock(&amp;virtio_mem_mutex);
+	if (list_empty(&amp;virtio_mem_devices))
+		rc = set_online_page_callback(&amp;virtio_mem_online_page_cb);
+	if (!rc)
+		list_add_rcu(&amp;vm-&gt;next, &amp;virtio_mem_devices);
+	mutex_unlock(&amp;virtio_mem_mutex);
+
+	return rc;
+}
+
+/*
+ * Unregister a virtio-mem device so it will no longer be considered for the
+ * online_page callback.
+ */
+static void unregister_virtio_mem_device(struct virtio_mem *vm)
+{
+	/* Last device unregisters the callback. */
+	mutex_lock(&amp;virtio_mem_mutex);
+	list_del_rcu(&amp;vm-&gt;next);
+	if (list_empty(&amp;virtio_mem_devices))
+		restore_online_page_callback(&amp;virtio_mem_online_page_cb);
+	mutex_unlock(&amp;virtio_mem_mutex);
+
+	synchronize_rcu();
+}
+
+/*
+ * Calculate the memory block id of a given address.
+ */
+static unsigned long virtio_mem_phys_to_mb_id(unsigned long addr)
+{
+	return addr / memory_block_size_bytes();
+}
+
+/*
+ * Calculate the physical start address of a given memory block id.
+ */
+static unsigned long virtio_mem_mb_id_to_phys(unsigned long mb_id)
+{
+	return mb_id * memory_block_size_bytes();
+}
+
+/*
+ * Calculate the subblock id of a given address.
+ */
+static unsigned long virtio_mem_phys_to_sb_id(struct virtio_mem *vm,
+					      unsigned long addr)
+{
+	const unsigned long mb_id = virtio_mem_phys_to_mb_id(addr);
+	const unsigned long mb_addr = virtio_mem_mb_id_to_phys(mb_id);
+
+	return (addr - mb_addr) / vm-&gt;subblock_size;
+}
+
+/*
+ * Set the state of a memory block, taking care of the state counter.
+ */
+static void virtio_mem_mb_set_state(struct virtio_mem *vm, unsigned long mb_id,
+				    enum virtio_mem_mb_state state)
+{
+	const unsigned long idx = mb_id - vm-&gt;first_mb_id;
+	enum virtio_mem_mb_state old_state;
+
+	old_state = vm-&gt;mb_state[idx];
+	vm-&gt;mb_state[idx] = state;
+
+	BUG_ON(vm-&gt;nb_mb_state[old_state] == 0);
+	vm-&gt;nb_mb_state[old_state]--;
+	vm-&gt;nb_mb_state[state]++;
+}
+
+/*
+ * Get the state of a memory block.
+ */
+static enum virtio_mem_mb_state virtio_mem_mb_get_state(struct virtio_mem *vm,
+							unsigned long mb_id)
+{
+	const unsigned long idx = mb_id - vm-&gt;first_mb_id;
+
+	return vm-&gt;mb_state[idx];
+}
+
+/*
+ * Prepare the state array for the next memory block.
+ */
+static int virtio_mem_mb_state_prepare_next_mb(struct virtio_mem *vm)
+{
+	unsigned long old_bytes = vm-&gt;next_mb_id - vm-&gt;first_mb_id + 1;
+	unsigned long new_bytes = vm-&gt;next_mb_id - vm-&gt;first_mb_id + 2;
+	int old_pages = PFN_UP(old_bytes);
+	int new_pages = PFN_UP(new_bytes);
+	uint8_t *new_mb_state;
+
+	if (vm-&gt;mb_state &amp;&amp; old_pages == new_pages)
+		return 0;
+
+	new_mb_state = vzalloc(new_pages * PAGE_SIZE);
+	if (!new_mb_state)
+		return -ENOMEM;
+
+	mutex_lock(&amp;vm-&gt;hotplug_mutex);
+	if (vm-&gt;mb_state)
+		memcpy(new_mb_state, vm-&gt;mb_state, old_pages * PAGE_SIZE);
+	vfree(vm-&gt;mb_state);
+	vm-&gt;mb_state = new_mb_state;
+	mutex_unlock(&amp;vm-&gt;hotplug_mutex);
+
+	return 0;
+}
+
+#define virtio_mem_for_each_mb_state(_vm, _mb_id, _state) \n+	for (_mb_id = _vm-&gt;first_mb_id; \n+	     _mb_id &lt; _vm-&gt;next_mb_id &amp;&amp; _vm-&gt;nb_mb_state[_state]; \n+	     _mb_id++) \n+		if (virtio_mem_mb_get_state(_vm, _mb_id) == _state)
+
+/*
+ * Mark all selected subblocks plugged.
+ *
+ * Will not modify the state of the memory block.
+ */
+static void virtio_mem_mb_set_sb_plugged(struct virtio_mem *vm,
+					 unsigned long mb_id, int sb_id,
+					 int count)
+{
+	const int bit = (mb_id - vm-&gt;first_mb_id) * vm-&gt;nb_sb_per_mb + sb_id;
+
+	__bitmap_set(vm-&gt;sb_bitmap, bit, count);
+}
+
+/*
+ * Mark all selected subblocks unplugged.
+ *
+ * Will not modify the state of the memory block.
+ */
+static void virtio_mem_mb_set_sb_unplugged(struct virtio_mem *vm,
+					   unsigned long mb_id, int sb_id,
+					   int count)
+{
+	const int bit = (mb_id - vm-&gt;first_mb_id) * vm-&gt;nb_sb_per_mb + sb_id;
+
+	__bitmap_clear(vm-&gt;sb_bitmap, bit, count);
+}
+
+/*
+ * Test if all selected subblocks are plugged.
+ */
+static bool virtio_mem_mb_test_sb_plugged(struct virtio_mem *vm,
+					  unsigned long mb_id, int sb_id,
+					  int count)
+{
+	const int bit = (mb_id - vm-&gt;first_mb_id) * vm-&gt;nb_sb_per_mb + sb_id;
+
+	if (count == 1)
+		return test_bit(bit, vm-&gt;sb_bitmap);
+
+	/* TODO: Helper similar to bitmap_set() */
+	return find_next_zero_bit(vm-&gt;sb_bitmap, bit + count, bit) &gt;=
+	       bit + count;
+}
+
+/*
+ * Find the first plugged subblock. Returns vm-&gt;nb_sb_per_mb in case there is
+ * none.
+ */
+static int virtio_mem_mb_first_plugged_sb(struct virtio_mem *vm,
+					  unsigned long mb_id)
+{
+	const int bit = (mb_id - vm-&gt;first_mb_id) * vm-&gt;nb_sb_per_mb;
+
+	return find_next_bit(vm-&gt;sb_bitmap, bit + vm-&gt;nb_sb_per_mb, bit) - bit;
+}
+
+/*
+ * Find the first unplugged subblock. Returns vm-&gt;nb_sb_per_mb in case there is
+ * none.
+ */
+static int virtio_mem_mb_first_unplugged_sb(struct virtio_mem *vm,
+					    unsigned long mb_id)
+{
+	const int bit = (mb_id - vm-&gt;first_mb_id) * vm-&gt;nb_sb_per_mb;
+
+	return find_next_zero_bit(vm-&gt;sb_bitmap, bit + vm-&gt;nb_sb_per_mb, bit) -
+	       bit;
+}
+
+/*
+ * Prepare the subblock bitmap for the next memory block.
+ */
+static int virtio_mem_sb_bitmap_prepare_next_mb(struct virtio_mem *vm)
+{
+	const unsigned long old_nb_mb = vm-&gt;next_mb_id - vm-&gt;first_mb_id;
+	const unsigned long old_nb_bits = old_nb_mb * vm-&gt;nb_sb_per_mb;
+	const unsigned long new_nb_bits = (old_nb_mb + 1) * vm-&gt;nb_sb_per_mb;
+	int old_pages = PFN_UP(BITS_TO_LONGS(old_nb_bits) * sizeof(long));
+	int new_pages = PFN_UP(BITS_TO_LONGS(new_nb_bits) * sizeof(long));
+	unsigned long *new_sb_bitmap, *old_sb_bitmap;
+
+	if (vm-&gt;sb_bitmap &amp;&amp; old_pages == new_pages)
+		return 0;
+
+	new_sb_bitmap = vzalloc(new_pages * PAGE_SIZE);
+	if (!new_sb_bitmap)
+		return -ENOMEM;
+
+	mutex_lock(&amp;vm-&gt;hotplug_mutex);
+	if (new_sb_bitmap)
+		memcpy(new_sb_bitmap, vm-&gt;sb_bitmap, old_pages * PAGE_SIZE);
+
+	old_sb_bitmap = vm-&gt;sb_bitmap;
+	vm-&gt;sb_bitmap = new_sb_bitmap;
+	mutex_unlock(&amp;vm-&gt;hotplug_mutex);
+
+	vfree(old_sb_bitmap);
+	return 0;
+}
+
+/*
+ * Try to add a memory block to Linux. This will usually only fail
+ * if out of memory.
+ *
+ * Must not be called with the vm-&gt;hotplug_mutex held (possible deadlock with
+ * onlining code).
+ *
+ * Will not modify the state of the memory block.
+ */
+static int virtio_mem_mb_add(struct virtio_mem *vm, unsigned long mb_id)
+{
+	const uint64_t addr = virtio_mem_mb_id_to_phys(mb_id);
+	int nid = memory_add_physaddr_to_nid(addr);
+
+	dev_dbg(&amp;vm-&gt;vdev-&gt;dev, "adding memory block: %lu
", mb_id);
+	return add_memory(nid, addr, memory_block_size_bytes());
+}
+
+/*
+ * Try to remove a memory block from Linux. Will only fail if the memory block
+ * is not offline.
+ *
+ * Must not be called with the vm-&gt;hotplug_mutex held (possible deadlock with
+ * onlining code).
+ *
+ * Will not modify the state of the memory block.
+ */
+static int virtio_mem_mb_remove(struct virtio_mem *vm, unsigned long mb_id)
+{
+	const uint64_t addr = virtio_mem_mb_id_to_phys(mb_id);
+	int nid = memory_add_physaddr_to_nid(addr);
+
+	dev_dbg(&amp;vm-&gt;vdev-&gt;dev, "removing memory block: %lu
", mb_id);
+	return remove_memory(nid, addr, memory_block_size_bytes());
+}
+
+/*
+ * Trigger the workqueue so the device can perform its magic.
+ */
+static void virtio_mem_retry(struct virtio_mem *vm)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&amp;vm-&gt;removal_lock, flags);
+	if (!vm-&gt;removing)
+		queue_work(system_freezable_wq, &amp;vm-&gt;wq);
+	spin_unlock_irqrestore(&amp;vm-&gt;removal_lock, flags);
+}
+
+/*
+ * Test if a virtio-mem device overlaps with the given range. Can be called
+ * from (notifier) callbacks lockless.
+ */
+static bool virtio_mem_overlaps_range(struct virtio_mem *vm,
+				      unsigned long start, unsigned long size)
+{
+	unsigned long dev_start = virtio_mem_mb_id_to_phys(vm-&gt;first_mb_id);
+	unsigned long dev_end = virtio_mem_mb_id_to_phys(vm-&gt;last_mb_id) +
+				memory_block_size_bytes();
+
+	return start &lt; dev_end &amp;&amp; dev_start &lt; start + size;
+}
+
+/*
+ * Test if a virtio-mem device owns a memory block. Can be called from
+ * (notifier) callbacks lockless.
+ */
+static bool virtio_mem_owned_mb(struct virtio_mem *vm, unsigned long mb_id)
+{
+	return mb_id &gt;= vm-&gt;first_mb_id &amp;&amp; mb_id &lt;= vm-&gt;last_mb_id;
+}
+
+static int virtio_mem_notify_going_online(struct virtio_mem *vm,
+					  unsigned long mb_id,
+					  enum zone_type zone)
+{
+	switch (virtio_mem_mb_get_state(vm, mb_id)) {
+	case VIRTIO_MEM_MB_STATE_OFFLINE_PARTIAL:
+		/*
+		 * We won't allow to online a partially plugged memory block
+		 * to the MOVABLE zone - it would contain unmovable parts.
+		 */
+		if (zone == ZONE_MOVABLE) {
+			dev_warn_ratelimited(&amp;vm-&gt;vdev-&gt;dev,
+					     "memory block has holes, MOVABLE not supported
");
+			return NOTIFY_BAD;
+		}
+		return NOTIFY_OK;
+	case VIRTIO_MEM_MB_STATE_OFFLINE:
+		return NOTIFY_OK;
+	default:
+		break;
+	}
+	dev_warn_ratelimited(&amp;vm-&gt;vdev-&gt;dev,
+			     "memory block onlining denied
");
+	return NOTIFY_BAD;
+}
+
+static void virtio_mem_notify_offline(struct virtio_mem *vm,
+				      unsigned long mb_id)
+{
+	switch (virtio_mem_mb_get_state(vm, mb_id)) {
+	case VIRTIO_MEM_MB_STATE_ONLINE_PARTIAL:
+		virtio_mem_mb_set_state(vm, mb_id,
+					VIRTIO_MEM_MB_STATE_OFFLINE_PARTIAL);
+		break;
+	case VIRTIO_MEM_MB_STATE_ONLINE:
+	case VIRTIO_MEM_MB_STATE_ONLINE_MOVABLE:
+		virtio_mem_mb_set_state(vm, mb_id,
+					VIRTIO_MEM_MB_STATE_OFFLINE);
+		break;
+	default:
+		BUG();
+		break;
+	}
+}
+
+static void virtio_mem_notify_online(struct virtio_mem *vm, unsigned long mb_id,
+				     enum zone_type zone)
+{
+	unsigned long nb_offline;
+
+	switch (virtio_mem_mb_get_state(vm, mb_id)) {
+	case VIRTIO_MEM_MB_STATE_OFFLINE_PARTIAL:
+		BUG_ON(zone == ZONE_MOVABLE);
+		virtio_mem_mb_set_state(vm, mb_id,
+					VIRTIO_MEM_MB_STATE_ONLINE_PARTIAL);
+		break;
+	case VIRTIO_MEM_MB_STATE_OFFLINE:
+		if (zone == ZONE_MOVABLE)
+			virtio_mem_mb_set_state(vm, mb_id,
+					    VIRTIO_MEM_MB_STATE_ONLINE_MOVABLE);
+		else
+			virtio_mem_mb_set_state(vm, mb_id,
+						VIRTIO_MEM_MB_STATE_ONLINE);
+		break;
+	default:
+		BUG();
+		break;
+	}
+	nb_offline = vm-&gt;nb_mb_state[VIRTIO_MEM_MB_STATE_OFFLINE] +
+		     vm-&gt;nb_mb_state[VIRTIO_MEM_MB_STATE_OFFLINE_PARTIAL];
+
+	/* see if we can add new blocks now that we onlined one block */
+	if (nb_offline == VIRTIO_MEM_NB_OFFLINE_THRESHOLD - 1)
+		virtio_mem_retry(vm);
+}
+
+/*
+ * This callback will either be called synchronously from add_memory() or
+ * asynchronously (e.g., triggered via user space). We have to be careful
+ * with locking when calling add_memory().
+ */
+static int virtio_mem_memory_notifier_cb(struct notifier_block *nb,
+					 unsigned long action, void *arg)
+{
+	struct virtio_mem *vm = container_of(nb, struct virtio_mem,
+					     memory_notifier);
+	struct memory_notify *mhp = arg;
+	const unsigned long start = PFN_PHYS(mhp-&gt;start_pfn);
+	const unsigned long size = PFN_PHYS(mhp-&gt;nr_pages);
+	const unsigned long mb_id = virtio_mem_phys_to_mb_id(start);
+	enum zone_type zone;
+	int rc = NOTIFY_OK;
+
+	if (!virtio_mem_overlaps_range(vm, start, size))
+		return NOTIFY_DONE;
+
+	/*
+	 * Memory is onlined/offlined in memory block granularity. We cannot
+	 * cross virtio-mem device boundaries and memory block boundaries. Bail
+	 * out if this ever changes.
+	 */
+	if (WARN_ON_ONCE(size != memory_block_size_bytes() ||
+			 !IS_ALIGNED(start, memory_block_size_bytes())))
+		return NOTIFY_BAD;
+
+	/*
+	 * Avoid circular locking lockdep warnings. We lock the mutex
+	 * e.g., in MEM_GOING_ONLINE and unlock it in MEM_ONLINE. The
+	 * blocking_notifier_call_chain() has it's own lock, which gets unlocked
+	 * between both notifier calls and will bail out. False positive.
+	 */
+	lockdep_off();
+
+	switch (action) {
+	case MEM_GOING_OFFLINE:
+		mutex_lock(&amp;vm-&gt;hotplug_mutex);
+		if (vm-&gt;removing) {
+			rc = notifier_from_errno(-EBUSY);
+			mutex_unlock(&amp;vm-&gt;hotplug_mutex);
+			break;
+		}
+		vm-&gt;hotplug_active = true;
+		break;
+	case MEM_GOING_ONLINE:
+		mutex_lock(&amp;vm-&gt;hotplug_mutex);
+		if (vm-&gt;removing) {
+			rc = notifier_from_errno(-EBUSY);
+			mutex_unlock(&amp;vm-&gt;hotplug_mutex);
+			break;
+		}
+		vm-&gt;hotplug_active = true;
+		zone = page_zonenum(pfn_to_page(mhp-&gt;start_pfn));
+		rc = virtio_mem_notify_going_online(vm, mb_id, zone);
+		break;
+	case MEM_OFFLINE:
+		virtio_mem_notify_offline(vm, mb_id);
+		vm-&gt;hotplug_active = false;
+		mutex_unlock(&amp;vm-&gt;hotplug_mutex);
+		break;
+	case MEM_ONLINE:
+		zone = page_zonenum(pfn_to_page(mhp-&gt;start_pfn));
+		virtio_mem_notify_online(vm, mb_id, zone);
+		vm-&gt;hotplug_active = false;
+		mutex_unlock(&amp;vm-&gt;hotplug_mutex);
+		break;
+	case MEM_CANCEL_OFFLINE:
+	case MEM_CANCEL_ONLINE:
+		if (!vm-&gt;hotplug_active)
+			break;
+		vm-&gt;hotplug_active = false;
+		mutex_unlock(&amp;vm-&gt;hotplug_mutex);
+		break;
+	default:
+		break;
+	}
+
+	lockdep_on();
+
+	return rc;
+}
+
+/*
+ * Set a range of pages PG_offline.
+ */
+static void virtio_mem_set_fake_offline(unsigned long pfn,
+					unsigned int nr_pages)
+{
+	for (; nr_pages--; pfn++)
+		__SetPageOffline(pfn_to_page(pfn));
+}
+
+/*
+ * Clear PG_offline from a range of pages.
+ */
+static void virtio_mem_clear_fake_offline(unsigned long pfn,
+					  unsigned int nr_pages)
+{
+	for (; nr_pages--; pfn++)
+		__ClearPageOffline(pfn_to_page(pfn));
+}
+
+/*
+ * Release a range of fake-offline pages to the buddy, effectively
+ * fake-onlining them.
+ */
+static void virtio_mem_fake_online(unsigned long pfn, unsigned int nr_pages)
+{
+	const int order = MAX_ORDER - 1;
+	int i;
+
+	/*
+	 * We are always called with subblock granularity, which is at least
+	 * aligned to MAX_ORDER - 1.
+	 */
+	virtio_mem_clear_fake_offline(pfn, nr_pages);
+
+	for (i = 0; i &lt; nr_pages; i += 1 &lt;&lt; order)
+		generic_online_page(pfn_to_page(pfn + i), order);
+}
+
+static void virtio_mem_online_page_cb(struct page *page, unsigned int order)
+{
+	const unsigned long addr = page_to_phys(page);
+	const unsigned long mb_id = virtio_mem_phys_to_mb_id(addr);
+	struct virtio_mem *vm;
+	int sb_id;
+
+	/*
+	 * We exploit here that subblocks have at least MAX_ORDER - 1
+	 * size/alignment and that this callback is is called with such a
+	 * size/alignment. So we cannot cross subblocks and therefore
+	 * also not memory blocks.
+	 */
+	rcu_read_lock();
+	list_for_each_entry_rcu(vm, &amp;virtio_mem_devices, next) {
+		if (!virtio_mem_owned_mb(vm, mb_id))
+			continue;
+
+		sb_id = virtio_mem_phys_to_sb_id(vm, addr);
+		/*
+		 * If plugged, online the pages, otherwise, set them fake
+		 * offline (PageOffline).
+		 */
+		if (virtio_mem_mb_test_sb_plugged(vm, mb_id, sb_id, 1))
+			generic_online_page(page, order);
+		else
+			virtio_mem_set_fake_offline(PFN_DOWN(addr), 1 &lt;&lt; order);
+		rcu_read_unlock();
+		return;
+	}
+	rcu_read_unlock();
+
+	/* not virtio-mem memory, but e.g., a DIMM. online it */
+	generic_online_page(page, order);
+}
+
+static uint64_t virtio_mem_send_request(struct virtio_mem *vm,
+					const struct virtio_mem_req *req)
+{
+	struct scatterlist *sgs[2], sg_req, sg_resp;
+	unsigned int len;
+	int rc;
+
+	/* don't use the request residing on the stack (vaddr) */
+	vm-&gt;req = *req;
+
+	/* out: buffer for request */
+	sg_init_one(&amp;sg_req, &amp;vm-&gt;req, sizeof(vm-&gt;req));
+	sgs[0] = &amp;sg_req;
+
+	/* in: buffer for response */
+	sg_init_one(&amp;sg_resp, &amp;vm-&gt;resp, sizeof(vm-&gt;resp));
+	sgs[1] = &amp;sg_resp;
+
+	rc = virtqueue_add_sgs(vm-&gt;vq, sgs, 1, 1, vm, GFP_KERNEL);
+	if (rc &lt; 0)
+		return rc;
+
+	virtqueue_kick(vm-&gt;vq);
+
+	/* wait for a response */
+	wait_event(vm-&gt;host_resp, virtqueue_get_buf(vm-&gt;vq, &amp;len));
+
+	return virtio16_to_cpu(vm-&gt;vdev, vm-&gt;resp.type);
+}
+
+static int virtio_mem_send_plug_request(struct virtio_mem *vm, uint64_t addr,
+					uint64_t size)
+{
+	const uint64_t nb_vm_blocks = size / vm-&gt;device_block_size;
+	const struct virtio_mem_req req = {
+		.type = cpu_to_virtio16(vm-&gt;vdev, VIRTIO_MEM_REQ_PLUG),
+		.u.plug.addr = cpu_to_virtio64(vm-&gt;vdev, addr),
+		.u.plug.nb_blocks = cpu_to_virtio16(vm-&gt;vdev, nb_vm_blocks),
+	};
+
+	if (atomic_read(&amp;vm-&gt;config_changed))
+		return -EAGAIN;
+
+	switch (virtio_mem_send_request(vm, &amp;req)) {
+	case VIRTIO_MEM_RESP_ACK:
+		vm-&gt;plugged_size += size;
+		return 0;
+	case VIRTIO_MEM_RESP_NACK:
+		return -EAGAIN;
+	case VIRTIO_MEM_RESP_BUSY:
+		return -EBUSY;
+	case VIRTIO_MEM_RESP_ERROR:
+		return -EINVAL;
+	default:
+		return -ENOMEM;
+	}
+}
+
+static int virtio_mem_send_unplug_request(struct virtio_mem *vm, uint64_t addr,
+					  uint64_t size)
+{
+	const uint64_t nb_vm_blocks = size / vm-&gt;device_block_size;
+	const struct virtio_mem_req req = {
+		.type = cpu_to_virtio16(vm-&gt;vdev, VIRTIO_MEM_REQ_UNPLUG),
+		.u.unplug.addr = cpu_to_virtio64(vm-&gt;vdev, addr),
+		.u.unplug.nb_blocks = cpu_to_virtio16(vm-&gt;vdev, nb_vm_blocks),
+	};
+
+	if (atomic_read(&amp;vm-&gt;config_changed))
+		return -EAGAIN;
+
+	switch (virtio_mem_send_request(vm, &amp;req)) {
+	case VIRTIO_MEM_RESP_ACK:
+		vm-&gt;plugged_size -= size;
+		return 0;
+	case VIRTIO_MEM_RESP_BUSY:
+		return -EBUSY;
+	case VIRTIO_MEM_RESP_ERROR:
+		return -EINVAL;
+	default:
+		return -ENOMEM;
+	}
+}
+
+static int virtio_mem_send_unplug_all_request(struct virtio_mem *vm)
+{
+	const struct virtio_mem_req req = {
+		.type = cpu_to_virtio16(vm-&gt;vdev, VIRTIO_MEM_REQ_UNPLUG_ALL),
+	};
+
+	switch (virtio_mem_send_request(vm, &amp;req)) {
+	case VIRTIO_MEM_RESP_ACK:
+		vm-&gt;unplug_all_required = false;
+		vm-&gt;plugged_size = 0;
+		/* usable region might have shrunk */
+		atomic_set(&amp;vm-&gt;config_changed, 1);
+		return 0;
+	case VIRTIO_MEM_RESP_BUSY:
+		return -EBUSY;
+	default:
+		return -ENOMEM;
+	}
+}
+
+/*
+ * Plug selected subblocks. Updates the plugged state, but not the state
+ * of the memory block.
+ */
+static int virtio_mem_mb_plug_sb(struct virtio_mem *vm, unsigned long mb_id,
+				 int sb_id, int count)
+{
+	const uint64_t addr = virtio_mem_mb_id_to_phys(mb_id) +
+			      sb_id * vm-&gt;subblock_size;
+	const uint64_t size = count * vm-&gt;subblock_size;
+	int rc;
+
+	dev_dbg(&amp;vm-&gt;vdev-&gt;dev, "plugging memory block: %lu : %i - %i
", mb_id,
+		sb_id, sb_id + count - 1);
+
+	rc = virtio_mem_send_plug_request(vm, addr, size);
+	if (!rc)
+		virtio_mem_mb_set_sb_plugged(vm, mb_id, sb_id, count);
+	return rc;
+}
+
+/*
+ * Unplug selected subblocks. Updates the plugged state, but not the state
+ * of the memory block.
+ */
+static int virtio_mem_mb_unplug_sb(struct virtio_mem *vm, unsigned long mb_id,
+				   int sb_id, int count)
+{
+	const uint64_t addr = virtio_mem_mb_id_to_phys(mb_id) +
+			      sb_id * vm-&gt;subblock_size;
+	const uint64_t size = count * vm-&gt;subblock_size;
+	int rc;
+
+	dev_dbg(&amp;vm-&gt;vdev-&gt;dev, "unplugging memory block: %lu : %i - %i
",
+		mb_id, sb_id, sb_id + count - 1);
+
+	rc = virtio_mem_send_unplug_request(vm, addr, size);
+	if (!rc)
+		virtio_mem_mb_set_sb_unplugged(vm, mb_id, sb_id, count);
+	return rc;
+}
+
+/*
+ * Unplug the desired number of plugged subblocks of a offline or not-added
+ * memory block. Will fail if any subblock cannot get unplugged (instead of
+ * skipping it).
+ *
+ * Will not modify the state of the memory block.
+ *
+ * Note: can fail after some subblocks were unplugged.
+ */
+static int virtio_mem_mb_unplug_any_sb(struct virtio_mem *vm,
+				       unsigned long mb_id, uint64_t *nb_sb)
+{
+	int sb_id, count;
+	int rc;
+
+	while (*nb_sb) {
+		sb_id = virtio_mem_mb_first_plugged_sb(vm, mb_id);
+		if (sb_id &gt;= vm-&gt;nb_sb_per_mb)
+			break;
+		count = 1;
+		while (count &lt; *nb_sb &amp;&amp;
+		       sb_id + count  &lt; vm-&gt;nb_sb_per_mb &amp;&amp;
+		       virtio_mem_mb_test_sb_plugged(vm, mb_id, sb_id + count,
+						     1))
+			count++;
+
+		rc = virtio_mem_mb_unplug_sb(vm, mb_id, sb_id, count);
+		if (rc)
+			return rc;
+		*nb_sb -= count;
+	}
+
+	return 0;
+}
+
+/*
+ * Unplug all plugged subblocks of an offline or not-added memory block.
+ *
+ * Will not modify the state of the memory block.
+ *
+ * Note: can fail after some subblocks were unplugged.
+ */
+static int virtio_mem_mb_unplug(struct virtio_mem *vm, unsigned long mb_id)
+{
+	uint64_t nb_sb = vm-&gt;nb_sb_per_mb;
+
+	return virtio_mem_mb_unplug_any_sb(vm, mb_id, &amp;nb_sb);
+}
+
+/*
+ * Prepare tracking data for the next memory block.
+ */
+static int virtio_mem_prepare_next_mb(struct virtio_mem *vm,
+				      unsigned long *mb_id)
+{
+	int rc;
+
+	if (vm-&gt;next_mb_id &gt; vm-&gt;last_usable_mb_id)
+		return -ENOSPC;
+
+	/* Resize the state array if required. */
+	rc = virtio_mem_mb_state_prepare_next_mb(vm);
+	if (rc)
+		return rc;
+
+	/* Resize the subblock bitmap if required. */
+	rc = virtio_mem_sb_bitmap_prepare_next_mb(vm);
+	if (rc)
+		return rc;
+
+	vm-&gt;nb_mb_state[VIRTIO_MEM_MB_STATE_UNUSED]++;
+	*mb_id = vm-&gt;next_mb_id++;
+	return 0;
+}
+
+/*
+ * Don't add too many blocks that are not onlined yet to avoid running OOM.
+ */
+static bool virtio_mem_too_many_mb_offline(struct virtio_mem *vm)
+{
+	unsigned long nb_offline;
+
+	nb_offline = vm-&gt;nb_mb_state[VIRTIO_MEM_MB_STATE_OFFLINE] +
+		     vm-&gt;nb_mb_state[VIRTIO_MEM_MB_STATE_OFFLINE_PARTIAL];
+	return nb_offline &gt;= VIRTIO_MEM_NB_OFFLINE_THRESHOLD;
+}
+
+/*
+ * Try to plug the desired number of subblocks and add the memory block
+ * to Linux.
+ *
+ * Will modify the state of the memory block.
+ */
+static int virtio_mem_mb_plug_and_add(struct virtio_mem *vm,
+				      unsigned long mb_id,
+				      uint64_t *nb_sb)
+{
+	const int count = min_t(int, *nb_sb, vm-&gt;nb_sb_per_mb);
+	int rc, rc2;
+
+	if (WARN_ON_ONCE(!count))
+		return -EINVAL;
+
+	/*
+	 * Plug the requested number of subblocks before adding it to linux,
+	 * so that onlining will directly online all plugged subblocks.
+	 */
+	rc = virtio_mem_mb_plug_sb(vm, mb_id, 0, count);
+	if (rc)
+		return rc;
+
+	/*
+	 * Mark the block properly offline before adding it to Linux,
+	 * so the memory notifiers will find the block in the right state.
+	 */
+	if (count == vm-&gt;nb_sb_per_mb)
+		virtio_mem_mb_set_state(vm, mb_id,
+					VIRTIO_MEM_MB_STATE_OFFLINE);
+	else
+		virtio_mem_mb_set_state(vm, mb_id,
+					VIRTIO_MEM_MB_STATE_OFFLINE_PARTIAL);
+
+	/* Add the memory block to linux - if that fails, try to unplug. */
+	rc = virtio_mem_mb_add(vm, mb_id);
+	if (rc) {
+		enum virtio_mem_mb_state new_state = VIRTIO_MEM_MB_STATE_UNUSED;
+
+		dev_err(&amp;vm-&gt;vdev-&gt;dev,
+			"adding memory block %lu failed with %d
", mb_id, rc);
+		rc2 = virtio_mem_mb_unplug_sb(vm, mb_id, 0, count);
+
+		/*
+		 * TODO: Linux MM does not properly clean up yet in all cases
+		 * where adding of memory failed - especially on -ENOMEM.
+		 */
+		if (rc2)
+			new_state = VIRTIO_MEM_MB_STATE_PLUGGED;
+		virtio_mem_mb_set_state(vm, mb_id, new_state);
+		return rc;
+	}
+
+	*nb_sb -= count;
+	return 0;
+}
+
+/*
+ * Try to plug the desired number of subblocks of a memory block that
+ * is already added to Linux.
+ *
+ * Will modify the state of the memory block.
+ *
+ * Note: Can fail after some subblocks were successfully plugged.
+ */
+static int virtio_mem_mb_plug_any_sb(struct virtio_mem *vm, unsigned long mb_id,
+				     uint64_t *nb_sb, bool online)
+{
+	unsigned long pfn, nr_pages;
+	int sb_id, count;
+	int rc;
+
+	if (WARN_ON_ONCE(!*nb_sb))
+		return -EINVAL;
+
+	while (*nb_sb) {
+		sb_id = virtio_mem_mb_first_unplugged_sb(vm, mb_id);
+		if (sb_id &gt;= vm-&gt;nb_sb_per_mb)
+			break;
+		count = 1;
+		while (count &lt; *nb_sb &amp;&amp;
+		       sb_id + count &lt; vm-&gt;nb_sb_per_mb &amp;&amp;
+		       !virtio_mem_mb_test_sb_plugged(vm, mb_id, sb_id + count,
+						      1))
+			count++;
+
+		rc = virtio_mem_mb_plug_sb(vm, mb_id, sb_id, count);
+		if (rc)
+			return rc;
+		*nb_sb -= count;
+		if (!online)
+			continue;
+
+		/* fake-online the pages if the memory block is online */
+		pfn = PFN_DOWN(virtio_mem_mb_id_to_phys(mb_id) +
+			       sb_id * vm-&gt;subblock_size);
+		nr_pages = PFN_DOWN(count * vm-&gt;subblock_size);
+		virtio_mem_fake_online(pfn, nr_pages);
+	}
+
+	if (virtio_mem_mb_test_sb_plugged(vm, mb_id, 0, vm-&gt;nb_sb_per_mb)) {
+		if (online)
+			virtio_mem_mb_set_state(vm, mb_id,
+						VIRTIO_MEM_MB_STATE_ONLINE);
+		else
+			virtio_mem_mb_set_state(vm, mb_id,
+						VIRTIO_MEM_MB_STATE_OFFLINE);
+	}
+
+	return rc;
+}
+
+/*
+ * Try to plug the requested amount of memory.
+ */
+static int virtio_mem_plug_request(struct virtio_mem *vm, uint64_t diff)
+{
+	uint64_t nb_sb = diff / vm-&gt;subblock_size;
+	unsigned long mb_id;
+	int rc;
+
+	if (!nb_sb)
+		return 0;
+
+	/* Don't race with onlining/offlining */
+	mutex_lock(&amp;vm-&gt;hotplug_mutex);
+
+	/* Try to plug subblocks of partially plugged online blocks. */
+	virtio_mem_for_each_mb_state(vm, mb_id,
+				     VIRTIO_MEM_MB_STATE_ONLINE_PARTIAL) {
+		rc = virtio_mem_mb_plug_any_sb(vm, mb_id, &amp;nb_sb, true);
+		if (rc || !nb_sb)
+			goto out_unlock;
+		cond_resched();
+	}
+
+	/* Try to plug subblocks of partially plugged offline blocks. */
+	virtio_mem_for_each_mb_state(vm, mb_id,
+				     VIRTIO_MEM_MB_STATE_OFFLINE_PARTIAL) {
+		rc = virtio_mem_mb_plug_any_sb(vm, mb_id, &amp;nb_sb, false);
+		if (rc || !nb_sb)
+			goto out_unlock;
+		cond_resched();
+	}
+
+	/*
+	 * We won't be working on online/offline memory blocks from this point,
+	 * so we can't race with memory onlining/offlining. Drop the mutex.
+	 */
+	mutex_unlock(&amp;vm-&gt;hotplug_mutex);
+
+	/* Try to plug and add unused blocks */
+	virtio_mem_for_each_mb_state(vm, mb_id, VIRTIO_MEM_MB_STATE_UNUSED) {
+		if (virtio_mem_too_many_mb_offline(vm))
+			return -ENOSPC;
+
+		rc = virtio_mem_mb_plug_and_add(vm, mb_id, &amp;nb_sb);
+		if (rc || !nb_sb)
+			return rc;
+		cond_resched();
+	}
+
+	/* Try to prepare, plug and add new blocks */
+	while (nb_sb) {
+		if (virtio_mem_too_many_mb_offline(vm))
+			return -ENOSPC;
+
+		rc = virtio_mem_prepare_next_mb(vm, &amp;mb_id);
+		if (rc)
+			return rc;
+		rc = virtio_mem_mb_plug_and_add(vm, mb_id, &amp;nb_sb);
+		if (rc)
+			return rc;
+		cond_resched();
+	}
+
+	return 0;
+out_unlock:
+	mutex_unlock(&amp;vm-&gt;hotplug_mutex);
+	return rc;
+}
+
+/*
+ * Try to unplug all blocks that couldn't be unplugged before, for example,
+ * because the hypervisor was busy.
+ */
+static int virtio_mem_unplug_pending_mb(struct virtio_mem *vm)
+{
+	unsigned long mb_id;
+	int rc;
+
+	virtio_mem_for_each_mb_state(vm, mb_id, VIRTIO_MEM_MB_STATE_PLUGGED) {
+		rc = virtio_mem_mb_unplug(vm, mb_id);
+		if (rc)
+			return rc;
+		virtio_mem_mb_set_state(vm, mb_id, VIRTIO_MEM_MB_STATE_UNUSED);
+	}
+
+	return 0;
+}
+
+/*
+ * Update all parts of the config that could have changed.
+ */
+static void virtio_mem_refresh_config(struct virtio_mem *vm)
+{
+	const uint64_t phys_limit = 1UL &lt;&lt; MAX_PHYSMEM_BITS;
+	uint64_t new_plugged_size, usable_region_size, end_addr;
+
+	/* the plugged_size is just a reflection of what _we_ did previously */
+	virtio_cread(vm-&gt;vdev, struct virtio_mem_config, plugged_size,
+		     &amp;new_plugged_size);
+	if (WARN_ON_ONCE(new_plugged_size != vm-&gt;plugged_size))
+		vm-&gt;plugged_size = new_plugged_size;
+
+	/* calculate the last usable memory block id */
+	virtio_cread(vm-&gt;vdev, struct virtio_mem_config,
+		     usable_region_size, &amp;usable_region_size);
+	end_addr = vm-&gt;addr + usable_region_size;
+	end_addr = min(end_addr, phys_limit);
+	vm-&gt;last_usable_mb_id = virtio_mem_phys_to_mb_id(end_addr) - 1;
+
+	/* see if there is a request to change the size */
+	virtio_cread(vm-&gt;vdev, struct virtio_mem_config, requested_size,
+		     &amp;vm-&gt;requested_size);
+
+	dev_info(&amp;vm-&gt;vdev-&gt;dev, "plugged size: 0x%llx", vm-&gt;plugged_size);
+	dev_info(&amp;vm-&gt;vdev-&gt;dev, "requested size: 0x%llx", vm-&gt;requested_size);
+}
+
+/*
+ * Workqueue function for handling plug/unplug requests and config updates.
+ */
+static void virtio_mem_run_wq(struct work_struct *work)
+{
+	struct virtio_mem *vm = container_of(work, struct virtio_mem, wq);
+	uint64_t diff;
+	int rc;
+
+	hrtimer_cancel(&amp;vm-&gt;retry_timer);
+
+	if (vm-&gt;broken)
+		return;
+
+retry:
+	rc = 0;
+
+	/* Make sure we start with a clean state if there are leftovers. */
+	if (unlikely(vm-&gt;unplug_all_required))
+		rc = virtio_mem_send_unplug_all_request(vm);
+
+	if (atomic_read(&amp;vm-&gt;config_changed)) {
+		atomic_set(&amp;vm-&gt;config_changed, 0);
+		virtio_mem_refresh_config(vm);
+	}
+
+	/* Unplug any leftovers from previous runs */
+	if (!rc)
+		rc = virtio_mem_unplug_pending_mb(vm);
+
+	if (!rc &amp;&amp; vm-&gt;requested_size != vm-&gt;plugged_size) {
+		if (vm-&gt;requested_size &gt; vm-&gt;plugged_size) {
+			diff = vm-&gt;requested_size - vm-&gt;plugged_size;
+			rc = virtio_mem_plug_request(vm, diff);
+		}
+		/* TODO: try to unplug memory */
+	}
+
+	switch (rc) {
+	case 0:
+		break;
+	case -ENOSPC:
+		/*
+		 * We cannot add any more memory (alignment, physical limit)
+		 * or we have too many offline memory blocks.
+		 */
+		break;
+	case -EBUSY:
+		/*
+		 * The hypervisor cannot process our request right now
+		 * (e.g., out of memory, migrating).
+		 */
+	case -ENOMEM:
+		/* Out of memory, try again later. */
+		hrtimer_start(&amp;vm-&gt;retry_timer,
+			      ms_to_ktime(VIRTIO_MEM_RETRY_TIMER_MS),
+			      HRTIMER_MODE_REL);
+		break;
+	case -EAGAIN:
+		/* Retry immediately (e.g., the config changed). */
+		goto retry;
+	default:
+		/* Unknown error, mark as broken */
+		dev_err(&amp;vm-&gt;vdev-&gt;dev,
+			"unknown error, marking device broken: %d
", rc);
+		vm-&gt;broken = true;
+	}
+}
+
+static enum hrtimer_restart virtio_mem_timer_expired(struct hrtimer *timer)
+{
+	struct virtio_mem *vm = container_of(timer, struct virtio_mem,
+					     retry_timer);
+
+	virtio_mem_retry(vm);
+	return HRTIMER_NORESTART;
+}
+
+static void virtio_mem_handle_response(struct virtqueue *vq)
+{
+	struct virtio_mem *vm = vq-&gt;vdev-&gt;priv;
+
+	wake_up(&amp;vm-&gt;host_resp);
+}
+
+static int virtio_mem_init_vq(struct virtio_mem *vm)
+{
+	struct virtqueue *vq;
+
+	vq = virtio_find_single_vq(vm-&gt;vdev, virtio_mem_handle_response,
+				   "guest-request");
+	if (IS_ERR(vq))
+		return PTR_ERR(vq);
+	vm-&gt;vq = vq;
+
+	return 0;
+}
+
+/*
+ * Test if any memory in the range is present in Linux.
+ */
+static bool virtio_mem_any_memory_present(unsigned long start,
+					  unsigned long size)
+{
+	const unsigned long start_pfn = PFN_DOWN(start);
+	const unsigned long end_pfn = PFN_UP(start + size);
+	unsigned long pfn;
+
+	for (pfn = start_pfn; pfn != end_pfn; pfn++)
+		if (present_section_nr(pfn_to_section_nr(pfn)))
+			return true;
+
+	return false;
+}
+
+static int virtio_mem_init(struct virtio_mem *vm)
+{
+	const uint64_t phys_limit = 1UL &lt;&lt; MAX_PHYSMEM_BITS;
+
+	if (!vm-&gt;vdev-&gt;config-&gt;get) {
+		dev_err(&amp;vm-&gt;vdev-&gt;dev, "config access disabled
");
+		return -EINVAL;
+	}
+
+	/*
+	 * We don't want to (un)plug or reuse any memory when in kdump. The
+	 * memory is still accessible (but not mapped).
+	 */
+	if (is_kdump_kernel()) {
+		dev_warn(&amp;vm-&gt;vdev-&gt;dev, "disabled in kdump kernel
");
+		return -EBUSY;
+	}
+
+	/* Fetch all properties that can't change. */
+	virtio_cread(vm-&gt;vdev, struct virtio_mem_config, plugged_size,
+		     &amp;vm-&gt;plugged_size);
+	virtio_cread(vm-&gt;vdev, struct virtio_mem_config, block_size,
+		     &amp;vm-&gt;device_block_size);
+	virtio_cread(vm-&gt;vdev, struct virtio_mem_config, addr, &amp;vm-&gt;addr);
+	virtio_cread(vm-&gt;vdev, struct virtio_mem_config, region_size,
+		     &amp;vm-&gt;region_size);
+
+	/*
+	 * If we still have memory plugged, we might have to unplug all
+	 * memory first. However, if somebody simply unloaded the driver
+	 * we would have to reinitialize the old state - something we don't
+	 * support yet. Detect if we have any memory in the area present.
+	 */
+	if (vm-&gt;plugged_size) {
+		uint64_t usable_region_size;
+
+		virtio_cread(vm-&gt;vdev, struct virtio_mem_config,
+			     usable_region_size, &amp;usable_region_size);
+
+		if (virtio_mem_any_memory_present(vm-&gt;addr,
+						  usable_region_size)) {
+			dev_err(&amp;vm-&gt;vdev-&gt;dev,
+				"reloading the driver is not supported
");
+			return -EINVAL;
+		}
+		/*
+		 * Note: it might happen that the device is busy and
+		 * unplugging all memory might take some time.
+		 */
+		dev_info(&amp;vm-&gt;vdev-&gt;dev, "unplugging all memory required
");
+		vm-&gt;unplug_all_required = 1;
+	}
+
+	/*
+	 * We always hotplug memory in memory block granularity. This way,
+	 * we have to wait for exactly one memory block to online.
+	 */
+	if (vm-&gt;device_block_size &gt; memory_block_size_bytes()) {
+		dev_err(&amp;vm-&gt;vdev-&gt;dev,
+			"The block size is not supported (too big).
");
+		return -EINVAL;
+	}
+
+	/* bad device setup - warn only */
+	if (!IS_ALIGNED(vm-&gt;addr, memory_block_size_bytes()))
+		dev_warn(&amp;vm-&gt;vdev-&gt;dev,
+			 "The alignment of the physical start address can make some memory unusable.
");
+	if (!IS_ALIGNED(vm-&gt;addr + vm-&gt;region_size, memory_block_size_bytes()))
+		dev_warn(&amp;vm-&gt;vdev-&gt;dev,
+			 "The alignment of the physical end address can make some memory unusable.
");
+	if (vm-&gt;addr + vm-&gt;region_size &gt; phys_limit)
+		dev_warn(&amp;vm-&gt;vdev-&gt;dev,
+			 "Some memory is not addressable. This can make some memory unusable.
");
+
+	/*
+	 * Calculate the subblock size:
+	 * - At least MAX_ORDER - 1 / pageblock_order.
+	 * - At least the device block size.
+	 * In the worst case, a single subblock per memory block.
+	 */
+	vm-&gt;subblock_size = PAGE_SIZE * 1u &lt;&lt; max_t(uint32_t, MAX_ORDER - 1,
+						    pageblock_order);
+	vm-&gt;subblock_size = max_t(uint32_t, vm-&gt;device_block_size,
+				  vm-&gt;subblock_size);
+	vm-&gt;nb_sb_per_mb = memory_block_size_bytes() / vm-&gt;subblock_size;
+
+	/* Round up to the next full memory block */
+	vm-&gt;first_mb_id = virtio_mem_phys_to_mb_id(vm-&gt;addr - 1 +
+						   memory_block_size_bytes());
+	vm-&gt;next_mb_id = vm-&gt;first_mb_id;
+	vm-&gt;last_mb_id = virtio_mem_phys_to_mb_id(vm-&gt;addr +
+			 vm-&gt;region_size) - 1;
+
+	dev_info(&amp;vm-&gt;vdev-&gt;dev, "start address: 0x%llx", vm-&gt;addr);
+	dev_info(&amp;vm-&gt;vdev-&gt;dev, "region size: 0x%llx", vm-&gt;region_size);
+	dev_info(&amp;vm-&gt;vdev-&gt;dev, "device block size: 0x%x",
+		 vm-&gt;device_block_size);
+	dev_info(&amp;vm-&gt;vdev-&gt;dev, "memory block size: 0x%lx",
+		 memory_block_size_bytes());
+	dev_info(&amp;vm-&gt;vdev-&gt;dev, "subblock size: 0x%x",
+		 vm-&gt;subblock_size);
+
+	return 0;
+}
+
+static int virtio_mem_probe(struct virtio_device *vdev)
+{
+	struct virtio_mem *vm;
+	int rc = -EINVAL;
+
+	vdev-&gt;priv = vm = kzalloc(sizeof(*vm), GFP_KERNEL);
+	if (!vm)
+		return -ENOMEM;
+
+	init_waitqueue_head(&amp;vm-&gt;host_resp);
+	vm-&gt;vdev = vdev;
+	INIT_WORK(&amp;vm-&gt;wq, virtio_mem_run_wq);
+	mutex_init(&amp;vm-&gt;hotplug_mutex);
+	INIT_LIST_HEAD(&amp;vm-&gt;next);
+	spin_lock_init(&amp;vm-&gt;removal_lock);
+	hrtimer_init(&amp;vm-&gt;retry_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	vm-&gt;retry_timer.function = virtio_mem_timer_expired;
+
+	/* register the virtqueue */
+	rc = virtio_mem_init_vq(vm);
+	if (rc)
+		goto out_free_vm;
+
+	/* initialize the device by querying the config */
+	rc = virtio_mem_init(vm);
+	if (rc)
+		goto out_del_vq;
+
+	/* register callbacks */
+	vm-&gt;memory_notifier.notifier_call = virtio_mem_memory_notifier_cb;
+	rc = register_memory_notifier(&amp;vm-&gt;memory_notifier);
+	if (rc)
+		goto out_del_vq;
+	rc = register_virtio_mem_device(vm);
+	if (rc)
+		goto out_unreg_mem;
+
+	virtio_device_ready(vdev);
+
+	/* trigger a config update to start processing the requested_size */
+	atomic_set(&amp;vm-&gt;config_changed, 1);
+	queue_work(system_freezable_wq, &amp;vm-&gt;wq);
+
+	return 0;
+out_unreg_mem:
+	unregister_memory_notifier(&amp;vm-&gt;memory_notifier);
+out_del_vq:
+	vdev-&gt;config-&gt;del_vqs(vdev);
+out_free_vm:
+	kfree(vm);
+	vdev-&gt;priv = NULL;
+
+	return rc;
+}
+
+static void virtio_mem_remove(struct virtio_device *vdev)
+{
+	struct virtio_mem *vm = vdev-&gt;priv;
+	unsigned long mb_id;
+	int rc;
+
+	/*
+	 * Make sure the workqueue won't be triggered anymore and no memory
+	 * blocks can be onlined/offlined until we're finished here.
+	 */
+	mutex_lock(&amp;vm-&gt;hotplug_mutex);
+	spin_lock_irq(&amp;vm-&gt;removal_lock);
+	vm-&gt;removing = true;
+	spin_unlock_irq(&amp;vm-&gt;removal_lock);
+	mutex_unlock(&amp;vm-&gt;hotplug_mutex);
+
+	/* wait until the workqueue stopped */
+	cancel_work_sync(&amp;vm-&gt;wq);
+	hrtimer_cancel(&amp;vm-&gt;retry_timer);
+
+	/*
+	 * After we unregistered our callbacks, user space can online partially
+	 * plugged offline blocks. Make sure to remove them.
+	 */
+	virtio_mem_for_each_mb_state(vm, mb_id,
+				     VIRTIO_MEM_MB_STATE_OFFLINE_PARTIAL) {
+		rc = virtio_mem_mb_remove(vm, mb_id);
+		BUG_ON(rc);
+		virtio_mem_mb_set_state(vm, mb_id, VIRTIO_MEM_MB_STATE_UNUSED);
+	}
+
+	/* unregister callbacks */
+	unregister_virtio_mem_device(vm);
+	unregister_memory_notifier(&amp;vm-&gt;memory_notifier);
+
+	/*
+	 * There is no way we could reliably remove all memory we have added to
+	 * the system. And there is no way to stop the driver/device from going
+	 * away. Warn at least.
+	 */
+	if (vm-&gt;nb_mb_state[VIRTIO_MEM_MB_STATE_OFFLINE] ||
+	    vm-&gt;nb_mb_state[VIRTIO_MEM_MB_STATE_OFFLINE_PARTIAL] ||
+	    vm-&gt;nb_mb_state[VIRTIO_MEM_MB_STATE_ONLINE] ||
+	    vm-&gt;nb_mb_state[VIRTIO_MEM_MB_STATE_ONLINE_PARTIAL] ||
+	    vm-&gt;nb_mb_state[VIRTIO_MEM_MB_STATE_ONLINE_MOVABLE])
+		dev_warn(&amp;vdev-&gt;dev, "device still has system memory added
");
+
+	/* remove all tracking data - no locking needed */
+	vfree(vm-&gt;mb_state);
+	vfree(vm-&gt;sb_bitmap);
+
+	/* reset the device and cleanup the queues */
+	vdev-&gt;config-&gt;reset(vdev);
+	vdev-&gt;config-&gt;del_vqs(vdev);
+
+	kfree(vm);
+	vdev-&gt;priv = NULL;
+}
+
+static void virtio_mem_config_changed(struct virtio_device *vdev)
+{
+	struct virtio_mem *vm = vdev-&gt;priv;
+
+	atomic_set(&amp;vm-&gt;config_changed, 1);
+	virtio_mem_retry(vm);
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int virtio_mem_freeze(struct virtio_device *vdev)
+{
+	/*
+	 * When restarting the VM, all memory is usually unplugged. Don't
+	 * allow to suspend/hibernate.
+	 */
+	dev_err(&amp;vdev-&gt;dev, "save/restore not supported.
");
+	return -EPERM;
+}
+
+static int virtio_mem_restore(struct virtio_device *vdev)
+{
+	return -EPERM;
+}
+#endif
+
+static struct virtio_device_id virtio_mem_id_table[] = {
+	{ VIRTIO_ID_MEM, VIRTIO_DEV_ANY_ID },
+	{ 0 },
+};
+
+static struct virtio_driver virtio_mem_driver = {
+	.driver.name = KBUILD_MODNAME,
+	.driver.owner = THIS_MODULE,
+	.id_table = virtio_mem_id_table,
+	.probe = virtio_mem_probe,
+	.remove = virtio_mem_remove,
+	.config_changed = virtio_mem_config_changed,
+#ifdef CONFIG_PM_SLEEP
+	.freeze	=	virtio_mem_freeze,
+	.restore =	virtio_mem_restore,
+#endif
+};
+
+module_virtio_driver(virtio_mem_driver);
+MODULE_DEVICE_TABLE(virtio, virtio_mem_id_table);
+MODULE_AUTHOR("David Hildenbrand &lt;david@redhat.com&gt;");
+MODULE_DESCRIPTION("Virtio-mem driver");
+MODULE_LICENSE("GPL");
</span><span class="head"><a href="#iZ2e.:20200507140139.17083-2-david::40redhat.com:1include:uapi:linux:virtio_ids.h" id="Z2e.:20200507140139.17083-2-david::40redhat.com:1include:uapi:linux:virtio_ids.h">diff</a> --git a/include/uapi/linux/virtio_ids.h b/include/uapi/linux/virtio_ids.h
index ecc27a17401a..b052355ac7a3 100644
--- a/include/uapi/linux/virtio_ids.h
+++ b/include/uapi/linux/virtio_ids.h
</span><span class="hunk">@@ -44,6 +44,7 @@
</span> #define VIRTIO_ID_VSOCK        19 /* virtio vsock transport */
 #define VIRTIO_ID_CRYPTO       20 /* virtio crypto */
 #define VIRTIO_ID_IOMMU        23 /* virtio IOMMU */
<span class="add">+#define VIRTIO_ID_MEM          24 /* virtio mem */
</span> #define VIRTIO_ID_FS           26 /* virtio filesystem */
 #define VIRTIO_ID_PMEM         27 /* virtio pmem */
 #define VIRTIO_ID_MAC80211_HWSIM 29 /* virtio mac80211-hwsim */
<span class="head"><a href="#iZ2e.:20200507140139.17083-2-david::40redhat.com:1include:uapi:linux:virtio_mem.h" id="Z2e.:20200507140139.17083-2-david::40redhat.com:1include:uapi:linux:virtio_mem.h">diff</a> --git a/include/uapi/linux/virtio_mem.h b/include/uapi/linux/virtio_mem.h
new file mode 100644
index 000000000000..1bfade78bdfd
--- /dev/null
+++ b/include/uapi/linux/virtio_mem.h
</span><span class="hunk">@@ -0,0 +1,200 @@
</span><span class="add">+/* SPDX-License-Identifier: BSD-3-Clause */
+/*
+ * Virtio Mem Device
+ *
+ * Copyright Red Hat, Inc. 2020
+ *
+ * Authors:
+ *     David Hildenbrand &lt;david@redhat.com&gt;
+ *
+ * This header is BSD licensed so anyone can use the definitions
+ * to implement compatible drivers/servers:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of IBM nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL IBM OR
+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef _LINUX_VIRTIO_MEM_H
+#define _LINUX_VIRTIO_MEM_H
+
+#include &lt;linux/types.h&gt;
+#include &lt;linux/virtio_types.h&gt;
+#include &lt;linux/virtio_ids.h&gt;
+#include &lt;linux/virtio_config.h&gt;
+
+/*
+ * Each virtio-mem device manages a dedicated region in physical address
+ * space. Each device can belong to a single NUMA node, multiple devices
+ * for a single NUMA node are possible. A virtio-mem device is like a
+ * "resizable DIMM" consisting of small memory blocks that can be plugged
+ * or unplugged. The device driver is responsible for (un)plugging memory
+ * blocks on demand.
+ *
+ * Virtio-mem devices can only operate on their assigned memory region in
+ * order to (un)plug memory. A device cannot (un)plug memory belonging to
+ * other devices.
+ *
+ * The "region_size" corresponds to the maximum amount of memory that can
+ * be provided by a device. The "size" corresponds to the amount of memory
+ * that is currently plugged. "requested_size" corresponds to a request
+ * from the device to the device driver to (un)plug blocks. The
+ * device driver should try to (un)plug blocks in order to reach the
+ * "requested_size". It is impossible to plug more memory than requested.
+ *
+ * The "usable_region_size" represents the memory region that can actually
+ * be used to (un)plug memory. It is always at least as big as the
+ * "requested_size" and will grow dynamically. It will only shrink when
+ * explicitly triggered (VIRTIO_MEM_REQ_UNPLUG).
+ *
+ * There are no guarantees what will happen if unplugged memory is
+ * read/written. Such memory should, in general, not be touched. E.g.,
+ * even writing might succeed, but the values will simply be discarded at
+ * random points in time.
+ *
+ * It can happen that the device cannot process a request, because it is
+ * busy. The device driver has to retry later.
+ *
+ * Usually, during system resets all memory will get unplugged, so the
+ * device driver can start with a clean state. However, in specific
+ * scenarios (if the device is busy) it can happen that the device still
+ * has memory plugged. The device driver can request to unplug all memory
+ * (VIRTIO_MEM_REQ_UNPLUG) - which might take a while to succeed if the
+ * device is busy.
+ */
+
+/* --- virtio-mem: guest -&gt; host requests --- */
+
+/* request to plug memory blocks */
+#define VIRTIO_MEM_REQ_PLUG			0
+/* request to unplug memory blocks */
+#define VIRTIO_MEM_REQ_UNPLUG			1
+/* request to unplug all blocks and shrink the usable size */
+#define VIRTIO_MEM_REQ_UNPLUG_ALL		2
+/* request information about the plugged state of memory blocks */
+#define VIRTIO_MEM_REQ_STATE			3
+
+struct virtio_mem_req_plug {
+	__virtio64 addr;
+	__virtio16 nb_blocks;
+};
+
+struct virtio_mem_req_unplug {
+	__virtio64 addr;
+	__virtio16 nb_blocks;
+};
+
+struct virtio_mem_req_state {
+	__virtio64 addr;
+	__virtio16 nb_blocks;
+};
+
+struct virtio_mem_req {
+	__virtio16 type;
+	__virtio16 padding[3];
+
+	union {
+		struct virtio_mem_req_plug plug;
+		struct virtio_mem_req_unplug unplug;
+		struct virtio_mem_req_state state;
+	} u;
+};
+
+
+/* --- virtio-mem: host -&gt; guest response --- */
+
+/*
+ * Request processed successfully, applicable for
+ * - VIRTIO_MEM_REQ_PLUG
+ * - VIRTIO_MEM_REQ_UNPLUG
+ * - VIRTIO_MEM_REQ_UNPLUG_ALL
+ * - VIRTIO_MEM_REQ_STATE
+ */
+#define VIRTIO_MEM_RESP_ACK			0
+/*
+ * Request denied - e.g. trying to plug more than requested, applicable for
+ * - VIRTIO_MEM_REQ_PLUG
+ */
+#define VIRTIO_MEM_RESP_NACK			1
+/*
+ * Request cannot be processed right now, try again later, applicable for
+ * - VIRTIO_MEM_REQ_PLUG
+ * - VIRTIO_MEM_REQ_UNPLUG
+ * - VIRTIO_MEM_REQ_UNPLUG_ALL
+ */
+#define VIRTIO_MEM_RESP_BUSY			2
+/*
+ * Error in request (e.g. addresses/alignment), applicable for
+ * - VIRTIO_MEM_REQ_PLUG
+ * - VIRTIO_MEM_REQ_UNPLUG
+ * - VIRTIO_MEM_REQ_STATE
+ */
+#define VIRTIO_MEM_RESP_ERROR			3
+
+
+/* State of memory blocks is "plugged" */
+#define VIRTIO_MEM_STATE_PLUGGED		0
+/* State of memory blocks is "unplugged" */
+#define VIRTIO_MEM_STATE_UNPLUGGED		1
+/* State of memory blocks is "mixed" */
+#define VIRTIO_MEM_STATE_MIXED			2
+
+struct virtio_mem_resp_state {
+	__virtio16 state;
+};
+
+struct virtio_mem_resp {
+	__virtio16 type;
+	__virtio16 padding[3];
+
+	union {
+		struct virtio_mem_resp_state state;
+	} u;
+};
+
+/* --- virtio-mem: configuration --- */
+
+struct virtio_mem_config {
+	/* Block size and alignment. Cannot change. */
+	__u32 block_size;
+	__u32 padding;
+	/* Start address of the memory region. Cannot change. */
+	__u64 addr;
+	/* Region size (maximum). Cannot change. */
+	__u64 region_size;
+	/*
+	 * Currently usable region size. Can grow up to region_size. Can
+	 * shrink due to VIRTIO_MEM_REQ_UNPLUG_ALL (in which case no config
+	 * update will be sent).
+	 */
+	__u64 usable_region_size;
+	/*
+	 * Currently used size. Changes due to plug/unplug requests, but no
+	 * config updates will be sent.
+	 */
+	__u64 plugged_size;
+	/* Requested size. New plug requests cannot exceed it. Can change. */
+	__u64 requested_size;
+};
+
+#endif /* _LINUX_VIRTIO_MEM_H */
</span>-- 
2.25.3

</pre><hr><pre><a href="../20200507140139.17083-2-david@redhat.com/" rel="next">next</a> <a href="../20200507140139.17083-1-david@redhat.com/" rel="prev">prev parent</a> <a href="#R">reply</a>	other threads:[<a href="../?t=20200507140224">~2020-05-07 14:02 UTC</a>|<a href="../">newest</a>]

<b>Thread overview: </b>49+ messages / expand[<a href="T/#u">flat</a>|<a href="t/#u">nested</a>]  <a href="t.mbox.gz">mbox.gz</a>  <a href="t.atom">Atom feed</a>  <a href="#b">top</a>
2020-05-07 14:01 <a href="../20200507140139.17083-1-david@redhat.com/">[virtio-dev] [PATCH v4 00/15] virtio-mem: paravirtualized memory</a> David Hildenbrand
2020-05-07 14:01 ` <a href="../20200507140139.17083-1-david@redhat.com/">David Hildenbrand</a>
2020-05-07 14:01 ` <a href="../20200507140139.17083-1-david@redhat.com/">David Hildenbrand</a>
<b>2020-05-07 14:01 ` <a id="r" href="#t">David Hildenbrand [this message]</a></b>
2020-05-07 14:01   ` <a href="../20200507140139.17083-2-david@redhat.com/">[PATCH v4 01/15] virtio-mem: Paravirtualized memory hotplug</a> David Hildenbrand
2020-05-07 14:01 ` <a href="../20200507140139.17083-3-david@redhat.com/">[virtio-dev] [PATCH v4 02/15] MAINTAINERS: Add myself as virtio-mem maintainer</a> David Hildenbrand
2020-05-07 14:01   ` <a href="../20200507140139.17083-3-david@redhat.com/">David Hildenbrand</a>
2020-05-07 14:01 ` <a href="../20200507140139.17083-4-david@redhat.com/">[virtio-dev] [PATCH v4 03/15] virtio-mem: Allow to specify an ACPI PXM as nid</a> David Hildenbrand
2020-05-07 14:01   ` <a href="../20200507140139.17083-4-david@redhat.com/">David Hildenbrand</a>
2020-05-07 14:01 ` <a href="../20200507140139.17083-5-david@redhat.com/">[virtio-dev] [PATCH v4 04/15] virtio-mem: Paravirtualized memory hotunplug part 1</a> David Hildenbrand
2020-05-07 14:01   ` <a href="../20200507140139.17083-5-david@redhat.com/">David Hildenbrand</a>
2020-05-07 14:01   ` <a href="../20200507140139.17083-5-david@redhat.com/">David Hildenbrand</a>
2020-05-07 14:01 ` <a href="../20200507140139.17083-6-david@redhat.com/">[virtio-dev] [PATCH v4 05/15] virtio-mem: Paravirtualized memory hotunplug part 2</a> David Hildenbrand
2020-05-07 14:01   ` <a href="../20200507140139.17083-6-david@redhat.com/">David Hildenbrand</a>
2020-05-07 14:01   ` <a href="../20200507140139.17083-6-david@redhat.com/">David Hildenbrand</a>
2020-05-07 14:01 ` <a href="../20200507140139.17083-7-david@redhat.com/">[virtio-dev] [PATCH v4 06/15] mm: Allow to offline unmovable PageOffline() pages via MEM_GOING_OFFLINE</a> David Hildenbrand
2020-05-07 14:01   ` <a href="../20200507140139.17083-7-david@redhat.com/">David Hildenbrand</a>
2020-05-07 14:01   ` <a href="../20200507140139.17083-7-david@redhat.com/">David Hildenbrand</a>
2020-05-07 14:01 ` <a href="../20200507140139.17083-8-david@redhat.com/">[virtio-dev] [PATCH v4 07/15] virtio-mem: Allow to offline partially unplugged memory blocks</a> David Hildenbrand
2020-05-07 14:01   ` <a href="../20200507140139.17083-8-david@redhat.com/">David Hildenbrand</a>
2020-05-07 14:01 ` <a href="../20200507140139.17083-9-david@redhat.com/">[virtio-dev] [PATCH v4 08/15] mm/memory_hotplug: Introduce offline_and_remove_memory()</a> David Hildenbrand
2020-05-07 14:01   ` <a href="../20200507140139.17083-9-david@redhat.com/">David Hildenbrand</a>
2020-05-07 14:01 ` <a href="../20200507140139.17083-10-david@redhat.com/">[virtio-dev] [PATCH v4 09/15] virtio-mem: Offline and remove completely unplugged memory blocks</a> David Hildenbrand
2020-05-07 14:01   ` <a href="../20200507140139.17083-10-david@redhat.com/">David Hildenbrand</a>
2020-05-07 14:01 ` <a href="../20200507140139.17083-11-david@redhat.com/">[virtio-dev] [PATCH v4 10/15] virtio-mem: Better retry handling</a> David Hildenbrand
2020-05-07 14:01   ` <a href="../20200507140139.17083-11-david@redhat.com/">David Hildenbrand</a>
2020-05-07 14:01 ` <a href="../20200507140139.17083-12-david@redhat.com/">[virtio-dev] [PATCH v4 11/15] virtio-mem: Add parent resource for all added "System RAM"</a> David Hildenbrand
2020-05-07 14:01   ` <a href="../20200507140139.17083-12-david@redhat.com/">David Hildenbrand</a>
2020-05-07 14:06   ` <a href="../CAM9Jb+jXy6Adhg=GstpMZN3roo1uQuikj2hpsxGj6-JUQU3oGA@mail.gmail.com/">Pankaj Gupta</a>
2020-05-07 14:01 ` <a href="../20200507140139.17083-13-david@redhat.com/">[virtio-dev] [PATCH v4 12/15] virtio-mem: Drop manual check for already present memory</a> David Hildenbrand
2020-05-07 14:01   ` <a href="../20200507140139.17083-13-david@redhat.com/">David Hildenbrand</a>
2020-05-07 14:01 ` <a href="../20200507140139.17083-14-david@redhat.com/">[virtio-dev] [PATCH v4 13/15] virtio-mem: Unplug subblocks right-to-left</a> David Hildenbrand
2020-05-07 14:01   ` <a href="../20200507140139.17083-14-david@redhat.com/">David Hildenbrand</a>
2020-05-07 14:01 ` <a href="../20200507140139.17083-15-david@redhat.com/">[virtio-dev] [PATCH v4 14/15] virtio-mem: Use -ETXTBSY as error code if the device is busy</a> David Hildenbrand
2020-05-07 14:01   ` <a href="../20200507140139.17083-15-david@redhat.com/">David Hildenbrand</a>
2020-05-07 14:01   ` <a href="../20200507140139.17083-15-david@redhat.com/">David Hildenbrand</a>
2020-05-07 14:01 ` <a href="../20200507140139.17083-16-david@redhat.com/">[virtio-dev] [PATCH v4 15/15] virtio-mem: Try to unplug the complete online memory block first</a> David Hildenbrand
2020-05-07 14:01   ` <a href="../20200507140139.17083-16-david@redhat.com/">David Hildenbrand</a>
2020-05-15 10:14 ` <a href="../20200515101402.16597-1-david@redhat.com/">[virtio-dev] [PATCH v4 16/15] virtio-mem: Don't rely on implicit compiler padding for requests</a> David Hildenbrand
2020-05-15 10:14   ` <a href="../20200515101402.16597-1-david@redhat.com/">David Hildenbrand</a>
2020-05-20  5:25 ` <a href="../2603F9B2-17D0-4A05-A82B-2D3B9671A96E@linux.alibaba.com/">[virtio-dev] Re: [PATCH v4 00/15] virtio-mem: paravirtualized memory</a> teawater
2020-05-20  5:25   ` <a href="../2603F9B2-17D0-4A05-A82B-2D3B9671A96E@linux.alibaba.com/">teawater</a>
2020-05-20  5:25   ` <a href="../2603F9B2-17D0-4A05-A82B-2D3B9671A96E@linux.alibaba.com/">teawater</a>
2020-05-20  7:56   ` <a href="../d7f18e6b-84e7-47d1-88d6-c73b5dcd8315@redhat.com/">[virtio-dev]</a> " David Hildenbrand
2020-05-20  7:56     ` <a href="../d7f18e6b-84e7-47d1-88d6-c73b5dcd8315@redhat.com/">David Hildenbrand</a>
2020-05-20  7:56     ` <a href="../d7f18e6b-84e7-47d1-88d6-c73b5dcd8315@redhat.com/">David Hildenbrand</a>
2020-06-02  7:09 ` <a href="../8e130bb2-e4bc-bbfc-a635-b44957f069ed@redhat.com/">[virtio-dev]</a> " David Hildenbrand
2020-06-02  7:09   ` <a href="../8e130bb2-e4bc-bbfc-a635-b44957f069ed@redhat.com/">David Hildenbrand</a>
2020-06-02  7:09   ` <a href="../8e130bb2-e4bc-bbfc-a635-b44957f069ed@redhat.com/">David Hildenbrand</a>
</pre><form id="related" action="../"><pre>find likely ancestor, descendant, or conflicting patches for <a href="#t">this message</a>:
<textarea name="q" cols="72" rows="8">( dfblob:69a32dfc318 dfblob:d6dde7d2cf7 dfblob:29a1386ecc0
dfblob:4d993791f2d dfblob:5d1dcaa6fc4 dfblob:ecc27a17401
dfblob:b052355ac7a dfblob:1bfade78bdf dfblob:69a32dfc318
dfblob:d6dde7d2cf7 dfblob:29a1386ecc0 dfblob:4d993791f2d
dfblob:5d1dcaa6fc4 dfblob:ecc27a17401 dfblob:b052355ac7a
dfblob:1bfade78bdf )
 OR (
bs:"[PATCH v4 01/15] virtio-mem: Paravirtualized memory hotplug" )</textarea>
<input type="submit" value="search">	(<a href="../_/text/help/#search">help</a>)</pre></form>
<hr><pre id="R"><b>Reply instructions:</b>

You may reply publicly to <a href="#t">this message</a> via plain-text email
using any one of the following methods:

* Save the following mbox file, import it into your mail client,
  and reply-to-all from there: <a href="raw">mbox</a>

  Avoid top-posting and favor interleaved quoting:
  <a href="https://en.wikipedia.org/wiki/Posting_style#Interleaved_style">https://en.wikipedia.org/wiki/Posting_style#Interleaved_style</a>

* Reply using the <b>--to</b>, <b>--cc</b>, and <b>--in-reply-to</b>
  switches of git-send-email(1):

  git send-email \n    --in-reply-to=20200507140139.17083-2-david@redhat.com \n    --to=david@redhat.com \n    --cc=akpm@linux-foundation.org \n    --cc=dan.j.williams@intel.com \n    --cc=dyoung@redhat.com \n    --cc=imammedo@redhat.com \n    --cc=jasowang@redhat.com \n    --cc=kvm@vger.kernel.org \n    --cc=lenb@kernel.org \n    --cc=linux-acpi@vger.kernel.org \n    --cc=linux-kernel@vger.kernel.org \n    --cc=linux-mm@kvack.org \n    --cc=mhocko@kernel.org \n    --cc=mst@redhat.com \n    --cc=osalvador@suse.de \n    --cc=pankaj.gupta.linux@gmail.com \n    --cc=pasha.tatashin@soleen.com \n    --cc=rjw@rjwysocki.net \n    --cc=stefanha@redhat.com \n    --cc=vbabka@suse.cz \n    --cc=virtio-dev@lists.oasis-open.org \n    --cc=virtualization@lists.linux-foundation.org \n    /path/to/YOUR_REPLY

  <a href="https://kernel.org/pub/software/scm/git/docs/git-send-email.html">https://kernel.org/pub/software/scm/git/docs/git-send-email.html</a>

* If your mail client supports setting the <b>In-Reply-To</b> header
  via mailto: links, try the <a href="mailto:david@redhat.com?In-Reply-To=%3C20200507140139.17083-2-david@redhat.com%3E&amp;Cc=akpm%40linux-foundation.org%2Cdan.j.williams%40intel.com%2Cdyoung%40redhat.com%2Cimammedo%40redhat.com%2Cjasowang%40redhat.com%2Ckvm%40vger.kernel.org%2Clenb%40kernel.org%2Clinux-acpi%40vger.kernel.org%2Clinux-kernel%40vger.kernel.org%2Clinux-mm%40kvack.org%2Cmhocko%40kernel.org%2Cmst%40redhat.com%2Cosalvador%40suse.de%2Cpankaj.gupta.linux%40gmail.com%2Cpasha.tatashin%40soleen.com%2Crjw%40rjwysocki.net%2Cstefanha%40redhat.com%2Cvbabka%40suse.cz%2Cvirtio-dev%40lists.oasis-open.org%2Cvirtualization%40lists.linux-foundation.org&amp;Subject=Re%3A%20%5Bvirtio-dev%5D%20%5BPATCH%20v4%2001%2F15%5D%20virtio-mem%3A%20Paravirtualized%20memory%20hotplug">mailto: link</a>
</pre>

  Be sure your reply has a <b>Subject:</b> header at the top and a blank line
  before the message body.
<hr><pre>This is an external index of several public inboxes,
see <a href="../_/text/mirror/">mirroring instructions</a> on how to clone and mirror
all data and code used by this external index.</pre></body><div style="all: initial;"><div style="all: initial;" id="__hcfy__"></div></div><div id="immersive-translate-popup" style="all: initial"></div></html>