<!-- Filename: 书签工具栏/虚拟化/IO/IOMMU/测试/[RFC PATCH v1 0_2] tests_qtest_ Add RISC-V IOMMU bare-metal test using iommu-testdev (2026-01-29 10：12：27).html
 Page saved with X-Webpage-Conserve 
 url: https://lore.kernel.org/qemu-devel/cover.1769600111.git.chao.liu.zevorn@gmail.com/T/#t
 Summary: 
-->
<html><head><title>[RFC PATCH v1 0/2] tests/qtest: Add RISC-V IOMMU bare-metal test using iommu-testdev</title><link rel="alternate" title="Atom feed" href="../../new.atom" type="application/atom+xml"><style>pre{white-space:pre-wrap}*{font-size:100%;font-family:monospace}</style><link type="text/css" rel="stylesheet" href="../../216light.css?6914e0a5" media="screen,print"><link type="text/css" rel="stylesheet" href="../../216dark.css?6914e0a5" media="screen and (prefers-color-scheme:dark)"><style data-id="immersive-translate-input-injected-css">.immersive-translate-input {
  position: absolute;
  top: 0;
  right: 0;
  left: 0;
  bottom: 0;
  z-index: 2147483647;
  display: flex;
  justify-content: center;
  align-items: center;
}
.immersive-translate-attach-loading::after {
  content: " ";

  --loading-color: #f78fb6;
  width: 6px;
  height: 6px;
  border-radius: 50%;
  display: block;
  margin: 12px auto;
  position: relative;
  color: white;
  left: -100px;
  box-sizing: border-box;
  animation: immersiveTranslateShadowRolling 1.5s linear infinite;

  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-2000%, -50%);
  z-index: 100;
}

.immersive-translate-loading-spinner {
  vertical-align: middle !important;
  width: 10px !important;
  height: 10px !important;
  display: inline-block !important;
  margin: 0 4px !important;
  border: 2px rgba(221, 244, 255, 0.6) solid !important;
  border-top: 2px rgba(0, 0, 0, 0.375) solid !important;
  border-left: 2px rgba(0, 0, 0, 0.375) solid !important;
  border-radius: 50% !important;
  padding: 0 !important;
  -webkit-animation: immersive-translate-loading-animation 0.6s infinite linear !important;
  animation: immersive-translate-loading-animation 0.6s infinite linear !important;
}

@-webkit-keyframes immersive-translate-loading-animation {
  from {
    -webkit-transform: rotate(0deg);
  }

  to {
    -webkit-transform: rotate(359deg);
  }
}

@keyframes immersive-translate-loading-animation {
  from {
    transform: rotate(0deg);
  }

  to {
    transform: rotate(359deg);
  }
}

.immersive-translate-input-loading {
  --loading-color: #f78fb6;
  width: 6px;
  height: 6px;
  border-radius: 50%;
  display: block;
  margin: 12px auto;
  position: relative;
  color: white;
  left: -100px;
  box-sizing: border-box;
  animation: immersiveTranslateShadowRolling 1.5s linear infinite;
}

@keyframes immersiveTranslateShadowRolling {
  0% {
    box-shadow: 0px 0 rgba(255, 255, 255, 0), 0px 0 rgba(255, 255, 255, 0),
      0px 0 rgba(255, 255, 255, 0), 0px 0 rgba(255, 255, 255, 0);
  }

  12% {
    box-shadow: 100px 0 var(--loading-color), 0px 0 rgba(255, 255, 255, 0),
      0px 0 rgba(255, 255, 255, 0), 0px 0 rgba(255, 255, 255, 0);
  }

  25% {
    box-shadow: 110px 0 var(--loading-color), 100px 0 var(--loading-color),
      0px 0 rgba(255, 255, 255, 0), 0px 0 rgba(255, 255, 255, 0);
  }

  36% {
    box-shadow: 120px 0 var(--loading-color), 110px 0 var(--loading-color),
      100px 0 var(--loading-color), 0px 0 rgba(255, 255, 255, 0);
  }

  50% {
    box-shadow: 130px 0 var(--loading-color), 120px 0 var(--loading-color),
      110px 0 var(--loading-color), 100px 0 var(--loading-color);
  }

  62% {
    box-shadow: 200px 0 rgba(255, 255, 255, 0), 130px 0 var(--loading-color),
      120px 0 var(--loading-color), 110px 0 var(--loading-color);
  }

  75% {
    box-shadow: 200px 0 rgba(255, 255, 255, 0), 200px 0 rgba(255, 255, 255, 0),
      130px 0 var(--loading-color), 120px 0 var(--loading-color);
  }

  87% {
    box-shadow: 200px 0 rgba(255, 255, 255, 0), 200px 0 rgba(255, 255, 255, 0),
      200px 0 rgba(255, 255, 255, 0), 130px 0 var(--loading-color);
  }

  100% {
    box-shadow: 200px 0 rgba(255, 255, 255, 0), 200px 0 rgba(255, 255, 255, 0),
      200px 0 rgba(255, 255, 255, 0), 200px 0 rgba(255, 255, 255, 0);
  }
}

.immersive-translate-toast {
  display: flex;
  position: fixed;
  z-index: 2147483647;
  left: 0;
  right: 0;
  top: 1%;
  width: fit-content;
  padding: 12px 20px;
  margin: auto;
  overflow: auto;
  background: #fef6f9;
  box-shadow: 0px 4px 10px 0px rgba(0, 10, 30, 0.06);
  font-size: 15px;
  border-radius: 8px;
  color: #333;
}

.immersive-translate-toast-content {
  display: flex;
  flex-direction: row;
  align-items: center;
}

.immersive-translate-toast-hidden {
  margin: 0 20px 0 72px;
  text-decoration: underline;
  cursor: pointer;
}

.immersive-translate-toast-close {
  color: #666666;
  font-size: 20px;
  font-weight: bold;
  padding: 0 10px;
  cursor: pointer;
}

@media screen and (max-width: 768px) {
  .immersive-translate-toast {
    top: 0;
    padding: 12px 0px 0 10px;
  }
  .immersive-translate-toast-content {
    flex-direction: column;
    text-align: center;
  }
  .immersive-translate-toast-hidden {
    margin: 10px auto;
  }
}

.immersive-translate-dialog {
  position: fixed;
  z-index: 2147483647;
  left: 0;
  top: 0;
  display: flex;
  width: 300px;
  flex-direction: column;
  align-items: center;
  font-size: 15px;
  left: 0;
  right: 0;
  top: 0;
  bottom: 0;
  margin: auto;
  height: fit-content;
  border-radius: 20px;
  background-color: #fff;
}

.immersive-translate-modal {
  display: none;
  position: fixed;
  z-index: 2147483647;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  overflow: auto;
  background-color: rgb(0, 0, 0);
  background-color: rgba(0, 0, 0, 0.4);
  font-size: 15px;
}

.immersive-translate-modal-content {
  background-color: #fefefe;
  margin: 10% auto;
  padding: 40px 24px 24px;
  border-radius: 12px;
  width: 350px;
  font-family: system-ui, -apple-system, "Segoe UI", "Roboto", "Ubuntu",
    "Cantarell", "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji",
    "Segoe UI Symbol", "Noto Color Emoji";
  position: relative;
}

@media screen and (max-width: 768px) {
  .immersive-translate-modal-content {
    margin: 25% auto !important;
  }
}

@media screen and (max-width: 480px) {
  .immersive-translate-modal-content {
    width: 80vw !important;
    margin: 20vh auto !important;
    padding: 20px 12px 12px !important;
  }

  .immersive-translate-modal-title {
    font-size: 14px !important;
  }

  .immersive-translate-modal-body {
    font-size: 13px !important;
    max-height: 60vh !important;
  }

  .immersive-translate-btn {
    font-size: 13px !important;
    padding: 8px 16px !important;
    margin: 0 4px !important;
  }

  .immersive-translate-modal-footer {
    gap: 6px !important;
    margin-top: 16px !important;
  }
}

.immersive-translate-modal .immersive-translate-modal-content-in-input {
  max-width: 500px;
}
.immersive-translate-modal-content-in-input .immersive-translate-modal-body {
  text-align: left;
  max-height: unset;
}

.immersive-translate-modal-title {
  text-align: center;
  font-size: 16px;
  font-weight: 700;
  color: #333333;
}

.immersive-translate-modal-body {
  text-align: center;
  font-size: 14px;
  font-weight: 400;
  color: #333333;
  margin-top: 24px;
  word-break: break-all;
}

@media screen and (max-width: 768px) {
  .immersive-translate-modal-body {
    max-height: 250px;
    overflow-y: auto;
  }
}

.immersive-translate-close {
  color: #666666;
  position: absolute;
  right: 16px;
  top: 16px;
  font-size: 20px;
  font-weight: bold;
}

.immersive-translate-close:hover,
.immersive-translate-close:focus {
  text-decoration: none;
  cursor: pointer;
}

.immersive-translate-modal-footer {
  display: flex;
  justify-content: center;
  flex-wrap: wrap;
  margin-top: 24px;
}

.immersive-translate-btn {
  width: fit-content;
  color: #fff;
  background-color: #ea4c89;
  border: none;
  font-size: 14px;
  margin: 0 8px;
  padding: 9px 30px;
  border-radius: 5px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: background-color 0.3s ease;
}

.immersive-translate-btn-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

.immersive-translate-btn:hover {
  background-color: #f082ac;
}
.immersive-translate-btn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}
.immersive-translate-btn:disabled:hover {
  background-color: #ea4c89;
}

.immersive-translate-link-btn {
  background-color: transparent;
  color: #ea4c89;
  border: none;
  cursor: pointer;
  height: 30px;
  line-height: 30px;
}

.immersive-translate-cancel-btn {
  /* gray color */
  background-color: rgb(89, 107, 120);
}

.immersive-translate-cancel-btn:hover {
  background-color: hsl(205, 20%, 32%);
}

.immersive-translate-action-btn {
  background-color: transparent;
  color: #ea4c89;
  border: 1px solid #ea4c89;
}

.immersive-translate-btn svg {
  margin-right: 5px;
}

.immersive-translate-link {
  cursor: pointer;
  user-select: none;
  -webkit-user-drag: none;
  text-decoration: none;
  color: #ea4c89;
  -webkit-tap-highlight-color: rgba(0, 0, 0, 0.1);
}

.immersive-translate-primary-link {
  cursor: pointer;
  user-select: none;
  -webkit-user-drag: none;
  text-decoration: none;
  color: #ea4c89;
  -webkit-tap-highlight-color: rgba(0, 0, 0, 0.1);
}

.immersive-translate-modal input[type="radio"] {
  margin: 0 6px;
  cursor: pointer;
}

.immersive-translate-modal label {
  cursor: pointer;
}

.immersive-translate-close-action {
  position: absolute;
  top: 2px;
  right: 0px;
  cursor: pointer;
}

.imt-image-status {
  background-color: rgba(0, 0, 0, 0.5) !important;
  display: flex !important;
  flex-direction: column !important;
  align-items: center !important;
  justify-content: center !important;
  border-radius: 16px !important;
}
.imt-image-status img,
.imt-image-status svg,
.imt-img-loading {
  width: 28px !important;
  height: 28px !important;
  margin: 0 0 8px 0 !important;
  min-height: 28px !important;
  min-width: 28px !important;
  position: relative !important;
}
.imt-img-loading {
  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAA4CAMAAACfWMssAAAAtFBMVEUAAAD////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////oK74hAAAAPHRSTlMABBMIDyQXHwyBfFdDMSw+OjXCb+5RG51IvV/k0rOqlGRM6KKMhdvNyZBz9MaupmxpWyj437iYd/yJVNZeuUC7AAACt0lEQVRIx53T2XKiUBCA4QYOiyCbiAsuuGBcYtxiYtT3f6/pbqoYHVFO5r+iivpo6DpAWYpqeoFfr9f90DsYAuRSWkFnPO50OgR9PwiCUFcl2GEcx+N/YBh6pvKaefHlUgZd1zVe0NbYcQjGBfzrPE8Xz8aF+71D8gG6DHFPpc4a7xFiCDuhaWgKgGIJQ3d5IMGDrpS4S5KgpIm+en9f6PlAhKby4JwEIxlYJV9h5k5nee9GoxHJ2IDSNB0dwdad1NAxDJ/uXDHYmebdk4PdbkS58CIVHdYSUHTYYRWOJblWSyu2lmy3KNFVJNBhxcuGW4YBVCbYGRZwIooipHsNqjM4FbgOQqQqSKQQU9V8xmi1QlgHqQQ6DDBvRUVCDirs+EzGDGOQTCATgtYTnbCVLgsVgRE0T1QE0qHCFAht2z6dLvJQs3Lo2FQoDxWNUiBhaP4eRgwNkI+dAjVOA/kUrIDwf3CG8NfNOE0eiFotSuo+rBiq8tD9oY4Qzc6YJw99hl1wzpQvD7ef2M8QgnOGJfJw+EltQc+oX2yn907QB22WZcvlUpd143dqQu+8pCJZuGE4xCuPXJqqcs5sNpsI93Rmzym1k4Npk+oD1SH3/a3LOK/JpUBpWfqNySxWzCfNCUITuDG5dtuphrUJ1myeIE9bIsPiKrfqTai5WZxbhtNphYx6GEIHihyGFTI69lje/rxajdh0s0msZ0zYxyPLhYCb1CyHm9Qsd2H37Y3lugVwL9kNh8Ot8cha6fUNQ8nuXi5z9/ExsAO4zQrb/ev1yrCB7lGyQzgYDGuxq1toDN/JGvN+HyWNHKB7zEoK+PX11e12G431erGYzwmytAWU56fkMHY5JJnDRR2eZji3AwtIcrEV8Cojat/BdQ7XOwGV1e1hDjGGjXbdArm8uJZtCH5MbcctVX8A1WpqumJHwckAAAAASUVORK5CYII=");
  background-size: 28px 28px;
  animation: image-loading-rotate 1s linear infinite !important;
}

.imt-image-status span {
  color: var(--bg-2, #fff) !important;
  font-size: 14px !important;
  line-height: 14px !important;
  font-weight: 500 !important;
  font-family: "PingFang SC", Arial, sans-serif !important;
}

.imt-primary-button {
  display: flex;
  padding: 12px 80px;
  justify-content: center;
  align-items: center;
  gap: 8px;
  border-radius: 8px;
  background: #ea4c89;
  color: #fff;
  font-size: 16px;
  font-style: normal;
  font-weight: 700;
  line-height: 24px;
  border: none;
  cursor: pointer;
}

.imt-retry-text {
  color: #999;
  text-align: center;
  font-size: 14px;
  font-style: normal;
  font-weight: 400;
  line-height: 21px;
  cursor: pointer;
}

.imt-action-container {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.imt-modal-content-text {
  text-align: left;
  color: #333;
  font-size: 16px;
  font-weight: 400;
  line-height: 24px;
}

@keyframes image-loading-rotate {
  from {
    transform: rotate(360deg);
  }
  to {
    transform: rotate(0deg);
  }
}

.imt-linear-gradient-text {
  background: linear-gradient(90deg, #00a6ff 0%, #c369ff 52.4%, #ff4590 100%);
  background-clip: text;
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

.imt-flex-center {
  display: flex;
  align-items: center;
  justify-content: center;
}

.imt-linear-black-btn {
  border-radius: 50px;
  background: linear-gradient(66deg, #222 19%, #696969 94.25%);
  height: 48px;
  width: 100%;
  color: #fff;
  font-size: 16px;
  font-weight: 700;
  display: flex;
  align-items: center;
  cursor: pointer;
  justify-content: center;
}
</style><style>pre { white-space: pre-wrap; }* { font-size: 100%; font-family: monospace; }</style><style>* { font-size: 100%; font-family: monospace; background: rgb(255, 255, 255); color: rgb(0, 0, 51); }pre { white-space: pre-wrap; }a:link { color: rgb(0, 0, 255); text-decoration: none; }a:visited { color: rgb(136, 0, 136); }.q { color: rgb(0, 0, 102); }.add { color: rgb(0, 102, 0); }.del { color: rgb(153, 0, 0); }.head { color: rgb(0, 0, 0); }.hunk { color: rgb(153, 102, 0); }.hl.num { color: rgb(255, 51, 0); }.hl.esc { color: rgb(255, 0, 255); }.hl.str { color: rgb(255, 51, 0); }.hl.ppc { color: rgb(204, 51, 204); }.hl.pps { color: rgb(255, 51, 0); }.hl.slc { color: rgb(0, 153, 153); }.hl.com { color: rgb(0, 153, 153); }.hl.kwa { color: rgb(255, 153, 0); }.hl.kwb { color: rgb(0, 102, 0); }.hl.kwc { color: rgb(255, 153, 0); }</style><style>* { font-size: 100%; font-family: monospace; background: rgb(0, 0, 0); color: rgb(204, 204, 204); }pre { white-space: pre-wrap; }a:link { color: rgb(102, 153, 255); text-decoration: none; }a:visited { color: rgb(153, 102, 255); }.q { color: rgb(0, 153, 255); }.add { color: rgb(0, 255, 255); }.del { color: rgb(255, 0, 255); }.head { color: rgb(255, 255, 255); }.hunk { color: rgb(204, 153, 51); }.hl.num { color: rgb(255, 51, 0); }.hl.esc { color: rgb(255, 0, 255); }.hl.str { color: rgb(255, 51, 0); }.hl.ppc { color: rgb(255, 0, 255); }.hl.pps { color: rgb(255, 51, 0); }.hl.slc { color: rgb(0, 153, 255); }.hl.com { color: rgb(0, 153, 255); }.hl.kwa { color: rgb(255, 255, 0); }.hl.kwb { color: rgb(0, 255, 0); }.hl.kwc { color: rgb(255, 255, 0); }</style></head><body><form action="../../"><pre><a href="../../?t=20260129020106"><b>qemu-devel.nongnu.org archive mirror</b></a>
<input name="q" type="text"><input type="submit" value="search"> <a href="../../_/text/help/">help</a> / <a href="../../_/text/color/">color</a> / <a id="mirror" href="../../_/text/mirror/">mirror</a> / <a href="../../new.atom">Atom feed</a></pre></form><pre><a href="#e73ac81ff33885a502d30d54b8cea4dcbaa767349" id="m73ac81ff33885a502d30d54b8cea4dcbaa767349">*</a> <b><u id="u">[RFC PATCH v1 0/2] tests/qtest: Add RISC-V IOMMU bare-metal test using iommu-testdev</u></b>
<b>@ 2026-01-28 12:09 Chao Liu</b>
  2026-01-28 12:09 ` <a href="#m9559a467360037b0fb0cd48d1cbad2b91a076885">[RFC PATCH v1 1/2] tests/qtest/libqos: Add RISC-V IOMMU helper library</a> Chao Liu
                   ` <a href="#r9559a467360037b0fb0cd48d1cbad2b91a076885">(3 more replies)</a>
  <a href="#r73ac81ff33885a502d30d54b8cea4dcbaa767349">0 siblings, 4 replies; 13+ messages in thread</a>
From: Chao Liu @ 2026-01-28 12:09 UTC (<a href="../../cover.1769600111.git.chao.liu.zevorn@gmail.com/">permalink</a> / <a href="../../cover.1769600111.git.chao.liu.zevorn@gmail.com/raw">raw</a>)
  To: Alistair Francis, Daniel Henrique Barboza, Palmer Dabbelt,
	Weiwei Li, Liu Zhiwei, Fabiano Rosas, Laurent Vivier,
	Paolo Bonzini, Tao Tang
  Cc: <a href="../../../qemu-devel/?t=20260128121436">qemu-devel</a>, <a href="../../../qemu-riscv/?t=20260128121436">qemu-riscv</a>, hust-os-kernel-patches, Chao Liu

Hi,

This patch series adds a bare-metal qtest for the RISC-V IOMMU using the
iommu-testdev framework. The test exercises address translation paths
without requiring a full guest OS boot.

Motivation
----------

The existing RISC-V IOMMU qtest (riscv-iommu-test.c) focuses on PCI device
enumeration and register-level validation:
- PCI configuration space verification (vendor/device ID)
- Register reset value checks
- Queue initialization procedures (CQ/FQ/PQ)

However, it does not test the actual address translation functionality.
This new test fills that gap by using iommu-testdev to trigger DMA
transactions and validate the IOMMU's translation logic.

Comparison with Existing Test
-----------------------------

| Feature               | riscv-iommu-test.c | iommu-riscv-test.c (new) |
|-----------------------|--------------------|--------------------------|
| PCI config            | Yes                | No                       |
| Register reset        | Yes                | No                       |
| Queue init            | Yes                | Yes (via helper)         |
| Bare translation      | No                 | Yes                      |
| S-stage (SV39)        | No                 | Yes                      |
| G-stage (SV39x4)      | No                 | Yes                      |
| Nested translation    | No                 | Yes                      |
| DMA verification      | No                 | Yes                      |
| Uses iommu-testdev    | No                 | Yes                      |

The new test provides:
- Device context (DC) configuration and validation
- SV39 page table walks for S-stage translation
- SV39x4 page table walks for G-stage translation
- Nested translation combining both stages
- FCTL register constraint validation
- End-to-end DMA verification

Note: The current implementation only supports SV39/SV39x4. Support for
SV48/SV48x4/SV57/SV57x4 can be added in future patches.

Testing
-------

QTEST_QEMU_BINARY=./build/qemu-system-riscv64 \n  ./build/tests/qtest/iommu-riscv-test --tap -k

Question for Maintainers
------------------------

The existing riscv-iommu-test.c and the new iommu-riscv-test.c serve
complementary purposes. Would it be beneficial to merge these two tests
into a single source file for easier maintenance? This would consolidate
all RISC-V IOMMU testing in one place while preserving both the
register-level and translation-level test coverage.

Thanks,
Chao

Chao Liu (2):
  tests/qtest/libqos: Add RISC-V IOMMU helper library
  tests/qtest: Add RISC-V IOMMU bare-metal test

 MAINTAINERS                          |   2 +
 tests/qtest/iommu-riscv-test.c       | 279 +++++++++++++++++++
 tests/qtest/libqos/meson.build       |   2 +-
 tests/qtest/libqos/qos-riscv-iommu.c | 400 +++++++++++++++++++++++++++
 tests/qtest/libqos/qos-riscv-iommu.h | 172 ++++++++++++
 tests/qtest/meson.build              |   5 +-
 6 files changed, 858 insertions(+), 2 deletions(-)
 create mode 100644 tests/qtest/iommu-riscv-test.c
 create mode 100644 tests/qtest/libqos/qos-riscv-iommu.c
 create mode 100644 tests/qtest/libqos/qos-riscv-iommu.h

--
2.52.0



<a href="#m73ac81ff33885a502d30d54b8cea4dcbaa767349" id="e73ac81ff33885a502d30d54b8cea4dcbaa767349">^</a> <a href="../../cover.1769600111.git.chao.liu.zevorn@gmail.com/">permalink</a> <a href="../../cover.1769600111.git.chao.liu.zevorn@gmail.com/raw">raw</a> <a href="../../cover.1769600111.git.chao.liu.zevorn@gmail.com/#R">reply</a>	[<a href="../../cover.1769600111.git.chao.liu.zevorn@gmail.com/T/#u"><b>flat</b></a>|<a href="../../cover.1769600111.git.chao.liu.zevorn@gmail.com/t/#u">nested</a>] <a href="#r73ac81ff33885a502d30d54b8cea4dcbaa767349">13+ messages in thread</a></pre><hr><pre><a href="#e9559a467360037b0fb0cd48d1cbad2b91a076885" id="m9559a467360037b0fb0cd48d1cbad2b91a076885">*</a> <b>[RFC PATCH v1 1/2] tests/qtest/libqos: Add RISC-V IOMMU helper library</b>
  2026-01-28 12:09 <a href="#m73ac81ff33885a502d30d54b8cea4dcbaa767349">[RFC PATCH v1 0/2] tests/qtest: Add RISC-V IOMMU bare-metal test using iommu-testdev</a> Chao Liu
<b>@ 2026-01-28 12:09 ` Chao Liu</b>
  2026-01-28 14:30   ` <a href="#mcb58b9919dda00cefe12d0ce47612540c7bdda90">Daniel Henrique Barboza</a>
                     ` <a href="#rcb58b9919dda00cefe12d0ce47612540c7bdda90">(2 more replies)</a>
  2026-01-28 12:09 ` <a href="#m351dceb4c1fd03d15423922990cc16cc7f3f55d9">[RFC PATCH v1 2/2] tests/qtest: Add RISC-V IOMMU bare-metal test</a> Chao Liu
                   ` <a href="#r351dceb4c1fd03d15423922990cc16cc7f3f55d9">(2 subsequent siblings)</a>
  <a href="#r9559a467360037b0fb0cd48d1cbad2b91a076885">3 siblings, 3 replies; 13+ messages in thread</a>
From: Chao Liu @ 2026-01-28 12:09 UTC (<a href="../../bf2b4f9cfe1484b0cde5540f518f74f9fc878c8d.1769600111.git.chao.liu.zevorn@gmail.com/">permalink</a> / <a href="../../bf2b4f9cfe1484b0cde5540f518f74f9fc878c8d.1769600111.git.chao.liu.zevorn@gmail.com/raw">raw</a>)
  To: Alistair Francis, Daniel Henrique Barboza, Palmer Dabbelt,
	Weiwei Li, Liu Zhiwei, Fabiano Rosas, Laurent Vivier,
	Paolo Bonzini, Tao Tang
  Cc: <a href="../../../qemu-devel/?t=20260128121436">qemu-devel</a>, <a href="../../../qemu-riscv/?t=20260128121436">qemu-riscv</a>, hust-os-kernel-patches, Chao Liu

Introduce a libqos helper module for RISC-V IOMMU testing with
iommu-testdev. The helper provides routines to:

- Build device contexts (DC) and 3-level page tables for SV39/SV39x4
- Program command queue (CQ), fault queue (FQ), and DDTP registers
  following the RISC-V IOMMU specification
- Execute DMA translations and verify results

The current implementation supports SV39 for S-stage and SV39x4 for
G-stage translation. Support for SV48/SV48x4/SV57/SV57x4 can be added
in future patches.

Signed-off-by: Chao Liu &lt;chao.liu.zevorn@gmail.com&gt;
---
 <a id="iZ2e.:..:bf2b4f9cfe1484b0cde5540f518f74f9fc878c8d.1769600111.git.chao.liu.zevorn::40gmail.com:1MAINTAINERS" href="#Z2e.:..:bf2b4f9cfe1484b0cde5540f518f74f9fc878c8d.1769600111.git.chao.liu.zevorn::40gmail.com:1MAINTAINERS">MAINTAINERS</a>                          |   1 +
 <a id="iZ2e.:..:bf2b4f9cfe1484b0cde5540f518f74f9fc878c8d.1769600111.git.chao.liu.zevorn::40gmail.com:1tests:qtest:libqos:meson.build" href="#Z2e.:..:bf2b4f9cfe1484b0cde5540f518f74f9fc878c8d.1769600111.git.chao.liu.zevorn::40gmail.com:1tests:qtest:libqos:meson.build">tests/qtest/libqos/meson.build</a>       |   2 +-
 <a id="iZ2e.:..:bf2b4f9cfe1484b0cde5540f518f74f9fc878c8d.1769600111.git.chao.liu.zevorn::40gmail.com:1tests:qtest:libqos:qos-riscv-iommu.c" href="#Z2e.:..:bf2b4f9cfe1484b0cde5540f518f74f9fc878c8d.1769600111.git.chao.liu.zevorn::40gmail.com:1tests:qtest:libqos:qos-riscv-iommu.c">tests/qtest/libqos/qos-riscv-iommu.c</a> | 400 +++++++++++++++++++++++++++
 <a id="iZ2e.:..:bf2b4f9cfe1484b0cde5540f518f74f9fc878c8d.1769600111.git.chao.liu.zevorn::40gmail.com:1tests:qtest:libqos:qos-riscv-iommu.h" href="#Z2e.:..:bf2b4f9cfe1484b0cde5540f518f74f9fc878c8d.1769600111.git.chao.liu.zevorn::40gmail.com:1tests:qtest:libqos:qos-riscv-iommu.h">tests/qtest/libqos/qos-riscv-iommu.h</a> | 172 ++++++++++++
 4 files <a href="#e9559a467360037b0fb0cd48d1cbad2b91a076885">changed</a>, 574 insertions(+), 1 deletion(-)
 create mode 100644 tests/qtest/libqos/qos-riscv-iommu.c
 create mode 100644 tests/qtest/libqos/qos-riscv-iommu.h

<span class="head"><a href="#iZ2e.:..:bf2b4f9cfe1484b0cde5540f518f74f9fc878c8d.1769600111.git.chao.liu.zevorn::40gmail.com:1MAINTAINERS" id="Z2e.:..:bf2b4f9cfe1484b0cde5540f518f74f9fc878c8d.1769600111.git.chao.liu.zevorn::40gmail.com:1MAINTAINERS">diff</a> --git a/MAINTAINERS b/MAINTAINERS
index dc31be033e..894e05bd2c 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
</span><span class="hunk">@@ -3583,6 +3583,7 @@ M: Tao Tang &lt;tangtao1634@phytium.com.cn&gt;
</span> S: Maintained
 F: tests/qtest/libqos/qos-iommu*
 F: tests/qtest/libqos/qos-smmuv3*
<span class="add">+F: tests/qtest/libqos/qos-riscv-iommu*
</span> 
 Device Fuzzing
 M: Alexander Bulekov &lt;alxndr@bu.edu&gt;
<span class="head"><a href="#iZ2e.:..:bf2b4f9cfe1484b0cde5540f518f74f9fc878c8d.1769600111.git.chao.liu.zevorn::40gmail.com:1tests:qtest:libqos:meson.build" id="Z2e.:..:bf2b4f9cfe1484b0cde5540f518f74f9fc878c8d.1769600111.git.chao.liu.zevorn::40gmail.com:1tests:qtest:libqos:meson.build">diff</a> --git a/tests/qtest/libqos/meson.build b/tests/qtest/libqos/meson.build
index b4daec808f..4a69acad0d 100644
--- a/tests/qtest/libqos/meson.build
+++ b/tests/qtest/libqos/meson.build
</span><span class="hunk">@@ -71,7 +71,7 @@ if have_virtfs
</span> endif
 
 if config_all_devices.has_key('CONFIG_RISCV_IOMMU')
<span class="del">-  libqos_srcs += files('riscv-iommu.c')
</span><span class="add">+  libqos_srcs += files('riscv-iommu.c', 'qos-riscv-iommu.c')
</span> endif
 if config_all_devices.has_key('CONFIG_TPCI200')
   libqos_srcs += files('tpci200.c')
<span class="head"><a href="#iZ2e.:..:bf2b4f9cfe1484b0cde5540f518f74f9fc878c8d.1769600111.git.chao.liu.zevorn::40gmail.com:1tests:qtest:libqos:qos-riscv-iommu.c" id="Z2e.:..:bf2b4f9cfe1484b0cde5540f518f74f9fc878c8d.1769600111.git.chao.liu.zevorn::40gmail.com:1tests:qtest:libqos:qos-riscv-iommu.c">diff</a> --git a/tests/qtest/libqos/qos-riscv-iommu.c b/tests/qtest/libqos/qos-riscv-iommu.c
new file mode 100644
index 0000000000..34ed3df84a
--- /dev/null
+++ b/tests/qtest/libqos/qos-riscv-iommu.c
</span><span class="hunk">@@ -0,0 +1,400 @@
</span><span class="add">+/*
+ * QOS RISC-V IOMMU Module
+ *
+ * This module provides RISC-V IOMMU-specific helper functions for libqos tests,
+ * encapsulating RISC-V IOMMU setup, and assertions.
+ *
+ * Copyright (c) 2026 Chao Liu &lt;chao.liu.zevorn@gmail.com&gt;
+ *
+ * SPDX-License-Identifier: GPL-2.0-or-later
+ */
+
+#include "qemu/osdep.h"
+#include "qemu/bitops.h"
+#include "hw/riscv/riscv-iommu-bits.h"
+#include "tests/qtest/libqos/pci.h"
+#include "qos-iommu-testdev.h"
+#include "qos-riscv-iommu.h"
+
+/* Apply space offset to address */
+static inline uint64_t qriommu_apply_space_offs(uint64_t address)
+{
+    return address + QRIOMMU_SPACE_OFFS;
+}
+
+static uint64_t qriommu_encode_pte(uint64_t pa, uint64_t attrs)
+{
+    return ((pa &gt;&gt; 12) &lt;&lt; 10) | attrs;
+}
+
+static void qriommu_wait_for_queue_active(QTestState *qts, uint64_t iommu_base,
+                                          uint32_t queue_csr, uint32_t on_bit)
+{
+    guint64 timeout_us = 2 * 1000 * 1000;
+    gint64 start_time = g_get_monotonic_time();
+    uint32_t reg;
+
+    for (;;) {
+        qtest_clock_step(qts, 100);
+
+        reg = qtest_readl(qts, iommu_base + queue_csr);
+        if (reg &amp; on_bit) {
+            return;
+        }
+        g_assert(g_get_monotonic_time() - start_time &lt;= timeout_us);
+    }
+}
+
+uint32_t qriommu_expected_dma_result(QRIOMMUTestContext *ctx)
+{
+    return ctx-&gt;config.expected_result;
+}
+
+uint32_t qriommu_build_dma_attrs(void)
+{
+    /* RISC-V IOMMU uses standard AXI attributes */
+    return 0;
+}
+
+uint32_t qriommu_setup_and_enable_translation(QRIOMMUTestContext *ctx)
+{
+    uint32_t build_result;
+
+    /* Build page tables and RISC-V IOMMU structures first */
+    build_result = qriommu_build_translation(
+                       ctx-&gt;qts, ctx-&gt;config.trans_mode,
+                       ctx-&gt;device_id);
+    if (build_result != 0) {
+        g_test_message("Build failed: mode=%u device_id=%u status=0x%x",
+                       ctx-&gt;config.trans_mode, ctx-&gt;device_id, build_result);
+        ctx-&gt;trans_status = build_result;
+        return ctx-&gt;trans_status;
+    }
+
+    /* Program RISC-V IOMMU registers */
+    qriommu_program_regs(ctx-&gt;qts, ctx-&gt;iommu_base);
+
+    ctx-&gt;trans_status = 0;
+    return ctx-&gt;trans_status;
+}
+
+static bool qriommu_validate_test_result(QRIOMMUTestContext *ctx)
+{
+    uint32_t expected = qriommu_expected_dma_result(ctx);
+    g_test_message("-&gt; Validating result: expected=0x%x actual=0x%x",
+                   expected, ctx-&gt;dma_result);
+    return (ctx-&gt;dma_result == expected);
+}
+
+static uint32_t qriommu_single_translation_setup(void *opaque)
+{
+    return qriommu_setup_and_enable_translation(opaque);
+}
+
+static uint32_t qriommu_single_translation_attrs(void *opaque)
+{
+    return qriommu_build_dma_attrs();
+}
+
+static bool qriommu_single_translation_validate(void *opaque)
+{
+    return qriommu_validate_test_result(opaque);
+}
+
+static void qriommu_single_translation_report(void *opaque,
+                                              uint32_t dma_result)
+{
+    QRIOMMUTestContext *ctx = opaque;
+
+    if (dma_result != 0) {
+        g_test_message("DMA failed: mode=%u result=0x%x",
+                       ctx-&gt;config.trans_mode, dma_result);
+    } else {
+        g_test_message("-&gt; DMA succeeded: mode=%u",
+                       ctx-&gt;config.trans_mode);
+    }
+}
+
+void qriommu_run_translation_case(QTestState *qts, QPCIDevice *dev,
+                                  QPCIBar bar, uint64_t iommu_base,
+                                  const QRIOMMUTestConfig *cfg)
+{
+    QRIOMMUTestContext ctx = {
+        .qts = qts,
+        .dev = dev,
+        .bar = bar,
+        .iommu_base = iommu_base,
+        .config = *cfg,
+        .device_id = dev-&gt;devfn,
+    };
+
+    QOSIOMMUTestdevDmaCfg dma = {
+        .dev = dev,
+        .bar = bar,
+        .iova = QRIOMMU_IOVA,
+        .gpa = ctx.config.dma_gpa,
+        .len = ctx.config.dma_len,
+    };
+
+    qtest_memset(qts, cfg-&gt;dma_gpa, 0x00, cfg-&gt;dma_len);
+    qos_iommu_testdev_single_translation(&amp;dma, &amp;ctx,
+                                         qriommu_single_translation_setup,
+                                         qriommu_single_translation_attrs,
+                                         qriommu_single_translation_validate,
+                                         qriommu_single_translation_report,
+                                         &amp;ctx.dma_result);
+
+    if (ctx.dma_result == 0 &amp;&amp; ctx.config.expected_result == 0) {
+        g_autofree uint8_t *buf = NULL;
+
+        buf = g_malloc(ctx.config.dma_len);
+        qtest_memread(ctx.qts, ctx.config.dma_gpa, buf, ctx.config.dma_len);
+
+        for (int i = 0; i &lt; ctx.config.dma_len; i++) {
+            uint8_t expected;
+
+            expected = (ITD_DMA_WRITE_VAL &gt;&gt; ((i % 4) * 8)) &amp; 0xff;
+            g_assert_cmpuint(buf[i], ==, expected);
+        }
+    }
+}
+
+static uint32_t qriommu_get_table_index(uint64_t addr, int level)
+{
+    /* SV39: 39-bit virtual address, 3-level page table */
+    switch (level) {
+    case 0:
+        return (addr &gt;&gt; 30) &amp; 0x1ff;   /* L0: bits [38:30] */
+    case 1:
+        return (addr &gt;&gt; 21) &amp; 0x1ff;   /* L1: bits [29:21] */
+    case 2:
+        return (addr &gt;&gt; 12) &amp; 0x1ff;   /* L2: bits [20:12] */
+    default:
+        g_assert_not_reached();
+    }
+}
+
+static uint64_t qriommu_get_table_addr(uint64_t base, int level, uint64_t iova)
+{
+    uint32_t index = qriommu_get_table_index(iova, level);
+    return (base &amp; QRIOMMU_PTE_PPN_MASK) + (index * 8);
+}
+
+static void qriommu_map_leaf(QTestState *qts, uint64_t root_pa,
+                             uint64_t l0_pa, uint64_t l1_pa,
+                             uint64_t l0_pte_val, uint64_t l1_pte_val,
+                             uint64_t va, uint64_t pa, uint64_t leaf_attrs)
+{
+    uint64_t l0_addr = qriommu_get_table_addr(root_pa, 0, va);
+    uint64_t l1_addr = qriommu_get_table_addr(l0_pa, 1, va);
+    uint64_t l2_addr = qriommu_get_table_addr(l1_pa, 2, va);
+
+    qtest_writeq(qts, l0_addr, l0_pte_val);
+    qtest_writeq(qts, l1_addr, l1_pte_val);
+    qtest_writeq(qts, l2_addr, qriommu_encode_pte(pa, leaf_attrs));
+}
+
+static uint64_t qriommu_get_pte_attrs(QRIOMMUTransMode mode, bool is_leaf)
+{
+    if (!is_leaf) {
+        return QRIOMMU_NON_LEAF_PTE_MASK;
+    }
+
+    /* For leaf PTE, set RWX permissions */
+    return QRIOMMU_LEAF_PTE_RW_MASK;
+}
+
+void qriommu_setup_translation_tables(QTestState *qts,
+                                      uint64_t iova,
+                                      QRIOMMUTransMode mode)
+{
+    uint64_t s_root = 0, s_l0_pte_val = 0, s_l1_pte_val = 0;
+    uint64_t s_l0_addr = 0, s_l1_addr = 0, s_l2_addr = 0, s_l2_pte_val = 0;
+    uint64_t s_l0_pa = 0, s_l1_pa = 0;
+    uint64_t s_l2_pa = qriommu_apply_space_offs(QRIOMMU_L2_PTE_VAL);
+    uint64_t s_l0_pa_real = 0, s_l1_pa_real = 0;
+    uint64_t s_l2_pa_real = qriommu_apply_space_offs(QRIOMMU_L2_PTE_VAL);
+    uint64_t non_leaf_attrs = qriommu_get_pte_attrs(mode, false);
+    uint64_t leaf_attrs = qriommu_get_pte_attrs(mode, true);
+
+    if (mode != QRIOMMU_TM_G_STAGE_ONLY) {
+        /* Setup S-stage 3-level page tables (SV39) */
+        s_l0_pa = qriommu_apply_space_offs(QRIOMMU_L0_PTE_VAL);
+        s_l1_pa = qriommu_apply_space_offs(QRIOMMU_L1_PTE_VAL);
+        s_root = qriommu_apply_space_offs(
+            QRIOMMU_IOHGATP &amp; QRIOMMU_PTE_PPN_MASK);
+        s_l2_pa = qriommu_apply_space_offs(QRIOMMU_L2_PTE_VAL);
+
+        s_l0_pa_real = s_l0_pa;
+        s_l1_pa_real = s_l1_pa;
+        s_l2_pa_real = s_l2_pa;
+
+        if (mode == QRIOMMU_TM_NESTED) {
+            s_l0_pa = QRIOMMU_L0_PTE_VAL;
+            s_l1_pa = QRIOMMU_L1_PTE_VAL;
+            s_l2_pa = QRIOMMU_L2_PTE_VAL;
+
+            s_l0_pa_real = qriommu_apply_space_offs(QRIOMMU_L0_PTE_VAL);
+            s_l1_pa_real = qriommu_apply_space_offs(QRIOMMU_L1_PTE_VAL);
+            s_l2_pa_real = qriommu_apply_space_offs(QRIOMMU_L2_PTE_VAL);
+        }
+
+        s_l0_pte_val = qriommu_encode_pte(s_l0_pa, non_leaf_attrs);
+        s_l1_pte_val = qriommu_encode_pte(s_l1_pa, non_leaf_attrs);
+
+        s_l0_addr = qriommu_get_table_addr(s_root, 0, iova);
+        qtest_writeq(qts, s_l0_addr, s_l0_pte_val);
+
+        s_l1_addr = qriommu_get_table_addr(s_l0_pa_real, 1, iova);
+        qtest_writeq(qts, s_l1_addr, s_l1_pte_val);
+
+        s_l2_addr = qriommu_get_table_addr(s_l1_pa_real, 2, iova);
+        s_l2_pte_val = qriommu_encode_pte(s_l2_pa, leaf_attrs);
+        qtest_writeq(qts, s_l2_addr, s_l2_pte_val);
+    }
+
+    if (mode == QRIOMMU_TM_G_STAGE_ONLY || mode == QRIOMMU_TM_NESTED) {
+        uint64_t g_root = qriommu_apply_space_offs(
+            QRIOMMU_G_IOHGATP &amp; QRIOMMU_PTE_PPN_MASK);
+        uint64_t g_l0_pa = qriommu_apply_space_offs(QRIOMMU_G_L0_PTE_VAL);
+        uint64_t g_l1_pa = qriommu_apply_space_offs(QRIOMMU_G_L1_PTE_VAL);
+        uint64_t g_l0_pte_val = qriommu_encode_pte(g_l0_pa, non_leaf_attrs);
+        uint64_t g_l1_pte_val = qriommu_encode_pte(g_l1_pa, non_leaf_attrs);
+
+        if (mode == QRIOMMU_TM_G_STAGE_ONLY) {
+            qriommu_map_leaf(qts, g_root, g_l0_pa, g_l1_pa,
+                             g_l0_pte_val, g_l1_pte_val,
+                             iova, s_l2_pa_real, leaf_attrs);
+        } else {
+            qriommu_map_leaf(qts, g_root, g_l0_pa, g_l1_pa,
+                             g_l0_pte_val, g_l1_pte_val,
+                             QRIOMMU_IOHGATP, s_root, leaf_attrs);
+            qriommu_map_leaf(qts, g_root, g_l0_pa, g_l1_pa,
+                             g_l0_pte_val, g_l1_pte_val,
+                             QRIOMMU_L0_PTE_VAL, s_l0_pa_real, leaf_attrs);
+            qriommu_map_leaf(qts, g_root, g_l0_pa, g_l1_pa,
+                             g_l0_pte_val, g_l1_pte_val,
+                             QRIOMMU_L1_PTE_VAL, s_l1_pa_real, leaf_attrs);
+            qriommu_map_leaf(qts, g_root, g_l0_pa, g_l1_pa,
+                             g_l0_pte_val, g_l1_pte_val,
+                             QRIOMMU_L2_PTE_VAL, s_l2_pa_real, leaf_attrs);
+        }
+    }
+}
+
+uint32_t qriommu_build_translation(QTestState *qts, QRIOMMUTransMode mode,
+                                   uint32_t device_id)
+{
+    uint64_t dc_addr, dc_addr_real;
+    struct riscv_iommu_dc dc;
+    uint64_t iohgatp;
+
+    qtest_memset(qts, qriommu_apply_space_offs(QRIOMMU_DDT_BASE), 0, 0x1000);
+
+    dc_addr = device_id * sizeof(struct riscv_iommu_dc) + QRIOMMU_DC_BASE;
+    dc_addr_real = qriommu_apply_space_offs(dc_addr);
+
+    /* Build Device Context (DC) */
+    memset(&amp;dc, 0, sizeof(dc));
+
+    switch (mode) {
+    case QRIOMMU_TM_BARE:
+        /* Pass-through mode: tc.V=1, no FSC/IOHGATP */
+        dc.tc = RISCV_IOMMU_DC_TC_V;
+        break;
+
+    case QRIOMMU_TM_S_STAGE_ONLY:
+        /* S-stage only: tc.V=1, set FSC */
+        dc.tc = RISCV_IOMMU_DC_TC_V;
+        iohgatp = qriommu_apply_space_offs(QRIOMMU_IOHGATP);
+        /* FSC mode: SV39 (mode=8) */
+        dc.fsc = (iohgatp &gt;&gt; 12) | (8ull &lt;&lt; 60);
+        break;
+
+    case QRIOMMU_TM_G_STAGE_ONLY:
+        /* G-stage only: tc.V=1, set IOHGATP */
+        dc.tc = RISCV_IOMMU_DC_TC_V;
+        iohgatp = qriommu_apply_space_offs(QRIOMMU_G_IOHGATP);
+        /* IOHGATP mode: SV39x4 (mode=8) */
+        dc.iohgatp = (iohgatp &gt;&gt; 12) | (8ull &lt;&lt; 60);
+        break;
+
+    case QRIOMMU_TM_NESTED:
+        /* Nested: tc.V=1, set both FSC and IOHGATP */
+        dc.tc = RISCV_IOMMU_DC_TC_V;
+        /* FSC mode: SV39 (mode=8) */
+        dc.fsc = (QRIOMMU_IOHGATP &gt;&gt; 12) | (8ull &lt;&lt; 60);
+        /* IOHGATP mode: SV39x4 (mode=8) */
+        iohgatp = qriommu_apply_space_offs(QRIOMMU_G_IOHGATP);
+        dc.iohgatp = (iohgatp &gt;&gt; 12) | (8ull &lt;&lt; 60);
+        break;
+
+    default:
+        g_assert_not_reached();
+    }
+
+    /* Write DC to memory */
+    qtest_writeq(qts, dc_addr_real + 0,  dc.tc);
+    qtest_writeq(qts, dc_addr_real + 8,  dc.iohgatp);
+    qtest_writeq(qts, dc_addr_real + 16, dc.ta);
+    qtest_writeq(qts, dc_addr_real + 24, dc.fsc);
+    qtest_writeq(qts, dc_addr_real + 32, dc.msiptp);
+    qtest_writeq(qts, dc_addr_real + 40, dc.msi_addr_mask);
+    qtest_writeq(qts, dc_addr_real + 48, dc.msi_addr_pattern);
+    qtest_writeq(qts, dc_addr_real + 56, dc._reserved);
+
+    /* Setup translation tables if not in BARE mode */
+    if (mode != QRIOMMU_TM_BARE) {
+        qriommu_setup_translation_tables(qts, QRIOMMU_IOVA, mode);
+    }
+
+    return 0;
+}
+
+void qriommu_program_regs(QTestState *qts, uint64_t iommu_base)
+{
+    uint64_t ddtp, cqb, fqb;
+    uint64_t cq_base, fq_base;
+    uint64_t cq_align, fq_align;
+    uint32_t cq_entries = QRIOMMU_QUEUE_ENTRIES;
+    uint32_t fq_entries = QRIOMMU_QUEUE_ENTRIES;
+    uint32_t cq_log2sz = ctz32(cq_entries) - 1;
+    uint32_t fq_log2sz = ctz32(fq_entries) - 1;
+
+    cq_base = qriommu_apply_space_offs(QRIOMMU_CQ_BASE_ADDR);
+    fq_base = qriommu_apply_space_offs(QRIOMMU_FQ_BASE_ADDR);
+
+    cq_align = MAX(0x1000ull, (uint64_t)cq_entries * QRIOMMU_CQ_ENTRY_SIZE);
+    fq_align = MAX(0x1000ull, (uint64_t)fq_entries * QRIOMMU_FQ_ENTRY_SIZE);
+    g_assert((cq_base &amp; (cq_align - 1)) == 0);
+    g_assert((fq_base &amp; (fq_align - 1)) == 0);
+
+    /* Setup Command Queue */
+    cqb = (cq_base &gt;&gt; 12) &lt;&lt; 10 | cq_log2sz;
+    qtest_writeq(qts, iommu_base + RISCV_IOMMU_REG_CQB, cqb);
+    qtest_writel(qts, iommu_base + RISCV_IOMMU_REG_CQH, 0);
+    qtest_writel(qts, iommu_base + RISCV_IOMMU_REG_CQT, 0);
+    qtest_writel(qts, iommu_base + RISCV_IOMMU_REG_CQCSR,
+                 RISCV_IOMMU_CQCSR_CQEN);
+    qriommu_wait_for_queue_active(qts, iommu_base, RISCV_IOMMU_REG_CQCSR,
+                                  RISCV_IOMMU_CQCSR_CQON);
+
+    /* Setup Fault Queue */
+    fqb = (fq_base &gt;&gt; 12) &lt;&lt; 10 | fq_log2sz;
+    qtest_writeq(qts, iommu_base + RISCV_IOMMU_REG_FQB, fqb);
+    qtest_writel(qts, iommu_base + RISCV_IOMMU_REG_FQH, 0);
+    qtest_writel(qts, iommu_base + RISCV_IOMMU_REG_FQT, 0);
+    qtest_writel(qts, iommu_base + RISCV_IOMMU_REG_FQCSR,
+                 RISCV_IOMMU_FQCSR_FQEN);
+    qriommu_wait_for_queue_active(qts, iommu_base, RISCV_IOMMU_REG_FQCSR,
+                                  RISCV_IOMMU_FQCSR_FQON);
+
+    /* Set Device Directory Table Pointer (DDTP) */
+    ddtp = qriommu_apply_space_offs(QRIOMMU_DDT_BASE);
+    g_assert((ddtp &amp; 0xfff) == 0);
+    ddtp = ((ddtp &gt;&gt; 12) &lt;&lt; 10) | RISCV_IOMMU_DDTP_MODE_1LVL;
+    qtest_writeq(qts, iommu_base + RISCV_IOMMU_REG_DDTP, ddtp);
+    g_assert((qtest_readq(qts, iommu_base + RISCV_IOMMU_REG_DDTP) &amp;
+              (RISCV_IOMMU_DDTP_PPN | RISCV_IOMMU_DDTP_MODE)) ==
+             (ddtp &amp; (RISCV_IOMMU_DDTP_PPN | RISCV_IOMMU_DDTP_MODE)));
+}
</span><span class="head"><a href="#iZ2e.:..:bf2b4f9cfe1484b0cde5540f518f74f9fc878c8d.1769600111.git.chao.liu.zevorn::40gmail.com:1tests:qtest:libqos:qos-riscv-iommu.h" id="Z2e.:..:bf2b4f9cfe1484b0cde5540f518f74f9fc878c8d.1769600111.git.chao.liu.zevorn::40gmail.com:1tests:qtest:libqos:qos-riscv-iommu.h">diff</a> --git a/tests/qtest/libqos/qos-riscv-iommu.h b/tests/qtest/libqos/qos-riscv-iommu.h
new file mode 100644
index 0000000000..1f4efbf682
--- /dev/null
+++ b/tests/qtest/libqos/qos-riscv-iommu.h
</span><span class="hunk">@@ -0,0 +1,172 @@
</span><span class="add">+/*
+ * QOS RISC-V IOMMU Module
+ *
+ * This module provides RISC-V IOMMU-specific helper functions for libqos tests,
+ * encapsulating RISC-V IOMMU setup, and assertions.
+ *
+ * Copyright (c) 2026 Chao Liu &lt;chao.liu.zevorn@gmail.com&gt;
+ *
+ * SPDX-License-Identifier: GPL-2.0-or-later
+ */
+
+#ifndef QTEST_LIBQOS_RISCV_IOMMU_H
+#define QTEST_LIBQOS_RISCV_IOMMU_H
+
+#include "hw/misc/iommu-testdev.h"
+
+/* RISC-V IOMMU MMIO register base for virt machine */
+#define VIRT_RISCV_IOMMU_BASE      0x0000000003010000ull
+
+/* RISC-V IOMMU queue and table base addresses */
+#define QRIOMMU_CQ_BASE_ADDR       0x000000000e160000ull
+#define QRIOMMU_FQ_BASE_ADDR       0x000000000e170000ull
+
+/* RISC-V IOMMU queue sizing */
+#define QRIOMMU_QUEUE_ENTRIES  1024
+#define QRIOMMU_CQ_ENTRY_SIZE  16
+#define QRIOMMU_FQ_ENTRY_SIZE  32
+
+/*
+ * Translation tables and descriptors for RISC-V IOMMU.
+ * Similar to ARM SMMUv3, but using RISC-V IOMMU terminology:
+ * - Device Context (DC) instead of STE
+ * - First-stage context (FSC) for S-stage translation
+ * - IOHGATP for G-stage translation
+ *
+ * Granule size: 4KB pages
+ * Page table levels: 3 levels for SV39 (L0, L1, L2)
+ * IOVA size: 39-bit virtual address space
+ */
+#define QRIOMMU_IOVA                0x0000000080604567ull
+#define QRIOMMU_IOHGATP             0x0000000000010000ull
+#define QRIOMMU_DDT_BASE            0x0000000000014000ull
+#define QRIOMMU_DC_BASE             (QRIOMMU_DDT_BASE)
+
+#define QRIOMMU_L0_PTE_VAL          0x0000000000011000ull
+#define QRIOMMU_L1_PTE_VAL          0x0000000000012000ull
+#define QRIOMMU_L2_PTE_VAL          0x0000000000013000ull
+
+#define QRIOMMU_G_IOHGATP           0x0000000000020000ull
+#define QRIOMMU_G_L0_PTE_VAL        0x0000000000021000ull
+#define QRIOMMU_G_L1_PTE_VAL        0x0000000000022000ull
+
+/* RISC-V page table entry masks */
+#define QRIOMMU_PTE_V               0x0000000000000001ull
+#define QRIOMMU_PTE_R               0x0000000000000002ull
+#define QRIOMMU_PTE_W               0x0000000000000004ull
+#define QRIOMMU_PTE_X               0x0000000000000008ull
+#define QRIOMMU_PTE_U               0x0000000000000010ull
+#define QRIOMMU_PTE_G               0x0000000000000020ull
+#define QRIOMMU_PTE_A               0x0000000000000040ull
+#define QRIOMMU_PTE_D               0x0000000000000080ull
+
+#define QRIOMMU_NON_LEAF_PTE_MASK   (QRIOMMU_PTE_V)
+#define QRIOMMU_LEAF_PTE_RW_MASK    (QRIOMMU_PTE_V | QRIOMMU_PTE_R | \n+                                     QRIOMMU_PTE_W | QRIOMMU_PTE_A | \n+                                     QRIOMMU_PTE_D)
+#define QRIOMMU_PTE_PPN_MASK        0x003ffffffffffc00ull
+
+/* Address-space base offset for test tables */
+#define QRIOMMU_SPACE_OFFS          0x0000000080000000ull
+
+typedef enum QRIOMMUTransMode {
+    QRIOMMU_TM_BARE         = 0,    /* No translation (pass-through) */
+    QRIOMMU_TM_S_STAGE_ONLY = 1,    /* First-stage only (S-stage) */
+    QRIOMMU_TM_G_STAGE_ONLY = 2,    /* Second-stage only (G-stage) */
+    QRIOMMU_TM_NESTED       = 3,    /* Nested translation (S + G) */
+} QRIOMMUTransMode;
+
+typedef struct QRIOMMUTestConfig {
+    QRIOMMUTransMode trans_mode;    /* Translation mode */
+    uint64_t dma_gpa;               /* GPA for readback validation */
+    uint32_t dma_len;               /* DMA length for testing */
+    uint32_t expected_result;       /* Expected DMA result */
+} QRIOMMUTestConfig;
+
+typedef struct QRIOMMUTestContext {
+    QTestState *qts;                /* QTest state handle */
+    QPCIDevice *dev;                /* PCI device handle */
+    QPCIBar bar;                    /* PCI BAR for MMIO access */
+    QRIOMMUTestConfig config;       /* Test configuration */
+    uint64_t iommu_base;            /* RISC-V IOMMU base address */
+    uint32_t trans_status;          /* Translation configuration status */
+    uint32_t dma_result;            /* DMA operation result */
+    uint32_t device_id;             /* Device ID for the test */
+} QRIOMMUTestContext;
+
+/*
+ * qriommu_setup_and_enable_translation - Complete translation setup and enable
+ *
+ * @ctx: Test context containing configuration and device handles
+ *
+ * Returns: Translation status (0 = success, non-zero = error)
+ *
+ * This function performs the complete translation setup sequence:
+ * 1. Builds all required RISC-V IOMMU structures (DC, page tables)
+ * 2. Programs RISC-V IOMMU registers
+ * 3. Returns configuration status
+ */
+uint32_t qriommu_setup_and_enable_translation(QRIOMMUTestContext *ctx);
+
+/*
+ * qriommu_build_translation - Build RISC-V IOMMU translation structures
+ *
+ * @qts: QTest state handle
+ * @mode: Translation mode (BARE, S_STAGE_ONLY, G_STAGE_ONLY, NESTED)
+ * @device_id: Device ID
+ *
+ * Returns: Build status (0 = success, non-zero = error)
+ *
+ * Constructs all necessary RISC-V IOMMU translation structures in guest memory:
+ * - Device Context (DC) for the given device ID
+ * - First-stage context (FSC) if S-stage translation is involved
+ * - Complete page table hierarchy based on translation mode
+ */
+uint32_t qriommu_build_translation(QTestState *qts, QRIOMMUTransMode mode,
+                                   uint32_t device_id);
+
+/*
+ * qriommu_program_regs - Program all required RISC-V IOMMU registers
+ *
+ * @qts: QTest state handle
+ * @iommu_base: RISC-V IOMMU base address
+ *
+ * Programs RISC-V IOMMU registers:
+ * - Device Directory Table Pointer (DDTP)
+ * - Command queue (base, head, tail)
+ * - Fault queue (base, head, tail)
+ * - Control and status registers
+ */
+void qriommu_program_regs(QTestState *qts, uint64_t iommu_base);
+
+/*
+ * qriommu_setup_translation_tables - Setup RISC-V IOMMU page table hierarchy
+ *
+ * @qts: QTest state handle
+ * @iova: Input Virtual Address to translate
+ * @mode: Translation mode
+ *
+ * This function builds the complete page table structure for translating
+ * the given IOVA through the RISC-V IOMMU. The structure varies based on mode:
+ *
+ * - BARE: No translation (pass-through)
+ * - S_STAGE_ONLY: Single S-stage walk (IOVA -&gt; PA)
+ * - G_STAGE_ONLY: Single G-stage walk (IPA -&gt; PA)
+ * - NESTED: S-stage walk (IOVA -&gt; IPA) + G-stage walk (IPA -&gt; PA)
+ */
+void qriommu_setup_translation_tables(QTestState *qts,
+                                      uint64_t iova,
+                                      QRIOMMUTransMode mode);
+
+/* High-level test execution helpers */
+void qriommu_run_translation_case(QTestState *qts, QPCIDevice *dev,
+                                  QPCIBar bar, uint64_t iommu_base,
+                                  const QRIOMMUTestConfig *cfg);
+
+/* Calculate expected DMA result */
+uint32_t qriommu_expected_dma_result(QRIOMMUTestContext *ctx);
+
+/* Build DMA attributes for RISC-V IOMMU */
+uint32_t qriommu_build_dma_attrs(void);
+
+#endif /* QTEST_LIBQOS_RISCV_IOMMU_H */
</span>-- 
2.52.0



<a href="#m9559a467360037b0fb0cd48d1cbad2b91a076885" id="e9559a467360037b0fb0cd48d1cbad2b91a076885">^</a> <a href="../../bf2b4f9cfe1484b0cde5540f518f74f9fc878c8d.1769600111.git.chao.liu.zevorn@gmail.com/">permalink</a> <a href="../../bf2b4f9cfe1484b0cde5540f518f74f9fc878c8d.1769600111.git.chao.liu.zevorn@gmail.com/raw">raw</a> <a href="../../bf2b4f9cfe1484b0cde5540f518f74f9fc878c8d.1769600111.git.chao.liu.zevorn@gmail.com/#R">reply</a> <a href="../../bf2b4f9cfe1484b0cde5540f518f74f9fc878c8d.1769600111.git.chao.liu.zevorn@gmail.com/#related">related</a>	[<a href="../../bf2b4f9cfe1484b0cde5540f518f74f9fc878c8d.1769600111.git.chao.liu.zevorn@gmail.com/T/#u"><b>flat</b></a>|<a href="../../bf2b4f9cfe1484b0cde5540f518f74f9fc878c8d.1769600111.git.chao.liu.zevorn@gmail.com/t/#u">nested</a>] <a href="#r9559a467360037b0fb0cd48d1cbad2b91a076885">13+ messages in thread</a></pre><hr><pre><a href="#e351dceb4c1fd03d15423922990cc16cc7f3f55d9" id="m351dceb4c1fd03d15423922990cc16cc7f3f55d9">*</a> <b>[RFC PATCH v1 2/2] tests/qtest: Add RISC-V IOMMU bare-metal test</b>
  2026-01-28 12:09 <a href="#m73ac81ff33885a502d30d54b8cea4dcbaa767349">[RFC PATCH v1 0/2] tests/qtest: Add RISC-V IOMMU bare-metal test using iommu-testdev</a> Chao Liu
  2026-01-28 12:09 ` <a href="#m9559a467360037b0fb0cd48d1cbad2b91a076885">[RFC PATCH v1 1/2] tests/qtest/libqos: Add RISC-V IOMMU helper library</a> Chao Liu
<b>@ 2026-01-28 12:09 ` Chao Liu</b>
  2026-01-28 14:30   ` <a href="#m225bb7c105a86bd5763acc6b70063b62327f191d">Daniel Henrique Barboza</a>
  2026-01-28 15:36   ` <a href="#med032f1adb576354a7b019f27ef1f7f96608a772">Tao Tang</a>
  2026-01-28 14:42 ` <a href="#m3469b37b570b142238cad69d7b5d435673adf0f8">[RFC PATCH v1 0/2] tests/qtest: Add RISC-V IOMMU bare-metal test using iommu-testdev</a> Daniel Henrique Barboza
  2026-01-28 14:54 ` <a href="#m24f461ed1166131dbfd5c478e2d918856776bc5d">Tao Tang</a>
  <a href="#r351dceb4c1fd03d15423922990cc16cc7f3f55d9">3 siblings, 2 replies; 13+ messages in thread</a>
From: Chao Liu @ 2026-01-28 12:09 UTC (<a href="../../c31147ca6db874b32dcfea6ba4ad08f59ae356b1.1769600111.git.chao.liu.zevorn@gmail.com/">permalink</a> / <a href="../../c31147ca6db874b32dcfea6ba4ad08f59ae356b1.1769600111.git.chao.liu.zevorn@gmail.com/raw">raw</a>)
  To: Alistair Francis, Daniel Henrique Barboza, Palmer Dabbelt,
	Weiwei Li, Liu Zhiwei, Fabiano Rosas, Laurent Vivier,
	Paolo Bonzini, Tao Tang
  Cc: <a href="../../../qemu-devel/?t=20260128121606">qemu-devel</a>, <a href="../../../qemu-riscv/?t=20260128121606">qemu-riscv</a>, hust-os-kernel-patches, Chao Liu

Add a qtest suite for the RISC-V IOMMU PCI device on the virt machine.
The test exercises bare, S-stage, G-stage, and nested translation paths
using iommu-testdev and the qos-riscv-iommu helpers.

The test validates:
- Device context (DC) configuration
- SV39 page table walks for S-stage translation
- SV39x4 page table walks for G-stage translation
- Nested translation combining both stages
- FCTL register constraints

This provides regression coverage for the RISC-V IOMMU implementation
without requiring a full guest OS boot.

Signed-off-by: Chao Liu &lt;chao.liu.zevorn@gmail.com&gt;
---
 <a id="iZ2e.:..:c31147ca6db874b32dcfea6ba4ad08f59ae356b1.1769600111.git.chao.liu.zevorn::40gmail.com:1MAINTAINERS" href="#Z2e.:..:c31147ca6db874b32dcfea6ba4ad08f59ae356b1.1769600111.git.chao.liu.zevorn::40gmail.com:1MAINTAINERS">MAINTAINERS</a>                    |   1 +
 <a id="iZ2e.:..:c31147ca6db874b32dcfea6ba4ad08f59ae356b1.1769600111.git.chao.liu.zevorn::40gmail.com:1tests:qtest:iommu-riscv-test.c" href="#Z2e.:..:c31147ca6db874b32dcfea6ba4ad08f59ae356b1.1769600111.git.chao.liu.zevorn::40gmail.com:1tests:qtest:iommu-riscv-test.c">tests/qtest/iommu-riscv-test.c</a> | 279 +++++++++++++++++++++++++++++++++
 <a id="iZ2e.:..:c31147ca6db874b32dcfea6ba4ad08f59ae356b1.1769600111.git.chao.liu.zevorn::40gmail.com:1tests:qtest:meson.build" href="#Z2e.:..:c31147ca6db874b32dcfea6ba4ad08f59ae356b1.1769600111.git.chao.liu.zevorn::40gmail.com:1tests:qtest:meson.build">tests/qtest/meson.build</a>        |   5 +-
 3 files <a href="#e351dceb4c1fd03d15423922990cc16cc7f3f55d9">changed</a>, 284 insertions(+), 1 deletion(-)
 create mode 100644 tests/qtest/iommu-riscv-test.c

<span class="head"><a href="#iZ2e.:..:c31147ca6db874b32dcfea6ba4ad08f59ae356b1.1769600111.git.chao.liu.zevorn::40gmail.com:1MAINTAINERS" id="Z2e.:..:c31147ca6db874b32dcfea6ba4ad08f59ae356b1.1769600111.git.chao.liu.zevorn::40gmail.com:1MAINTAINERS">diff</a> --git a/MAINTAINERS b/MAINTAINERS
index 894e05bd2c..c7400c83d2 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
</span><span class="hunk">@@ -347,6 +347,7 @@ F: common-user/host/riscv*
</span> F: tests/functional/riscv32
 F: tests/functional/riscv64
 F: tests/tcg/riscv64/
<span class="add">+F: tests/qtest/iommu-riscv-test.c
</span> 
 RISC-V XThead* extensions
 M: Christoph Muellner &lt;christoph.muellner@vrull.eu&gt;
<span class="head"><a href="#iZ2e.:..:c31147ca6db874b32dcfea6ba4ad08f59ae356b1.1769600111.git.chao.liu.zevorn::40gmail.com:1tests:qtest:iommu-riscv-test.c" id="Z2e.:..:c31147ca6db874b32dcfea6ba4ad08f59ae356b1.1769600111.git.chao.liu.zevorn::40gmail.com:1tests:qtest:iommu-riscv-test.c">diff</a> --git a/tests/qtest/iommu-riscv-test.c b/tests/qtest/iommu-riscv-test.c
new file mode 100644
index 0000000000..9438578e1e
--- /dev/null
+++ b/tests/qtest/iommu-riscv-test.c
</span><span class="hunk">@@ -0,0 +1,279 @@
</span><span class="add">+/*
+ * QTest testcase for RISC-V IOMMU with iommu-testdev
+ *
+ * This QTest file is used to test the RISC-V IOMMU with iommu-testdev so that
+ * we can test RISC-V IOMMU without any guest kernel or firmware.
+ *
+ * Copyright (c) 2026 Chao Liu &lt;chao.liu.zevorn@gmail.com&gt;
+ *
+ * SPDX-License-Identifier: GPL-2.0-or-later
+ */
+
+#include "qemu/osdep.h"
+#include "libqtest.h"
+#include "libqos/pci.h"
+#include "libqos/generic-pcihost.h"
+#include "hw/pci/pci_regs.h"
+#include "hw/misc/iommu-testdev.h"
+#include "hw/riscv/riscv-iommu-bits.h"
+#include "libqos/qos-riscv-iommu.h"
+#include "libqos/riscv-iommu.h"
+
+#define DMA_LEN           4
+
+/* RISC-V virt machine PCI configuration */
+#define RISCV_GPEX_PIO_BASE        0x3000000
+#define RISCV_BUS_PIO_LIMIT        0x10000
+#define RISCV_BUS_MMIO_ALLOC_PTR   0x40000000
+#define RISCV_BUS_MMIO_LIMIT       0x80000000
+#define RISCV_ECAM_ALLOC_PTR       0x30000000
+
+typedef struct RiscvIommuTestState {
+    QTestState *qts;
+    QGenericPCIBus gbus;
+    QPCIDevice *iommu_dev;
+    QPCIDevice *testdev;
+    QPCIBar testdev_bar;
+    uint64_t iommu_base;
+} RiscvIommuTestState;
+
+static void riscv_config_qpci_bus(QGenericPCIBus *qpci)
+{
+    qpci-&gt;gpex_pio_base = RISCV_GPEX_PIO_BASE;
+    qpci-&gt;bus.pio_limit = RISCV_BUS_PIO_LIMIT;
+    qpci-&gt;bus.mmio_alloc_ptr = RISCV_BUS_MMIO_ALLOC_PTR;
+    qpci-&gt;bus.mmio_limit = RISCV_BUS_MMIO_LIMIT;
+    qpci-&gt;ecam_alloc_ptr = RISCV_ECAM_ALLOC_PTR;
+}
+
+static uint64_t riscv_iommu_expected_gpa(uint64_t iova)
+{
+    return QRIOMMU_SPACE_OFFS + QRIOMMU_L2_PTE_VAL + (iova &amp; 0xfff);
+}
+
+static void save_fn(QPCIDevice *dev, int devfn, void *data)
+{
+    QPCIDevice **pdev = (QPCIDevice **) data;
+    uint16_t vendor = qpci_config_readw(dev, 0);
+    uint16_t device = qpci_config_readw(dev, 2);
+
+    g_test_message("Found PCI device: vendor=0x%04x device=0x%04x devfn=0x%02x",
+                   vendor, device, devfn);
+
+    if (!*pdev) {
+        *pdev = dev;
+    }
+}
+
+static QPCIDevice *find_riscv_iommu_pci(QGenericPCIBus *gbus,
+                                        uint64_t *iommu_base)
+{
+    QPCIDevice *iommu_dev = NULL;
+    QPCIBar iommu_bar;
+
+    g_test_message("Searching for riscv-iommu-pci "
+                   "(vendor=0x%04x, device=0x%04x)",
+                   RISCV_IOMMU_PCI_VENDOR_ID, RISCV_IOMMU_PCI_DEVICE_ID);
+
+    qpci_device_foreach(&amp;gbus-&gt;bus, RISCV_IOMMU_PCI_VENDOR_ID,
+                        RISCV_IOMMU_PCI_DEVICE_ID, save_fn, &amp;iommu_dev);
+
+    if (!iommu_dev) {
+        g_test_message("riscv-iommu-pci device not found!");
+        return NULL;
+    }
+
+    g_test_message("Found riscv-iommu-pci at devfn=0x%02x", iommu_dev-&gt;devfn);
+
+    qpci_device_enable(iommu_dev);
+    iommu_bar = qpci_iomap(iommu_dev, 0, NULL);
+    g_assert_false(iommu_bar.is_io);
+
+    *iommu_base = iommu_bar.addr;
+    g_test_message("RISC-V IOMMU MMIO base address: 0x%lx", *iommu_base);
+
+    return iommu_dev;
+}
+
+static QPCIDevice *find_iommu_testdev(QGenericPCIBus *gbus, QPCIBar *bar)
+{
+    QPCIDevice *dev = NULL;
+
+    g_test_message("Searching for iommu-testdev (vendor=0x%04x, device=0x%04x)",
+                   IOMMU_TESTDEV_VENDOR_ID, IOMMU_TESTDEV_DEVICE_ID);
+
+    qpci_device_foreach(&amp;gbus-&gt;bus, IOMMU_TESTDEV_VENDOR_ID,
+                        IOMMU_TESTDEV_DEVICE_ID, save_fn, &amp;dev);
+    g_assert(dev);
+
+    qpci_device_enable(dev);
+    *bar = qpci_iomap(dev, 0, NULL);
+    g_assert_false(bar-&gt;is_io);
+
+    return dev;
+}
+
+static bool riscv_iommu_test_setup(RiscvIommuTestState *state)
+{
+    if (!qtest_has_machine("virt")) {
+        g_test_skip("virt machine not available");
+        return false;
+    }
+
+    state-&gt;qts = qtest_init("-machine virt,acpi=off "
+                            "-cpu max -smp 1 -m 512 -net none "
+                            "-device riscv-iommu-pci "
+                            "-device iommu-testdev");
+
+    qpci_init_generic(&amp;state-&gt;gbus, state-&gt;qts, NULL, false);
+    riscv_config_qpci_bus(&amp;state-&gt;gbus);
+
+    state-&gt;iommu_dev = find_riscv_iommu_pci(&amp;state-&gt;gbus, &amp;state-&gt;iommu_base);
+    g_assert(state-&gt;iommu_dev);
+
+    state-&gt;testdev = find_iommu_testdev(&amp;state-&gt;gbus, &amp;state-&gt;testdev_bar);
+    g_assert(state-&gt;testdev);
+
+    return true;
+}
+
+static void riscv_iommu_test_teardown(RiscvIommuTestState *state)
+{
+    qtest_quit(state-&gt;qts);
+}
+
+static uint64_t riscv_iommu_check(QTestState *qts, uint64_t iommu_base,
+                                  QRIOMMUTransMode mode)
+{
+    uint64_t cap;
+    uint64_t ddtp;
+    uint32_t cqcsr;
+    uint32_t fqcsr;
+    uint32_t pqcsr;
+    uint32_t fctl;
+    uint32_t fctl_mask;
+    uint32_t fctl_desired;
+    uint32_t igs;
+
+    cap = qtest_readq(qts, iommu_base + RISCV_IOMMU_REG_CAP);
+    g_assert_cmpuint((uint32_t)(cap &amp; RISCV_IOMMU_CAP_VERSION), ==,
+                     RISCV_IOMMU_SPEC_DOT_VER);
+
+    fctl = qtest_readl(qts, iommu_base + RISCV_IOMMU_REG_FCTL);
+    igs = (cap &amp; RISCV_IOMMU_CAP_IGS) &gt;&gt; 28;
+    g_assert_cmpuint(igs, &lt;=, RISCV_IOMMU_CAP_IGS_BOTH);
+
+    fctl_mask = RISCV_IOMMU_FCTL_BE | RISCV_IOMMU_FCTL_WSI |
+                RISCV_IOMMU_FCTL_GXL;
+    fctl_desired = fctl &amp; ~fctl_mask;
+    if (igs == RISCV_IOMMU_CAP_IGS_WSI) {
+        fctl_desired |= RISCV_IOMMU_FCTL_WSI;
+    }
+
+    if ((fctl &amp; fctl_mask) != (fctl_desired &amp; fctl_mask)) {
+        ddtp = qtest_readq(qts, iommu_base + RISCV_IOMMU_REG_DDTP);
+        cqcsr = qtest_readl(qts, iommu_base + RISCV_IOMMU_REG_CQCSR);
+        fqcsr = qtest_readl(qts, iommu_base + RISCV_IOMMU_REG_FQCSR);
+        pqcsr = qtest_readl(qts, iommu_base + RISCV_IOMMU_REG_PQCSR);
+
+        g_assert_cmpuint((uint32_t)(ddtp &amp; RISCV_IOMMU_DDTP_MODE), ==,
+                         RISCV_IOMMU_DDTP_MODE_OFF);
+        g_assert_cmpuint(cqcsr &amp; RISCV_IOMMU_CQCSR_CQON, ==, 0);
+        g_assert_cmpuint(fqcsr &amp; RISCV_IOMMU_FQCSR_FQON, ==, 0);
+        g_assert_cmpuint(pqcsr &amp; RISCV_IOMMU_PQCSR_PQON, ==, 0);
+
+        qtest_writel(qts, iommu_base + RISCV_IOMMU_REG_FCTL, fctl_desired);
+        fctl = qtest_readl(qts, iommu_base + RISCV_IOMMU_REG_FCTL);
+    }
+
+    g_assert_cmpuint(fctl &amp; fctl_mask, ==, fctl_desired &amp; fctl_mask);
+
+    if (mode == QRIOMMU_TM_S_STAGE_ONLY || mode == QRIOMMU_TM_NESTED) {
+        g_assert((cap &amp; RISCV_IOMMU_CAP_SV39) != 0);
+    }
+    if (mode == QRIOMMU_TM_G_STAGE_ONLY || mode == QRIOMMU_TM_NESTED) {
+        g_assert((cap &amp; RISCV_IOMMU_CAP_SV39X4) != 0);
+        g_assert_cmpuint(fctl &amp; RISCV_IOMMU_FCTL_GXL, ==, 0);
+    }
+
+    return cap;
+}
+
+static void run_riscv_iommu_translation(const QRIOMMUTestConfig *cfg)
+{
+    RiscvIommuTestState state = { 0 };
+
+    if (!riscv_iommu_test_setup(&amp;state)) {
+        return;
+    }
+
+    riscv_iommu_check(state.qts, state.iommu_base, cfg-&gt;trans_mode);
+
+    g_test_message("### RISC-V IOMMU translation mode=%d ###",
+                   cfg-&gt;trans_mode);
+    qriommu_run_translation_case(state.qts, state.testdev, state.testdev_bar,
+                                 state.iommu_base, cfg);
+    riscv_iommu_test_teardown(&amp;state);
+}
+
+static void test_riscv_iommu_bare(void)
+{
+    QRIOMMUTestConfig cfg = {
+        .trans_mode = QRIOMMU_TM_BARE,
+        .dma_gpa = QRIOMMU_IOVA,
+        .dma_len = DMA_LEN,
+        .expected_result = 0,
+    };
+
+    run_riscv_iommu_translation(&amp;cfg);
+}
+
+static void test_riscv_iommu_s_stage_only(void)
+{
+    QRIOMMUTestConfig cfg = {
+        .trans_mode = QRIOMMU_TM_S_STAGE_ONLY,
+        .dma_gpa = riscv_iommu_expected_gpa(QRIOMMU_IOVA),
+        .dma_len = DMA_LEN,
+        .expected_result = 0,
+    };
+
+    run_riscv_iommu_translation(&amp;cfg);
+}
+
+static void test_riscv_iommu_g_stage_only(void)
+{
+    QRIOMMUTestConfig cfg = {
+        .trans_mode = QRIOMMU_TM_G_STAGE_ONLY,
+        .dma_gpa = riscv_iommu_expected_gpa(QRIOMMU_IOVA),
+        .dma_len = DMA_LEN,
+        .expected_result = 0,
+    };
+
+    run_riscv_iommu_translation(&amp;cfg);
+}
+
+static void test_riscv_iommu_nested(void)
+{
+    QRIOMMUTestConfig cfg = {
+        .trans_mode = QRIOMMU_TM_NESTED,
+        .dma_gpa = riscv_iommu_expected_gpa(QRIOMMU_IOVA),
+        .dma_len = DMA_LEN,
+        .expected_result = 0,
+    };
+
+    run_riscv_iommu_translation(&amp;cfg);
+}
+
+int main(int argc, char **argv)
+{
+    g_test_init(&amp;argc, &amp;argv, NULL);
+    qtest_add_func("/iommu-testdev/translation/bare",
+                   test_riscv_iommu_bare);
+    qtest_add_func("/iommu-testdev/translation/s-stage-only",
+                   test_riscv_iommu_s_stage_only);
+    qtest_add_func("/iommu-testdev/translation/g-stage-only",
+                   test_riscv_iommu_g_stage_only);
+    qtest_add_func("/iommu-testdev/translation/ns-nested",
+                   test_riscv_iommu_nested);
+    return g_test_run();
+}
</span><span class="head"><a href="#iZ2e.:..:c31147ca6db874b32dcfea6ba4ad08f59ae356b1.1769600111.git.chao.liu.zevorn::40gmail.com:1tests:qtest:meson.build" id="Z2e.:..:c31147ca6db874b32dcfea6ba4ad08f59ae356b1.1769600111.git.chao.liu.zevorn::40gmail.com:1tests:qtest:meson.build">diff</a> --git a/tests/qtest/meson.build b/tests/qtest/meson.build
index a8b09d065f..eb45e0f97d 100644
--- a/tests/qtest/meson.build
+++ b/tests/qtest/meson.build
</span><span class="hunk">@@ -286,7 +286,10 @@ qtests_riscv32 = \n</span>   (config_all_devices.has_key('CONFIG_SIFIVE_E_AON') ? ['sifive-e-aon-watchdog-test'] : [])
 
 qtests_riscv64 = ['riscv-csr-test'] + \n<span class="del">-  (unpack_edk2_blobs ? ['bios-tables-test'] : [])
</span><span class="add">+  (unpack_edk2_blobs ? ['bios-tables-test'] : []) + \n+  (config_all_devices.has_key('CONFIG_IOMMU_TESTDEV') and
+   config_all_devices.has_key('CONFIG_RISCV_IOMMU') ?
+   ['iommu-riscv-test'] : [])
</span> 
 qos_test_ss = ss.source_set()
 qos_test_ss.add(
-- 
2.52.0



<a href="#m351dceb4c1fd03d15423922990cc16cc7f3f55d9" id="e351dceb4c1fd03d15423922990cc16cc7f3f55d9">^</a> <a href="../../c31147ca6db874b32dcfea6ba4ad08f59ae356b1.1769600111.git.chao.liu.zevorn@gmail.com/">permalink</a> <a href="../../c31147ca6db874b32dcfea6ba4ad08f59ae356b1.1769600111.git.chao.liu.zevorn@gmail.com/raw">raw</a> <a href="../../c31147ca6db874b32dcfea6ba4ad08f59ae356b1.1769600111.git.chao.liu.zevorn@gmail.com/#R">reply</a> <a href="../../c31147ca6db874b32dcfea6ba4ad08f59ae356b1.1769600111.git.chao.liu.zevorn@gmail.com/#related">related</a>	[<a href="../../c31147ca6db874b32dcfea6ba4ad08f59ae356b1.1769600111.git.chao.liu.zevorn@gmail.com/T/#u"><b>flat</b></a>|<a href="../../c31147ca6db874b32dcfea6ba4ad08f59ae356b1.1769600111.git.chao.liu.zevorn@gmail.com/t/#u">nested</a>] <a href="#r351dceb4c1fd03d15423922990cc16cc7f3f55d9">13+ messages in thread</a></pre><hr><pre><a href="#ecb58b9919dda00cefe12d0ce47612540c7bdda90" id="mcb58b9919dda00cefe12d0ce47612540c7bdda90">*</a> <b>Re: [RFC PATCH v1 1/2] tests/qtest/libqos: Add RISC-V IOMMU helper library</b>
  2026-01-28 12:09 ` <a href="#m9559a467360037b0fb0cd48d1cbad2b91a076885">[RFC PATCH v1 1/2] tests/qtest/libqos: Add RISC-V IOMMU helper library</a> Chao Liu
<b>@ 2026-01-28 14:30   ` Daniel Henrique Barboza</b>
  2026-01-28 15:23   ` <a href="#m47ec136efcc6562c3cb0be5024eb931e13b96868">Tao Tang</a>
  2026-01-29  1:59   ` <a href="#md2721ada56e836596debf9456a222cba2cf28cb7">Tao Tang</a>
  <a href="#rcb58b9919dda00cefe12d0ce47612540c7bdda90">2 siblings, 0 replies; 13+ messages in thread</a>
From: Daniel Henrique Barboza @ 2026-01-28 14:30 UTC (<a href="../../26d44609-bbb3-4016-98a0-523b8d11a528@ventanamicro.com/">permalink</a> / <a href="../../26d44609-bbb3-4016-98a0-523b8d11a528@ventanamicro.com/raw">raw</a>)
  To: Chao Liu, Alistair Francis, Palmer Dabbelt, Weiwei Li, Liu Zhiwei,
	Fabiano Rosas, Laurent Vivier, Paolo Bonzini, Tao Tang
  Cc: <a href="../../../qemu-devel/?t=20260128143131">qemu-devel</a>, <a href="../../../qemu-riscv/?t=20260128143131">qemu-riscv</a>, hust-os-kernel-patches



On 1/28/2026 9:09 AM, Chao Liu wrote:
<span class="q">&gt; Introduce a libqos helper module for RISC-V IOMMU testing with
&gt; iommu-testdev. The helper provides routines to:
&gt; 
&gt; - Build device contexts (DC) and 3-level page tables for SV39/SV39x4
&gt; - Program command queue (CQ), fault queue (FQ), and DDTP registers
&gt;    following the RISC-V IOMMU specification
&gt; - Execute DMA translations and verify results
&gt; 
&gt; The current implementation supports SV39 for S-stage and SV39x4 for
&gt; G-stage translation. Support for SV48/SV48x4/SV57/SV57x4 can be added
&gt; in future patches.
&gt; 
&gt; Signed-off-by: Chao Liu &lt;chao.liu.zevorn@gmail.com&gt;
&gt; ---
</span>
Reviewed-by: Daniel Henrique Barboza &lt;daniel.barboza@oss.qualcomm.com&gt;


<span class="q">&gt;   MAINTAINERS                          |   1 +
&gt;   tests/qtest/libqos/meson.build       |   2 +-
&gt;   tests/qtest/libqos/qos-riscv-iommu.c | 400 +++++++++++++++++++++++++++
&gt;   tests/qtest/libqos/qos-riscv-iommu.h | 172 ++++++++++++
&gt;   4 files changed, 574 insertions(+), 1 deletion(-)
&gt;   create mode 100644 tests/qtest/libqos/qos-riscv-iommu.c
&gt;   create mode 100644 tests/qtest/libqos/qos-riscv-iommu.h
&gt; 
&gt; diff --git a/MAINTAINERS b/MAINTAINERS
&gt; index dc31be033e..894e05bd2c 100644
&gt; --- a/MAINTAINERS
&gt; +++ b/MAINTAINERS
&gt; @@ -3583,6 +3583,7 @@ M: Tao Tang &lt;tangtao1634@phytium.com.cn&gt;
&gt;   S: Maintained
&gt;   F: tests/qtest/libqos/qos-iommu*
&gt;   F: tests/qtest/libqos/qos-smmuv3*
&gt; +F: tests/qtest/libqos/qos-riscv-iommu*
&gt;   
&gt;   Device Fuzzing
&gt;   M: Alexander Bulekov &lt;alxndr@bu.edu&gt;
&gt; diff --git a/tests/qtest/libqos/meson.build b/tests/qtest/libqos/meson.build
&gt; index b4daec808f..4a69acad0d 100644
&gt; --- a/tests/qtest/libqos/meson.build
&gt; +++ b/tests/qtest/libqos/meson.build
&gt; @@ -71,7 +71,7 @@ if have_virtfs
&gt;   endif
&gt;   
&gt;   if config_all_devices.has_key('CONFIG_RISCV_IOMMU')
&gt; -  libqos_srcs += files('riscv-iommu.c')
&gt; +  libqos_srcs += files('riscv-iommu.c', 'qos-riscv-iommu.c')
&gt;   endif
&gt;   if config_all_devices.has_key('CONFIG_TPCI200')
&gt;     libqos_srcs += files('tpci200.c')
&gt; diff --git a/tests/qtest/libqos/qos-riscv-iommu.c b/tests/qtest/libqos/qos-riscv-iommu.c
&gt; new file mode 100644
&gt; index 0000000000..34ed3df84a
&gt; --- /dev/null
&gt; +++ b/tests/qtest/libqos/qos-riscv-iommu.c
&gt; @@ -0,0 +1,400 @@
&gt; +/*
&gt; + * QOS RISC-V IOMMU Module
&gt; + *
&gt; + * This module provides RISC-V IOMMU-specific helper functions for libqos tests,
&gt; + * encapsulating RISC-V IOMMU setup, and assertions.
&gt; + *
&gt; + * Copyright (c) 2026 Chao Liu &lt;chao.liu.zevorn@gmail.com&gt;
&gt; + *
&gt; + * SPDX-License-Identifier: GPL-2.0-or-later
&gt; + */
&gt; +
&gt; +#include "qemu/osdep.h"
&gt; +#include "qemu/bitops.h"
&gt; +#include "hw/riscv/riscv-iommu-bits.h"
&gt; +#include "tests/qtest/libqos/pci.h"
&gt; +#include "qos-iommu-testdev.h"
&gt; +#include "qos-riscv-iommu.h"
&gt; +
&gt; +/* Apply space offset to address */
&gt; +static inline uint64_t qriommu_apply_space_offs(uint64_t address)
&gt; +{
&gt; +    return address + QRIOMMU_SPACE_OFFS;
&gt; +}
&gt; +
&gt; +static uint64_t qriommu_encode_pte(uint64_t pa, uint64_t attrs)
&gt; +{
&gt; +    return ((pa &gt;&gt; 12) &lt;&lt; 10) | attrs;
&gt; +}
&gt; +
&gt; +static void qriommu_wait_for_queue_active(QTestState *qts, uint64_t iommu_base,
&gt; +                                          uint32_t queue_csr, uint32_t on_bit)
&gt; +{
&gt; +    guint64 timeout_us = 2 * 1000 * 1000;
&gt; +    gint64 start_time = g_get_monotonic_time();
&gt; +    uint32_t reg;
&gt; +
&gt; +    for (;;) {
&gt; +        qtest_clock_step(qts, 100);
&gt; +
&gt; +        reg = qtest_readl(qts, iommu_base + queue_csr);
&gt; +        if (reg &amp; on_bit) {
&gt; +            return;
&gt; +        }
&gt; +        g_assert(g_get_monotonic_time() - start_time &lt;= timeout_us);
&gt; +    }
&gt; +}
&gt; +
&gt; +uint32_t qriommu_expected_dma_result(QRIOMMUTestContext *ctx)
&gt; +{
&gt; +    return ctx-&gt;config.expected_result;
&gt; +}
&gt; +
&gt; +uint32_t qriommu_build_dma_attrs(void)
&gt; +{
&gt; +    /* RISC-V IOMMU uses standard AXI attributes */
&gt; +    return 0;
&gt; +}
&gt; +
&gt; +uint32_t qriommu_setup_and_enable_translation(QRIOMMUTestContext *ctx)
&gt; +{
&gt; +    uint32_t build_result;
&gt; +
&gt; +    /* Build page tables and RISC-V IOMMU structures first */
&gt; +    build_result = qriommu_build_translation(
&gt; +                       ctx-&gt;qts, ctx-&gt;config.trans_mode,
&gt; +                       ctx-&gt;device_id);
&gt; +    if (build_result != 0) {
&gt; +        g_test_message("Build failed: mode=%u device_id=%u status=0x%x",
&gt; +                       ctx-&gt;config.trans_mode, ctx-&gt;device_id, build_result);
&gt; +        ctx-&gt;trans_status = build_result;
&gt; +        return ctx-&gt;trans_status;
&gt; +    }
&gt; +
&gt; +    /* Program RISC-V IOMMU registers */
&gt; +    qriommu_program_regs(ctx-&gt;qts, ctx-&gt;iommu_base);
&gt; +
&gt; +    ctx-&gt;trans_status = 0;
&gt; +    return ctx-&gt;trans_status;
&gt; +}
&gt; +
&gt; +static bool qriommu_validate_test_result(QRIOMMUTestContext *ctx)
&gt; +{
&gt; +    uint32_t expected = qriommu_expected_dma_result(ctx);
&gt; +    g_test_message("-&gt; Validating result: expected=0x%x actual=0x%x",
&gt; +                   expected, ctx-&gt;dma_result);
&gt; +    return (ctx-&gt;dma_result == expected);
&gt; +}
&gt; +
&gt; +static uint32_t qriommu_single_translation_setup(void *opaque)
&gt; +{
&gt; +    return qriommu_setup_and_enable_translation(opaque);
&gt; +}
&gt; +
&gt; +static uint32_t qriommu_single_translation_attrs(void *opaque)
&gt; +{
&gt; +    return qriommu_build_dma_attrs();
&gt; +}
&gt; +
&gt; +static bool qriommu_single_translation_validate(void *opaque)
&gt; +{
&gt; +    return qriommu_validate_test_result(opaque);
&gt; +}
&gt; +
&gt; +static void qriommu_single_translation_report(void *opaque,
&gt; +                                              uint32_t dma_result)
&gt; +{
&gt; +    QRIOMMUTestContext *ctx = opaque;
&gt; +
&gt; +    if (dma_result != 0) {
&gt; +        g_test_message("DMA failed: mode=%u result=0x%x",
&gt; +                       ctx-&gt;config.trans_mode, dma_result);
&gt; +    } else {
&gt; +        g_test_message("-&gt; DMA succeeded: mode=%u",
&gt; +                       ctx-&gt;config.trans_mode);
&gt; +    }
&gt; +}
&gt; +
&gt; +void qriommu_run_translation_case(QTestState *qts, QPCIDevice *dev,
&gt; +                                  QPCIBar bar, uint64_t iommu_base,
&gt; +                                  const QRIOMMUTestConfig *cfg)
&gt; +{
&gt; +    QRIOMMUTestContext ctx = {
&gt; +        .qts = qts,
&gt; +        .dev = dev,
&gt; +        .bar = bar,
&gt; +        .iommu_base = iommu_base,
&gt; +        .config = *cfg,
&gt; +        .device_id = dev-&gt;devfn,
&gt; +    };
&gt; +
&gt; +    QOSIOMMUTestdevDmaCfg dma = {
&gt; +        .dev = dev,
&gt; +        .bar = bar,
&gt; +        .iova = QRIOMMU_IOVA,
&gt; +        .gpa = ctx.config.dma_gpa,
&gt; +        .len = ctx.config.dma_len,
&gt; +    };
&gt; +
&gt; +    qtest_memset(qts, cfg-&gt;dma_gpa, 0x00, cfg-&gt;dma_len);
&gt; +    qos_iommu_testdev_single_translation(&amp;dma, &amp;ctx,
&gt; +                                         qriommu_single_translation_setup,
&gt; +                                         qriommu_single_translation_attrs,
&gt; +                                         qriommu_single_translation_validate,
&gt; +                                         qriommu_single_translation_report,
&gt; +                                         &amp;ctx.dma_result);
&gt; +
&gt; +    if (ctx.dma_result == 0 &amp;&amp; ctx.config.expected_result == 0) {
&gt; +        g_autofree uint8_t *buf = NULL;
&gt; +
&gt; +        buf = g_malloc(ctx.config.dma_len);
&gt; +        qtest_memread(ctx.qts, ctx.config.dma_gpa, buf, ctx.config.dma_len);
&gt; +
&gt; +        for (int i = 0; i &lt; ctx.config.dma_len; i++) {
&gt; +            uint8_t expected;
&gt; +
&gt; +            expected = (ITD_DMA_WRITE_VAL &gt;&gt; ((i % 4) * 8)) &amp; 0xff;
&gt; +            g_assert_cmpuint(buf[i], ==, expected);
&gt; +        }
&gt; +    }
&gt; +}
&gt; +
&gt; +static uint32_t qriommu_get_table_index(uint64_t addr, int level)
&gt; +{
&gt; +    /* SV39: 39-bit virtual address, 3-level page table */
&gt; +    switch (level) {
&gt; +    case 0:
&gt; +        return (addr &gt;&gt; 30) &amp; 0x1ff;   /* L0: bits [38:30] */
&gt; +    case 1:
&gt; +        return (addr &gt;&gt; 21) &amp; 0x1ff;   /* L1: bits [29:21] */
&gt; +    case 2:
&gt; +        return (addr &gt;&gt; 12) &amp; 0x1ff;   /* L2: bits [20:12] */
&gt; +    default:
&gt; +        g_assert_not_reached();
&gt; +    }
&gt; +}
&gt; +
&gt; +static uint64_t qriommu_get_table_addr(uint64_t base, int level, uint64_t iova)
&gt; +{
&gt; +    uint32_t index = qriommu_get_table_index(iova, level);
&gt; +    return (base &amp; QRIOMMU_PTE_PPN_MASK) + (index * 8);
&gt; +}
&gt; +
&gt; +static void qriommu_map_leaf(QTestState *qts, uint64_t root_pa,
&gt; +                             uint64_t l0_pa, uint64_t l1_pa,
&gt; +                             uint64_t l0_pte_val, uint64_t l1_pte_val,
&gt; +                             uint64_t va, uint64_t pa, uint64_t leaf_attrs)
&gt; +{
&gt; +    uint64_t l0_addr = qriommu_get_table_addr(root_pa, 0, va);
&gt; +    uint64_t l1_addr = qriommu_get_table_addr(l0_pa, 1, va);
&gt; +    uint64_t l2_addr = qriommu_get_table_addr(l1_pa, 2, va);
&gt; +
&gt; +    qtest_writeq(qts, l0_addr, l0_pte_val);
&gt; +    qtest_writeq(qts, l1_addr, l1_pte_val);
&gt; +    qtest_writeq(qts, l2_addr, qriommu_encode_pte(pa, leaf_attrs));
&gt; +}
&gt; +
&gt; +static uint64_t qriommu_get_pte_attrs(QRIOMMUTransMode mode, bool is_leaf)
&gt; +{
&gt; +    if (!is_leaf) {
&gt; +        return QRIOMMU_NON_LEAF_PTE_MASK;
&gt; +    }
&gt; +
&gt; +    /* For leaf PTE, set RWX permissions */
&gt; +    return QRIOMMU_LEAF_PTE_RW_MASK;
&gt; +}
&gt; +
&gt; +void qriommu_setup_translation_tables(QTestState *qts,
&gt; +                                      uint64_t iova,
&gt; +                                      QRIOMMUTransMode mode)
&gt; +{
&gt; +    uint64_t s_root = 0, s_l0_pte_val = 0, s_l1_pte_val = 0;
&gt; +    uint64_t s_l0_addr = 0, s_l1_addr = 0, s_l2_addr = 0, s_l2_pte_val = 0;
&gt; +    uint64_t s_l0_pa = 0, s_l1_pa = 0;
&gt; +    uint64_t s_l2_pa = qriommu_apply_space_offs(QRIOMMU_L2_PTE_VAL);
&gt; +    uint64_t s_l0_pa_real = 0, s_l1_pa_real = 0;
&gt; +    uint64_t s_l2_pa_real = qriommu_apply_space_offs(QRIOMMU_L2_PTE_VAL);
&gt; +    uint64_t non_leaf_attrs = qriommu_get_pte_attrs(mode, false);
&gt; +    uint64_t leaf_attrs = qriommu_get_pte_attrs(mode, true);
&gt; +
&gt; +    if (mode != QRIOMMU_TM_G_STAGE_ONLY) {
&gt; +        /* Setup S-stage 3-level page tables (SV39) */
&gt; +        s_l0_pa = qriommu_apply_space_offs(QRIOMMU_L0_PTE_VAL);
&gt; +        s_l1_pa = qriommu_apply_space_offs(QRIOMMU_L1_PTE_VAL);
&gt; +        s_root = qriommu_apply_space_offs(
&gt; +            QRIOMMU_IOHGATP &amp; QRIOMMU_PTE_PPN_MASK);
&gt; +        s_l2_pa = qriommu_apply_space_offs(QRIOMMU_L2_PTE_VAL);
&gt; +
&gt; +        s_l0_pa_real = s_l0_pa;
&gt; +        s_l1_pa_real = s_l1_pa;
&gt; +        s_l2_pa_real = s_l2_pa;
&gt; +
&gt; +        if (mode == QRIOMMU_TM_NESTED) {
&gt; +            s_l0_pa = QRIOMMU_L0_PTE_VAL;
&gt; +            s_l1_pa = QRIOMMU_L1_PTE_VAL;
&gt; +            s_l2_pa = QRIOMMU_L2_PTE_VAL;
&gt; +
&gt; +            s_l0_pa_real = qriommu_apply_space_offs(QRIOMMU_L0_PTE_VAL);
&gt; +            s_l1_pa_real = qriommu_apply_space_offs(QRIOMMU_L1_PTE_VAL);
&gt; +            s_l2_pa_real = qriommu_apply_space_offs(QRIOMMU_L2_PTE_VAL);
&gt; +        }
&gt; +
&gt; +        s_l0_pte_val = qriommu_encode_pte(s_l0_pa, non_leaf_attrs);
&gt; +        s_l1_pte_val = qriommu_encode_pte(s_l1_pa, non_leaf_attrs);
&gt; +
&gt; +        s_l0_addr = qriommu_get_table_addr(s_root, 0, iova);
&gt; +        qtest_writeq(qts, s_l0_addr, s_l0_pte_val);
&gt; +
&gt; +        s_l1_addr = qriommu_get_table_addr(s_l0_pa_real, 1, iova);
&gt; +        qtest_writeq(qts, s_l1_addr, s_l1_pte_val);
&gt; +
&gt; +        s_l2_addr = qriommu_get_table_addr(s_l1_pa_real, 2, iova);
&gt; +        s_l2_pte_val = qriommu_encode_pte(s_l2_pa, leaf_attrs);
&gt; +        qtest_writeq(qts, s_l2_addr, s_l2_pte_val);
&gt; +    }
&gt; +
&gt; +    if (mode == QRIOMMU_TM_G_STAGE_ONLY || mode == QRIOMMU_TM_NESTED) {
&gt; +        uint64_t g_root = qriommu_apply_space_offs(
&gt; +            QRIOMMU_G_IOHGATP &amp; QRIOMMU_PTE_PPN_MASK);
&gt; +        uint64_t g_l0_pa = qriommu_apply_space_offs(QRIOMMU_G_L0_PTE_VAL);
&gt; +        uint64_t g_l1_pa = qriommu_apply_space_offs(QRIOMMU_G_L1_PTE_VAL);
&gt; +        uint64_t g_l0_pte_val = qriommu_encode_pte(g_l0_pa, non_leaf_attrs);
&gt; +        uint64_t g_l1_pte_val = qriommu_encode_pte(g_l1_pa, non_leaf_attrs);
&gt; +
&gt; +        if (mode == QRIOMMU_TM_G_STAGE_ONLY) {
&gt; +            qriommu_map_leaf(qts, g_root, g_l0_pa, g_l1_pa,
&gt; +                             g_l0_pte_val, g_l1_pte_val,
&gt; +                             iova, s_l2_pa_real, leaf_attrs);
&gt; +        } else {
&gt; +            qriommu_map_leaf(qts, g_root, g_l0_pa, g_l1_pa,
&gt; +                             g_l0_pte_val, g_l1_pte_val,
&gt; +                             QRIOMMU_IOHGATP, s_root, leaf_attrs);
&gt; +            qriommu_map_leaf(qts, g_root, g_l0_pa, g_l1_pa,
&gt; +                             g_l0_pte_val, g_l1_pte_val,
&gt; +                             QRIOMMU_L0_PTE_VAL, s_l0_pa_real, leaf_attrs);
&gt; +            qriommu_map_leaf(qts, g_root, g_l0_pa, g_l1_pa,
&gt; +                             g_l0_pte_val, g_l1_pte_val,
&gt; +                             QRIOMMU_L1_PTE_VAL, s_l1_pa_real, leaf_attrs);
&gt; +            qriommu_map_leaf(qts, g_root, g_l0_pa, g_l1_pa,
&gt; +                             g_l0_pte_val, g_l1_pte_val,
&gt; +                             QRIOMMU_L2_PTE_VAL, s_l2_pa_real, leaf_attrs);
&gt; +        }
&gt; +    }
&gt; +}
&gt; +
&gt; +uint32_t qriommu_build_translation(QTestState *qts, QRIOMMUTransMode mode,
&gt; +                                   uint32_t device_id)
&gt; +{
&gt; +    uint64_t dc_addr, dc_addr_real;
&gt; +    struct riscv_iommu_dc dc;
&gt; +    uint64_t iohgatp;
&gt; +
&gt; +    qtest_memset(qts, qriommu_apply_space_offs(QRIOMMU_DDT_BASE), 0, 0x1000);
&gt; +
&gt; +    dc_addr = device_id * sizeof(struct riscv_iommu_dc) + QRIOMMU_DC_BASE;
&gt; +    dc_addr_real = qriommu_apply_space_offs(dc_addr);
&gt; +
&gt; +    /* Build Device Context (DC) */
&gt; +    memset(&amp;dc, 0, sizeof(dc));
&gt; +
&gt; +    switch (mode) {
&gt; +    case QRIOMMU_TM_BARE:
&gt; +        /* Pass-through mode: tc.V=1, no FSC/IOHGATP */
&gt; +        dc.tc = RISCV_IOMMU_DC_TC_V;
&gt; +        break;
&gt; +
&gt; +    case QRIOMMU_TM_S_STAGE_ONLY:
&gt; +        /* S-stage only: tc.V=1, set FSC */
&gt; +        dc.tc = RISCV_IOMMU_DC_TC_V;
&gt; +        iohgatp = qriommu_apply_space_offs(QRIOMMU_IOHGATP);
&gt; +        /* FSC mode: SV39 (mode=8) */
&gt; +        dc.fsc = (iohgatp &gt;&gt; 12) | (8ull &lt;&lt; 60);
&gt; +        break;
&gt; +
&gt; +    case QRIOMMU_TM_G_STAGE_ONLY:
&gt; +        /* G-stage only: tc.V=1, set IOHGATP */
&gt; +        dc.tc = RISCV_IOMMU_DC_TC_V;
&gt; +        iohgatp = qriommu_apply_space_offs(QRIOMMU_G_IOHGATP);
&gt; +        /* IOHGATP mode: SV39x4 (mode=8) */
&gt; +        dc.iohgatp = (iohgatp &gt;&gt; 12) | (8ull &lt;&lt; 60);
&gt; +        break;
&gt; +
&gt; +    case QRIOMMU_TM_NESTED:
&gt; +        /* Nested: tc.V=1, set both FSC and IOHGATP */
&gt; +        dc.tc = RISCV_IOMMU_DC_TC_V;
&gt; +        /* FSC mode: SV39 (mode=8) */
&gt; +        dc.fsc = (QRIOMMU_IOHGATP &gt;&gt; 12) | (8ull &lt;&lt; 60);
&gt; +        /* IOHGATP mode: SV39x4 (mode=8) */
&gt; +        iohgatp = qriommu_apply_space_offs(QRIOMMU_G_IOHGATP);
&gt; +        dc.iohgatp = (iohgatp &gt;&gt; 12) | (8ull &lt;&lt; 60);
&gt; +        break;
&gt; +
&gt; +    default:
&gt; +        g_assert_not_reached();
&gt; +    }
&gt; +
&gt; +    /* Write DC to memory */
&gt; +    qtest_writeq(qts, dc_addr_real + 0,  dc.tc);
&gt; +    qtest_writeq(qts, dc_addr_real + 8,  dc.iohgatp);
&gt; +    qtest_writeq(qts, dc_addr_real + 16, dc.ta);
&gt; +    qtest_writeq(qts, dc_addr_real + 24, dc.fsc);
&gt; +    qtest_writeq(qts, dc_addr_real + 32, dc.msiptp);
&gt; +    qtest_writeq(qts, dc_addr_real + 40, dc.msi_addr_mask);
&gt; +    qtest_writeq(qts, dc_addr_real + 48, dc.msi_addr_pattern);
&gt; +    qtest_writeq(qts, dc_addr_real + 56, dc._reserved);
&gt; +
&gt; +    /* Setup translation tables if not in BARE mode */
&gt; +    if (mode != QRIOMMU_TM_BARE) {
&gt; +        qriommu_setup_translation_tables(qts, QRIOMMU_IOVA, mode);
&gt; +    }
&gt; +
&gt; +    return 0;
&gt; +}
&gt; +
&gt; +void qriommu_program_regs(QTestState *qts, uint64_t iommu_base)
&gt; +{
&gt; +    uint64_t ddtp, cqb, fqb;
&gt; +    uint64_t cq_base, fq_base;
&gt; +    uint64_t cq_align, fq_align;
&gt; +    uint32_t cq_entries = QRIOMMU_QUEUE_ENTRIES;
&gt; +    uint32_t fq_entries = QRIOMMU_QUEUE_ENTRIES;
&gt; +    uint32_t cq_log2sz = ctz32(cq_entries) - 1;
&gt; +    uint32_t fq_log2sz = ctz32(fq_entries) - 1;
&gt; +
&gt; +    cq_base = qriommu_apply_space_offs(QRIOMMU_CQ_BASE_ADDR);
&gt; +    fq_base = qriommu_apply_space_offs(QRIOMMU_FQ_BASE_ADDR);
&gt; +
&gt; +    cq_align = MAX(0x1000ull, (uint64_t)cq_entries * QRIOMMU_CQ_ENTRY_SIZE);
&gt; +    fq_align = MAX(0x1000ull, (uint64_t)fq_entries * QRIOMMU_FQ_ENTRY_SIZE);
&gt; +    g_assert((cq_base &amp; (cq_align - 1)) == 0);
&gt; +    g_assert((fq_base &amp; (fq_align - 1)) == 0);
&gt; +
&gt; +    /* Setup Command Queue */
&gt; +    cqb = (cq_base &gt;&gt; 12) &lt;&lt; 10 | cq_log2sz;
&gt; +    qtest_writeq(qts, iommu_base + RISCV_IOMMU_REG_CQB, cqb);
&gt; +    qtest_writel(qts, iommu_base + RISCV_IOMMU_REG_CQH, 0);
&gt; +    qtest_writel(qts, iommu_base + RISCV_IOMMU_REG_CQT, 0);
&gt; +    qtest_writel(qts, iommu_base + RISCV_IOMMU_REG_CQCSR,
&gt; +                 RISCV_IOMMU_CQCSR_CQEN);
&gt; +    qriommu_wait_for_queue_active(qts, iommu_base, RISCV_IOMMU_REG_CQCSR,
&gt; +                                  RISCV_IOMMU_CQCSR_CQON);
&gt; +
&gt; +    /* Setup Fault Queue */
&gt; +    fqb = (fq_base &gt;&gt; 12) &lt;&lt; 10 | fq_log2sz;
&gt; +    qtest_writeq(qts, iommu_base + RISCV_IOMMU_REG_FQB, fqb);
&gt; +    qtest_writel(qts, iommu_base + RISCV_IOMMU_REG_FQH, 0);
&gt; +    qtest_writel(qts, iommu_base + RISCV_IOMMU_REG_FQT, 0);
&gt; +    qtest_writel(qts, iommu_base + RISCV_IOMMU_REG_FQCSR,
&gt; +                 RISCV_IOMMU_FQCSR_FQEN);
&gt; +    qriommu_wait_for_queue_active(qts, iommu_base, RISCV_IOMMU_REG_FQCSR,
&gt; +                                  RISCV_IOMMU_FQCSR_FQON);
&gt; +
&gt; +    /* Set Device Directory Table Pointer (DDTP) */
&gt; +    ddtp = qriommu_apply_space_offs(QRIOMMU_DDT_BASE);
&gt; +    g_assert((ddtp &amp; 0xfff) == 0);
&gt; +    ddtp = ((ddtp &gt;&gt; 12) &lt;&lt; 10) | RISCV_IOMMU_DDTP_MODE_1LVL;
&gt; +    qtest_writeq(qts, iommu_base + RISCV_IOMMU_REG_DDTP, ddtp);
&gt; +    g_assert((qtest_readq(qts, iommu_base + RISCV_IOMMU_REG_DDTP) &amp;
&gt; +              (RISCV_IOMMU_DDTP_PPN | RISCV_IOMMU_DDTP_MODE)) ==
&gt; +             (ddtp &amp; (RISCV_IOMMU_DDTP_PPN | RISCV_IOMMU_DDTP_MODE)));
&gt; +}
&gt; diff --git a/tests/qtest/libqos/qos-riscv-iommu.h b/tests/qtest/libqos/qos-riscv-iommu.h
&gt; new file mode 100644
&gt; index 0000000000..1f4efbf682
&gt; --- /dev/null
&gt; +++ b/tests/qtest/libqos/qos-riscv-iommu.h
&gt; @@ -0,0 +1,172 @@
&gt; +/*
&gt; + * QOS RISC-V IOMMU Module
&gt; + *
&gt; + * This module provides RISC-V IOMMU-specific helper functions for libqos tests,
&gt; + * encapsulating RISC-V IOMMU setup, and assertions.
&gt; + *
&gt; + * Copyright (c) 2026 Chao Liu &lt;chao.liu.zevorn@gmail.com&gt;
&gt; + *
&gt; + * SPDX-License-Identifier: GPL-2.0-or-later
&gt; + */
&gt; +
&gt; +#ifndef QTEST_LIBQOS_RISCV_IOMMU_H
&gt; +#define QTEST_LIBQOS_RISCV_IOMMU_H
&gt; +
&gt; +#include "hw/misc/iommu-testdev.h"
&gt; +
&gt; +/* RISC-V IOMMU MMIO register base for virt machine */
&gt; +#define VIRT_RISCV_IOMMU_BASE      0x0000000003010000ull
&gt; +
&gt; +/* RISC-V IOMMU queue and table base addresses */
&gt; +#define QRIOMMU_CQ_BASE_ADDR       0x000000000e160000ull
&gt; +#define QRIOMMU_FQ_BASE_ADDR       0x000000000e170000ull
&gt; +
&gt; +/* RISC-V IOMMU queue sizing */
&gt; +#define QRIOMMU_QUEUE_ENTRIES  1024
&gt; +#define QRIOMMU_CQ_ENTRY_SIZE  16
&gt; +#define QRIOMMU_FQ_ENTRY_SIZE  32
&gt; +
&gt; +/*
&gt; + * Translation tables and descriptors for RISC-V IOMMU.
&gt; + * Similar to ARM SMMUv3, but using RISC-V IOMMU terminology:
&gt; + * - Device Context (DC) instead of STE
&gt; + * - First-stage context (FSC) for S-stage translation
&gt; + * - IOHGATP for G-stage translation
&gt; + *
&gt; + * Granule size: 4KB pages
&gt; + * Page table levels: 3 levels for SV39 (L0, L1, L2)
&gt; + * IOVA size: 39-bit virtual address space
&gt; + */
&gt; +#define QRIOMMU_IOVA                0x0000000080604567ull
&gt; +#define QRIOMMU_IOHGATP             0x0000000000010000ull
&gt; +#define QRIOMMU_DDT_BASE            0x0000000000014000ull
&gt; +#define QRIOMMU_DC_BASE             (QRIOMMU_DDT_BASE)
&gt; +
&gt; +#define QRIOMMU_L0_PTE_VAL          0x0000000000011000ull
&gt; +#define QRIOMMU_L1_PTE_VAL          0x0000000000012000ull
&gt; +#define QRIOMMU_L2_PTE_VAL          0x0000000000013000ull
&gt; +
&gt; +#define QRIOMMU_G_IOHGATP           0x0000000000020000ull
&gt; +#define QRIOMMU_G_L0_PTE_VAL        0x0000000000021000ull
&gt; +#define QRIOMMU_G_L1_PTE_VAL        0x0000000000022000ull
&gt; +
&gt; +/* RISC-V page table entry masks */
&gt; +#define QRIOMMU_PTE_V               0x0000000000000001ull
&gt; +#define QRIOMMU_PTE_R               0x0000000000000002ull
&gt; +#define QRIOMMU_PTE_W               0x0000000000000004ull
&gt; +#define QRIOMMU_PTE_X               0x0000000000000008ull
&gt; +#define QRIOMMU_PTE_U               0x0000000000000010ull
&gt; +#define QRIOMMU_PTE_G               0x0000000000000020ull
&gt; +#define QRIOMMU_PTE_A               0x0000000000000040ull
&gt; +#define QRIOMMU_PTE_D               0x0000000000000080ull
&gt; +
&gt; +#define QRIOMMU_NON_LEAF_PTE_MASK   (QRIOMMU_PTE_V)
&gt; +#define QRIOMMU_LEAF_PTE_RW_MASK    (QRIOMMU_PTE_V | QRIOMMU_PTE_R | \n&gt; +                                     QRIOMMU_PTE_W | QRIOMMU_PTE_A | \n&gt; +                                     QRIOMMU_PTE_D)
&gt; +#define QRIOMMU_PTE_PPN_MASK        0x003ffffffffffc00ull
&gt; +
&gt; +/* Address-space base offset for test tables */
&gt; +#define QRIOMMU_SPACE_OFFS          0x0000000080000000ull
&gt; +
&gt; +typedef enum QRIOMMUTransMode {
&gt; +    QRIOMMU_TM_BARE         = 0,    /* No translation (pass-through) */
&gt; +    QRIOMMU_TM_S_STAGE_ONLY = 1,    /* First-stage only (S-stage) */
&gt; +    QRIOMMU_TM_G_STAGE_ONLY = 2,    /* Second-stage only (G-stage) */
&gt; +    QRIOMMU_TM_NESTED       = 3,    /* Nested translation (S + G) */
&gt; +} QRIOMMUTransMode;
&gt; +
&gt; +typedef struct QRIOMMUTestConfig {
&gt; +    QRIOMMUTransMode trans_mode;    /* Translation mode */
&gt; +    uint64_t dma_gpa;               /* GPA for readback validation */
&gt; +    uint32_t dma_len;               /* DMA length for testing */
&gt; +    uint32_t expected_result;       /* Expected DMA result */
&gt; +} QRIOMMUTestConfig;
&gt; +
&gt; +typedef struct QRIOMMUTestContext {
&gt; +    QTestState *qts;                /* QTest state handle */
&gt; +    QPCIDevice *dev;                /* PCI device handle */
&gt; +    QPCIBar bar;                    /* PCI BAR for MMIO access */
&gt; +    QRIOMMUTestConfig config;       /* Test configuration */
&gt; +    uint64_t iommu_base;            /* RISC-V IOMMU base address */
&gt; +    uint32_t trans_status;          /* Translation configuration status */
&gt; +    uint32_t dma_result;            /* DMA operation result */
&gt; +    uint32_t device_id;             /* Device ID for the test */
&gt; +} QRIOMMUTestContext;
&gt; +
&gt; +/*
&gt; + * qriommu_setup_and_enable_translation - Complete translation setup and enable
&gt; + *
&gt; + * @ctx: Test context containing configuration and device handles
&gt; + *
&gt; + * Returns: Translation status (0 = success, non-zero = error)
&gt; + *
&gt; + * This function performs the complete translation setup sequence:
&gt; + * 1. Builds all required RISC-V IOMMU structures (DC, page tables)
&gt; + * 2. Programs RISC-V IOMMU registers
&gt; + * 3. Returns configuration status
&gt; + */
&gt; +uint32_t qriommu_setup_and_enable_translation(QRIOMMUTestContext *ctx);
&gt; +
&gt; +/*
&gt; + * qriommu_build_translation - Build RISC-V IOMMU translation structures
&gt; + *
&gt; + * @qts: QTest state handle
&gt; + * @mode: Translation mode (BARE, S_STAGE_ONLY, G_STAGE_ONLY, NESTED)
&gt; + * @device_id: Device ID
&gt; + *
&gt; + * Returns: Build status (0 = success, non-zero = error)
&gt; + *
&gt; + * Constructs all necessary RISC-V IOMMU translation structures in guest memory:
&gt; + * - Device Context (DC) for the given device ID
&gt; + * - First-stage context (FSC) if S-stage translation is involved
&gt; + * - Complete page table hierarchy based on translation mode
&gt; + */
&gt; +uint32_t qriommu_build_translation(QTestState *qts, QRIOMMUTransMode mode,
&gt; +                                   uint32_t device_id);
&gt; +
&gt; +/*
&gt; + * qriommu_program_regs - Program all required RISC-V IOMMU registers
&gt; + *
&gt; + * @qts: QTest state handle
&gt; + * @iommu_base: RISC-V IOMMU base address
&gt; + *
&gt; + * Programs RISC-V IOMMU registers:
&gt; + * - Device Directory Table Pointer (DDTP)
&gt; + * - Command queue (base, head, tail)
&gt; + * - Fault queue (base, head, tail)
&gt; + * - Control and status registers
&gt; + */
&gt; +void qriommu_program_regs(QTestState *qts, uint64_t iommu_base);
&gt; +
&gt; +/*
&gt; + * qriommu_setup_translation_tables - Setup RISC-V IOMMU page table hierarchy
&gt; + *
&gt; + * @qts: QTest state handle
&gt; + * @iova: Input Virtual Address to translate
&gt; + * @mode: Translation mode
&gt; + *
&gt; + * This function builds the complete page table structure for translating
&gt; + * the given IOVA through the RISC-V IOMMU. The structure varies based on mode:
&gt; + *
&gt; + * - BARE: No translation (pass-through)
&gt; + * - S_STAGE_ONLY: Single S-stage walk (IOVA -&gt; PA)
&gt; + * - G_STAGE_ONLY: Single G-stage walk (IPA -&gt; PA)
&gt; + * - NESTED: S-stage walk (IOVA -&gt; IPA) + G-stage walk (IPA -&gt; PA)
&gt; + */
&gt; +void qriommu_setup_translation_tables(QTestState *qts,
&gt; +                                      uint64_t iova,
&gt; +                                      QRIOMMUTransMode mode);
&gt; +
&gt; +/* High-level test execution helpers */
&gt; +void qriommu_run_translation_case(QTestState *qts, QPCIDevice *dev,
&gt; +                                  QPCIBar bar, uint64_t iommu_base,
&gt; +                                  const QRIOMMUTestConfig *cfg);
&gt; +
&gt; +/* Calculate expected DMA result */
&gt; +uint32_t qriommu_expected_dma_result(QRIOMMUTestContext *ctx);
&gt; +
&gt; +/* Build DMA attributes for RISC-V IOMMU */
&gt; +uint32_t qriommu_build_dma_attrs(void);
&gt; +
&gt; +#endif /* QTEST_LIBQOS_RISCV_IOMMU_H */
</span>


<a href="#mcb58b9919dda00cefe12d0ce47612540c7bdda90" id="ecb58b9919dda00cefe12d0ce47612540c7bdda90">^</a> <a href="../../26d44609-bbb3-4016-98a0-523b8d11a528@ventanamicro.com/">permalink</a> <a href="../../26d44609-bbb3-4016-98a0-523b8d11a528@ventanamicro.com/raw">raw</a> <a href="../../26d44609-bbb3-4016-98a0-523b8d11a528@ventanamicro.com/#R">reply</a>	[<a href="../../26d44609-bbb3-4016-98a0-523b8d11a528@ventanamicro.com/T/#u"><b>flat</b></a>|<a href="../../26d44609-bbb3-4016-98a0-523b8d11a528@ventanamicro.com/t/#u">nested</a>] <a href="#rcb58b9919dda00cefe12d0ce47612540c7bdda90">13+ messages in thread</a></pre><hr><pre><a href="#e225bb7c105a86bd5763acc6b70063b62327f191d" id="m225bb7c105a86bd5763acc6b70063b62327f191d">*</a> <b>Re: [RFC PATCH v1 2/2] tests/qtest: Add RISC-V IOMMU bare-metal test</b>
  2026-01-28 12:09 ` <a href="#m351dceb4c1fd03d15423922990cc16cc7f3f55d9">[RFC PATCH v1 2/2] tests/qtest: Add RISC-V IOMMU bare-metal test</a> Chao Liu
<b>@ 2026-01-28 14:30   ` Daniel Henrique Barboza</b>
  2026-01-28 15:36   ` <a href="#med032f1adb576354a7b019f27ef1f7f96608a772">Tao Tang</a>
  <a href="#r225bb7c105a86bd5763acc6b70063b62327f191d">1 sibling, 0 replies; 13+ messages in thread</a>
From: Daniel Henrique Barboza @ 2026-01-28 14:30 UTC (<a href="../../cd8bc37a-c9ef-4f31-a024-fac24b74613e@ventanamicro.com/">permalink</a> / <a href="../../cd8bc37a-c9ef-4f31-a024-fac24b74613e@ventanamicro.com/raw">raw</a>)
  To: Chao Liu, Alistair Francis, Palmer Dabbelt, Weiwei Li, Liu Zhiwei,
	Fabiano Rosas, Laurent Vivier, Paolo Bonzini, Tao Tang
  Cc: <a href="../../../qemu-devel/?t=20260128143241">qemu-devel</a>, <a href="../../../qemu-riscv/?t=20260128143241">qemu-riscv</a>, hust-os-kernel-patches



On 1/28/2026 9:09 AM, Chao Liu wrote:
<span class="q">&gt; Add a qtest suite for the RISC-V IOMMU PCI device on the virt machine.
&gt; The test exercises bare, S-stage, G-stage, and nested translation paths
&gt; using iommu-testdev and the qos-riscv-iommu helpers.
&gt; 
&gt; The test validates:
&gt; - Device context (DC) configuration
&gt; - SV39 page table walks for S-stage translation
&gt; - SV39x4 page table walks for G-stage translation
&gt; - Nested translation combining both stages
&gt; - FCTL register constraints
&gt; 
&gt; This provides regression coverage for the RISC-V IOMMU implementation
&gt; without requiring a full guest OS boot.
&gt; 
&gt; Signed-off-by: Chao Liu &lt;chao.liu.zevorn@gmail.com&gt;
&gt; ---
</span>
Reviewed-by: Daniel Henrique Barboza &lt;daniel.barboza@oss.qualcomm.com&gt;

<span class="q">&gt;   MAINTAINERS                    |   1 +
&gt;   tests/qtest/iommu-riscv-test.c | 279 +++++++++++++++++++++++++++++++++
&gt;   tests/qtest/meson.build        |   5 +-
&gt;   3 files changed, 284 insertions(+), 1 deletion(-)
&gt;   create mode 100644 tests/qtest/iommu-riscv-test.c
&gt; 
&gt; diff --git a/MAINTAINERS b/MAINTAINERS
&gt; index 894e05bd2c..c7400c83d2 100644
&gt; --- a/MAINTAINERS
&gt; +++ b/MAINTAINERS
&gt; @@ -347,6 +347,7 @@ F: common-user/host/riscv*
&gt;   F: tests/functional/riscv32
&gt;   F: tests/functional/riscv64
&gt;   F: tests/tcg/riscv64/
&gt; +F: tests/qtest/iommu-riscv-test.c
&gt;   
&gt;   RISC-V XThead* extensions
&gt;   M: Christoph Muellner &lt;christoph.muellner@vrull.eu&gt;
&gt; diff --git a/tests/qtest/iommu-riscv-test.c b/tests/qtest/iommu-riscv-test.c
&gt; new file mode 100644
&gt; index 0000000000..9438578e1e
&gt; --- /dev/null
&gt; +++ b/tests/qtest/iommu-riscv-test.c
&gt; @@ -0,0 +1,279 @@
&gt; +/*
&gt; + * QTest testcase for RISC-V IOMMU with iommu-testdev
&gt; + *
&gt; + * This QTest file is used to test the RISC-V IOMMU with iommu-testdev so that
&gt; + * we can test RISC-V IOMMU without any guest kernel or firmware.
&gt; + *
&gt; + * Copyright (c) 2026 Chao Liu &lt;chao.liu.zevorn@gmail.com&gt;
&gt; + *
&gt; + * SPDX-License-Identifier: GPL-2.0-or-later
&gt; + */
&gt; +
&gt; +#include "qemu/osdep.h"
&gt; +#include "libqtest.h"
&gt; +#include "libqos/pci.h"
&gt; +#include "libqos/generic-pcihost.h"
&gt; +#include "hw/pci/pci_regs.h"
&gt; +#include "hw/misc/iommu-testdev.h"
&gt; +#include "hw/riscv/riscv-iommu-bits.h"
&gt; +#include "libqos/qos-riscv-iommu.h"
&gt; +#include "libqos/riscv-iommu.h"
&gt; +
&gt; +#define DMA_LEN           4
&gt; +
&gt; +/* RISC-V virt machine PCI configuration */
&gt; +#define RISCV_GPEX_PIO_BASE        0x3000000
&gt; +#define RISCV_BUS_PIO_LIMIT        0x10000
&gt; +#define RISCV_BUS_MMIO_ALLOC_PTR   0x40000000
&gt; +#define RISCV_BUS_MMIO_LIMIT       0x80000000
&gt; +#define RISCV_ECAM_ALLOC_PTR       0x30000000
&gt; +
&gt; +typedef struct RiscvIommuTestState {
&gt; +    QTestState *qts;
&gt; +    QGenericPCIBus gbus;
&gt; +    QPCIDevice *iommu_dev;
&gt; +    QPCIDevice *testdev;
&gt; +    QPCIBar testdev_bar;
&gt; +    uint64_t iommu_base;
&gt; +} RiscvIommuTestState;
&gt; +
&gt; +static void riscv_config_qpci_bus(QGenericPCIBus *qpci)
&gt; +{
&gt; +    qpci-&gt;gpex_pio_base = RISCV_GPEX_PIO_BASE;
&gt; +    qpci-&gt;bus.pio_limit = RISCV_BUS_PIO_LIMIT;
&gt; +    qpci-&gt;bus.mmio_alloc_ptr = RISCV_BUS_MMIO_ALLOC_PTR;
&gt; +    qpci-&gt;bus.mmio_limit = RISCV_BUS_MMIO_LIMIT;
&gt; +    qpci-&gt;ecam_alloc_ptr = RISCV_ECAM_ALLOC_PTR;
&gt; +}
&gt; +
&gt; +static uint64_t riscv_iommu_expected_gpa(uint64_t iova)
&gt; +{
&gt; +    return QRIOMMU_SPACE_OFFS + QRIOMMU_L2_PTE_VAL + (iova &amp; 0xfff);
&gt; +}
&gt; +
&gt; +static void save_fn(QPCIDevice *dev, int devfn, void *data)
&gt; +{
&gt; +    QPCIDevice **pdev = (QPCIDevice **) data;
&gt; +    uint16_t vendor = qpci_config_readw(dev, 0);
&gt; +    uint16_t device = qpci_config_readw(dev, 2);
&gt; +
&gt; +    g_test_message("Found PCI device: vendor=0x%04x device=0x%04x devfn=0x%02x",
&gt; +                   vendor, device, devfn);
&gt; +
&gt; +    if (!*pdev) {
&gt; +        *pdev = dev;
&gt; +    }
&gt; +}
&gt; +
&gt; +static QPCIDevice *find_riscv_iommu_pci(QGenericPCIBus *gbus,
&gt; +                                        uint64_t *iommu_base)
&gt; +{
&gt; +    QPCIDevice *iommu_dev = NULL;
&gt; +    QPCIBar iommu_bar;
&gt; +
&gt; +    g_test_message("Searching for riscv-iommu-pci "
&gt; +                   "(vendor=0x%04x, device=0x%04x)",
&gt; +                   RISCV_IOMMU_PCI_VENDOR_ID, RISCV_IOMMU_PCI_DEVICE_ID);
&gt; +
&gt; +    qpci_device_foreach(&amp;gbus-&gt;bus, RISCV_IOMMU_PCI_VENDOR_ID,
&gt; +                        RISCV_IOMMU_PCI_DEVICE_ID, save_fn, &amp;iommu_dev);
&gt; +
&gt; +    if (!iommu_dev) {
&gt; +        g_test_message("riscv-iommu-pci device not found!");
&gt; +        return NULL;
&gt; +    }
&gt; +
&gt; +    g_test_message("Found riscv-iommu-pci at devfn=0x%02x", iommu_dev-&gt;devfn);
&gt; +
&gt; +    qpci_device_enable(iommu_dev);
&gt; +    iommu_bar = qpci_iomap(iommu_dev, 0, NULL);
&gt; +    g_assert_false(iommu_bar.is_io);
&gt; +
&gt; +    *iommu_base = iommu_bar.addr;
&gt; +    g_test_message("RISC-V IOMMU MMIO base address: 0x%lx", *iommu_base);
&gt; +
&gt; +    return iommu_dev;
&gt; +}
&gt; +
&gt; +static QPCIDevice *find_iommu_testdev(QGenericPCIBus *gbus, QPCIBar *bar)
&gt; +{
&gt; +    QPCIDevice *dev = NULL;
&gt; +
&gt; +    g_test_message("Searching for iommu-testdev (vendor=0x%04x, device=0x%04x)",
&gt; +                   IOMMU_TESTDEV_VENDOR_ID, IOMMU_TESTDEV_DEVICE_ID);
&gt; +
&gt; +    qpci_device_foreach(&amp;gbus-&gt;bus, IOMMU_TESTDEV_VENDOR_ID,
&gt; +                        IOMMU_TESTDEV_DEVICE_ID, save_fn, &amp;dev);
&gt; +    g_assert(dev);
&gt; +
&gt; +    qpci_device_enable(dev);
&gt; +    *bar = qpci_iomap(dev, 0, NULL);
&gt; +    g_assert_false(bar-&gt;is_io);
&gt; +
&gt; +    return dev;
&gt; +}
&gt; +
&gt; +static bool riscv_iommu_test_setup(RiscvIommuTestState *state)
&gt; +{
&gt; +    if (!qtest_has_machine("virt")) {
&gt; +        g_test_skip("virt machine not available");
&gt; +        return false;
&gt; +    }
&gt; +
&gt; +    state-&gt;qts = qtest_init("-machine virt,acpi=off "
&gt; +                            "-cpu max -smp 1 -m 512 -net none "
&gt; +                            "-device riscv-iommu-pci "
&gt; +                            "-device iommu-testdev");
&gt; +
&gt; +    qpci_init_generic(&amp;state-&gt;gbus, state-&gt;qts, NULL, false);
&gt; +    riscv_config_qpci_bus(&amp;state-&gt;gbus);
&gt; +
&gt; +    state-&gt;iommu_dev = find_riscv_iommu_pci(&amp;state-&gt;gbus, &amp;state-&gt;iommu_base);
&gt; +    g_assert(state-&gt;iommu_dev);
&gt; +
&gt; +    state-&gt;testdev = find_iommu_testdev(&amp;state-&gt;gbus, &amp;state-&gt;testdev_bar);
&gt; +    g_assert(state-&gt;testdev);
&gt; +
&gt; +    return true;
&gt; +}
&gt; +
&gt; +static void riscv_iommu_test_teardown(RiscvIommuTestState *state)
&gt; +{
&gt; +    qtest_quit(state-&gt;qts);
&gt; +}
&gt; +
&gt; +static uint64_t riscv_iommu_check(QTestState *qts, uint64_t iommu_base,
&gt; +                                  QRIOMMUTransMode mode)
&gt; +{
&gt; +    uint64_t cap;
&gt; +    uint64_t ddtp;
&gt; +    uint32_t cqcsr;
&gt; +    uint32_t fqcsr;
&gt; +    uint32_t pqcsr;
&gt; +    uint32_t fctl;
&gt; +    uint32_t fctl_mask;
&gt; +    uint32_t fctl_desired;
&gt; +    uint32_t igs;
&gt; +
&gt; +    cap = qtest_readq(qts, iommu_base + RISCV_IOMMU_REG_CAP);
&gt; +    g_assert_cmpuint((uint32_t)(cap &amp; RISCV_IOMMU_CAP_VERSION), ==,
&gt; +                     RISCV_IOMMU_SPEC_DOT_VER);
&gt; +
&gt; +    fctl = qtest_readl(qts, iommu_base + RISCV_IOMMU_REG_FCTL);
&gt; +    igs = (cap &amp; RISCV_IOMMU_CAP_IGS) &gt;&gt; 28;
&gt; +    g_assert_cmpuint(igs, &lt;=, RISCV_IOMMU_CAP_IGS_BOTH);
&gt; +
&gt; +    fctl_mask = RISCV_IOMMU_FCTL_BE | RISCV_IOMMU_FCTL_WSI |
&gt; +                RISCV_IOMMU_FCTL_GXL;
&gt; +    fctl_desired = fctl &amp; ~fctl_mask;
&gt; +    if (igs == RISCV_IOMMU_CAP_IGS_WSI) {
&gt; +        fctl_desired |= RISCV_IOMMU_FCTL_WSI;
&gt; +    }
&gt; +
&gt; +    if ((fctl &amp; fctl_mask) != (fctl_desired &amp; fctl_mask)) {
&gt; +        ddtp = qtest_readq(qts, iommu_base + RISCV_IOMMU_REG_DDTP);
&gt; +        cqcsr = qtest_readl(qts, iommu_base + RISCV_IOMMU_REG_CQCSR);
&gt; +        fqcsr = qtest_readl(qts, iommu_base + RISCV_IOMMU_REG_FQCSR);
&gt; +        pqcsr = qtest_readl(qts, iommu_base + RISCV_IOMMU_REG_PQCSR);
&gt; +
&gt; +        g_assert_cmpuint((uint32_t)(ddtp &amp; RISCV_IOMMU_DDTP_MODE), ==,
&gt; +                         RISCV_IOMMU_DDTP_MODE_OFF);
&gt; +        g_assert_cmpuint(cqcsr &amp; RISCV_IOMMU_CQCSR_CQON, ==, 0);
&gt; +        g_assert_cmpuint(fqcsr &amp; RISCV_IOMMU_FQCSR_FQON, ==, 0);
&gt; +        g_assert_cmpuint(pqcsr &amp; RISCV_IOMMU_PQCSR_PQON, ==, 0);
&gt; +
&gt; +        qtest_writel(qts, iommu_base + RISCV_IOMMU_REG_FCTL, fctl_desired);
&gt; +        fctl = qtest_readl(qts, iommu_base + RISCV_IOMMU_REG_FCTL);
&gt; +    }
&gt; +
&gt; +    g_assert_cmpuint(fctl &amp; fctl_mask, ==, fctl_desired &amp; fctl_mask);
&gt; +
&gt; +    if (mode == QRIOMMU_TM_S_STAGE_ONLY || mode == QRIOMMU_TM_NESTED) {
&gt; +        g_assert((cap &amp; RISCV_IOMMU_CAP_SV39) != 0);
&gt; +    }
&gt; +    if (mode == QRIOMMU_TM_G_STAGE_ONLY || mode == QRIOMMU_TM_NESTED) {
&gt; +        g_assert((cap &amp; RISCV_IOMMU_CAP_SV39X4) != 0);
&gt; +        g_assert_cmpuint(fctl &amp; RISCV_IOMMU_FCTL_GXL, ==, 0);
&gt; +    }
&gt; +
&gt; +    return cap;
&gt; +}
&gt; +
&gt; +static void run_riscv_iommu_translation(const QRIOMMUTestConfig *cfg)
&gt; +{
&gt; +    RiscvIommuTestState state = { 0 };
&gt; +
&gt; +    if (!riscv_iommu_test_setup(&amp;state)) {
&gt; +        return;
&gt; +    }
&gt; +
&gt; +    riscv_iommu_check(state.qts, state.iommu_base, cfg-&gt;trans_mode);
&gt; +
&gt; +    g_test_message("### RISC-V IOMMU translation mode=%d ###",
&gt; +                   cfg-&gt;trans_mode);
&gt; +    qriommu_run_translation_case(state.qts, state.testdev, state.testdev_bar,
&gt; +                                 state.iommu_base, cfg);
&gt; +    riscv_iommu_test_teardown(&amp;state);
&gt; +}
&gt; +
&gt; +static void test_riscv_iommu_bare(void)
&gt; +{
&gt; +    QRIOMMUTestConfig cfg = {
&gt; +        .trans_mode = QRIOMMU_TM_BARE,
&gt; +        .dma_gpa = QRIOMMU_IOVA,
&gt; +        .dma_len = DMA_LEN,
&gt; +        .expected_result = 0,
&gt; +    };
&gt; +
&gt; +    run_riscv_iommu_translation(&amp;cfg);
&gt; +}
&gt; +
&gt; +static void test_riscv_iommu_s_stage_only(void)
&gt; +{
&gt; +    QRIOMMUTestConfig cfg = {
&gt; +        .trans_mode = QRIOMMU_TM_S_STAGE_ONLY,
&gt; +        .dma_gpa = riscv_iommu_expected_gpa(QRIOMMU_IOVA),
&gt; +        .dma_len = DMA_LEN,
&gt; +        .expected_result = 0,
&gt; +    };
&gt; +
&gt; +    run_riscv_iommu_translation(&amp;cfg);
&gt; +}
&gt; +
&gt; +static void test_riscv_iommu_g_stage_only(void)
&gt; +{
&gt; +    QRIOMMUTestConfig cfg = {
&gt; +        .trans_mode = QRIOMMU_TM_G_STAGE_ONLY,
&gt; +        .dma_gpa = riscv_iommu_expected_gpa(QRIOMMU_IOVA),
&gt; +        .dma_len = DMA_LEN,
&gt; +        .expected_result = 0,
&gt; +    };
&gt; +
&gt; +    run_riscv_iommu_translation(&amp;cfg);
&gt; +}
&gt; +
&gt; +static void test_riscv_iommu_nested(void)
&gt; +{
&gt; +    QRIOMMUTestConfig cfg = {
&gt; +        .trans_mode = QRIOMMU_TM_NESTED,
&gt; +        .dma_gpa = riscv_iommu_expected_gpa(QRIOMMU_IOVA),
&gt; +        .dma_len = DMA_LEN,
&gt; +        .expected_result = 0,
&gt; +    };
&gt; +
&gt; +    run_riscv_iommu_translation(&amp;cfg);
&gt; +}
&gt; +
&gt; +int main(int argc, char **argv)
&gt; +{
&gt; +    g_test_init(&amp;argc, &amp;argv, NULL);
&gt; +    qtest_add_func("/iommu-testdev/translation/bare",
&gt; +                   test_riscv_iommu_bare);
&gt; +    qtest_add_func("/iommu-testdev/translation/s-stage-only",
&gt; +                   test_riscv_iommu_s_stage_only);
&gt; +    qtest_add_func("/iommu-testdev/translation/g-stage-only",
&gt; +                   test_riscv_iommu_g_stage_only);
&gt; +    qtest_add_func("/iommu-testdev/translation/ns-nested",
&gt; +                   test_riscv_iommu_nested);
&gt; +    return g_test_run();
&gt; +}
&gt; diff --git a/tests/qtest/meson.build b/tests/qtest/meson.build
&gt; index a8b09d065f..eb45e0f97d 100644
&gt; --- a/tests/qtest/meson.build
&gt; +++ b/tests/qtest/meson.build
&gt; @@ -286,7 +286,10 @@ qtests_riscv32 = \n&gt;     (config_all_devices.has_key('CONFIG_SIFIVE_E_AON') ? ['sifive-e-aon-watchdog-test'] : [])
&gt;   
&gt;   qtests_riscv64 = ['riscv-csr-test'] + \n&gt; -  (unpack_edk2_blobs ? ['bios-tables-test'] : [])
&gt; +  (unpack_edk2_blobs ? ['bios-tables-test'] : []) + \n&gt; +  (config_all_devices.has_key('CONFIG_IOMMU_TESTDEV') and
&gt; +   config_all_devices.has_key('CONFIG_RISCV_IOMMU') ?
&gt; +   ['iommu-riscv-test'] : [])
&gt;   
&gt;   qos_test_ss = ss.source_set()
&gt;   qos_test_ss.add(
</span>


<a href="#m225bb7c105a86bd5763acc6b70063b62327f191d" id="e225bb7c105a86bd5763acc6b70063b62327f191d">^</a> <a href="../../cd8bc37a-c9ef-4f31-a024-fac24b74613e@ventanamicro.com/">permalink</a> <a href="../../cd8bc37a-c9ef-4f31-a024-fac24b74613e@ventanamicro.com/raw">raw</a> <a href="../../cd8bc37a-c9ef-4f31-a024-fac24b74613e@ventanamicro.com/#R">reply</a>	[<a href="../../cd8bc37a-c9ef-4f31-a024-fac24b74613e@ventanamicro.com/T/#u"><b>flat</b></a>|<a href="../../cd8bc37a-c9ef-4f31-a024-fac24b74613e@ventanamicro.com/t/#u">nested</a>] <a href="#r225bb7c105a86bd5763acc6b70063b62327f191d">13+ messages in thread</a></pre><hr><pre><a href="#e3469b37b570b142238cad69d7b5d435673adf0f8" id="m3469b37b570b142238cad69d7b5d435673adf0f8">*</a> <b>Re: [RFC PATCH v1 0/2] tests/qtest: Add RISC-V IOMMU bare-metal test using iommu-testdev</b>
  2026-01-28 12:09 <a href="#m73ac81ff33885a502d30d54b8cea4dcbaa767349">[RFC PATCH v1 0/2] tests/qtest: Add RISC-V IOMMU bare-metal test using iommu-testdev</a> Chao Liu
  2026-01-28 12:09 ` <a href="#m9559a467360037b0fb0cd48d1cbad2b91a076885">[RFC PATCH v1 1/2] tests/qtest/libqos: Add RISC-V IOMMU helper library</a> Chao Liu
  2026-01-28 12:09 ` <a href="#m351dceb4c1fd03d15423922990cc16cc7f3f55d9">[RFC PATCH v1 2/2] tests/qtest: Add RISC-V IOMMU bare-metal test</a> Chao Liu
<b>@ 2026-01-28 14:42 ` Daniel Henrique Barboza</b>
  2026-01-28 16:25   ` <a href="#md2e478315f3a497a04cf4723c11de56fce9a1c9b">Chao Liu</a>
  2026-01-28 14:54 ` <a href="#m24f461ed1166131dbfd5c478e2d918856776bc5d">Tao Tang</a>
  <a href="#r3469b37b570b142238cad69d7b5d435673adf0f8">3 siblings, 1 reply; 13+ messages in thread</a>
From: Daniel Henrique Barboza @ 2026-01-28 14:42 UTC (<a href="../../97143bc3-b473-4e72-877c-b3bf9a70819d@ventanamicro.com/">permalink</a> / <a href="../../97143bc3-b473-4e72-877c-b3bf9a70819d@ventanamicro.com/raw">raw</a>)
  To: Chao Liu, Alistair Francis, Palmer Dabbelt, Weiwei Li, Liu Zhiwei,
	Fabiano Rosas, Laurent Vivier, Paolo Bonzini, Tao Tang
  Cc: <a href="../../../qemu-devel/?t=20260128144356">qemu-devel</a>, <a href="../../../qemu-riscv/?t=20260128144356">qemu-riscv</a>, hust-os-kernel-patches



On 1/28/2026 9:09 AM, Chao Liu wrote:
<span class="q">&gt; Hi,
&gt; 
&gt; This patch series adds a bare-metal qtest for the RISC-V IOMMU using the
&gt; iommu-testdev framework. The test exercises address translation paths
&gt; without requiring a full guest OS boot.
&gt; 
&gt; Motivation
&gt; ----------
&gt; 
&gt; The existing RISC-V IOMMU qtest (riscv-iommu-test.c) focuses on PCI device
&gt; enumeration and register-level validation:
&gt; - PCI configuration space verification (vendor/device ID)
&gt; - Register reset value checks
&gt; - Queue initialization procedures (CQ/FQ/PQ)
&gt; 
&gt; However, it does not test the actual address translation functionality.
&gt; This new test fills that gap by using iommu-testdev to trigger DMA
&gt; transactions and validate the IOMMU's translation logic.
&gt; 
&gt; Comparison with Existing Test
&gt; -----------------------------
&gt; 
&gt; | Feature               | riscv-iommu-test.c | iommu-riscv-test.c (new) |
&gt; |-----------------------|--------------------|--------------------------|
&gt; | PCI config            | Yes                | No                       |
&gt; | Register reset        | Yes                | No                       |
&gt; | Queue init            | Yes                | Yes (via helper)         |
&gt; | Bare translation      | No                 | Yes                      |
&gt; | S-stage (SV39)        | No                 | Yes                      |
&gt; | G-stage (SV39x4)      | No                 | Yes                      |
&gt; | Nested translation    | No                 | Yes                      |
&gt; | DMA verification      | No                 | Yes                      |
&gt; | Uses iommu-testdev    | No                 | Yes                      |
&gt; 
&gt; The new test provides:
&gt; - Device context (DC) configuration and validation
&gt; - SV39 page table walks for S-stage translation
&gt; - SV39x4 page table walks for G-stage translation
&gt; - Nested translation combining both stages
&gt; - FCTL register constraint validation
&gt; - End-to-end DMA verification
</span>
I have a customized environment just to test IOMMU stuff (boot an Ubuntu 
emulated RISC-V host, see if the riscv-iommu works with a PCI net card). 
And even then this kind of test is limited by the amount of stuff the 
current Linux driver is capable of doing. And yet I have to at least 
give it a try with every IOMMU change/fix sent ... This new test will 
give us additional coverage that neither the existing test nor my manual 
testing can provide.

Thank you for the time and effort putting into this work. This is really 
remarkable.

<span class="q">&gt; 
&gt; Note: The current implementation only supports SV39/SV39x4. Support for
&gt; SV48/SV48x4/SV57/SV57x4 can be added in future patches.
&gt; 
&gt; Testing
&gt; -------
&gt; 
&gt; QTEST_QEMU_BINARY=./build/qemu-system-riscv64 \n&gt;    ./build/tests/qtest/iommu-riscv-test --tap -k
&gt; 
&gt; Question for Maintainers
&gt; ------------------------
&gt; 
&gt; The existing riscv-iommu-test.c and the new iommu-riscv-test.c serve
&gt; complementary purposes. Would it be beneficial to merge these two tests
&gt; into a single source file for easier maintenance? This would consolidate
&gt; all RISC-V IOMMU testing in one place while preserving both the
&gt; register-level and translation-level test coverage.
</span>
I'll give my non-maintainer opinion because I happen to be the author of 
riscv-iommu-test.c: as long as we preserve the existing tests for both 
files I'm ok with it. Maybe there are code re-use opportunities that 
will be exposed when merging the 2 together.

But I believe this can wait. We should push this upstream first (or at 
least get it queued into the maintainer's tree).


Thanks,
Daniel

<span class="q">&gt; 
&gt; Thanks,
&gt; Chao
&gt; 
&gt; Chao Liu (2):
&gt;    tests/qtest/libqos: Add RISC-V IOMMU helper library
&gt;    tests/qtest: Add RISC-V IOMMU bare-metal test
&gt; 
&gt;   MAINTAINERS                          |   2 +
&gt;   tests/qtest/iommu-riscv-test.c       | 279 +++++++++++++++++++
&gt;   tests/qtest/libqos/meson.build       |   2 +-
&gt;   tests/qtest/libqos/qos-riscv-iommu.c | 400 +++++++++++++++++++++++++++
&gt;   tests/qtest/libqos/qos-riscv-iommu.h | 172 ++++++++++++
&gt;   tests/qtest/meson.build              |   5 +-
&gt;   6 files changed, 858 insertions(+), 2 deletions(-)
&gt;   create mode 100644 tests/qtest/iommu-riscv-test.c
&gt;   create mode 100644 tests/qtest/libqos/qos-riscv-iommu.c
&gt;   create mode 100644 tests/qtest/libqos/qos-riscv-iommu.h
&gt; 
&gt; --
&gt; 2.52.0
&gt; 
</span>


<a href="#m3469b37b570b142238cad69d7b5d435673adf0f8" id="e3469b37b570b142238cad69d7b5d435673adf0f8">^</a> <a href="../../97143bc3-b473-4e72-877c-b3bf9a70819d@ventanamicro.com/">permalink</a> <a href="../../97143bc3-b473-4e72-877c-b3bf9a70819d@ventanamicro.com/raw">raw</a> <a href="../../97143bc3-b473-4e72-877c-b3bf9a70819d@ventanamicro.com/#R">reply</a>	[<a href="../../97143bc3-b473-4e72-877c-b3bf9a70819d@ventanamicro.com/T/#u"><b>flat</b></a>|<a href="../../97143bc3-b473-4e72-877c-b3bf9a70819d@ventanamicro.com/t/#u">nested</a>] <a href="#r3469b37b570b142238cad69d7b5d435673adf0f8">13+ messages in thread</a></pre><hr><pre><a href="#e24f461ed1166131dbfd5c478e2d918856776bc5d" id="m24f461ed1166131dbfd5c478e2d918856776bc5d">*</a> <b>Re: [RFC PATCH v1 0/2] tests/qtest: Add RISC-V IOMMU bare-metal test using iommu-testdev</b>
  2026-01-28 12:09 <a href="#m73ac81ff33885a502d30d54b8cea4dcbaa767349">[RFC PATCH v1 0/2] tests/qtest: Add RISC-V IOMMU bare-metal test using iommu-testdev</a> Chao Liu
                   ` <a href="#r3469b37b570b142238cad69d7b5d435673adf0f8">(2 preceding siblings ...)</a>
  2026-01-28 14:42 ` <a href="#m3469b37b570b142238cad69d7b5d435673adf0f8">[RFC PATCH v1 0/2] tests/qtest: Add RISC-V IOMMU bare-metal test using iommu-testdev</a> Daniel Henrique Barboza
<b>@ 2026-01-28 14:54 ` Tao Tang</b>
  <a href="#r24f461ed1166131dbfd5c478e2d918856776bc5d">3 siblings, 0 replies; 13+ messages in thread</a>
From: Tao Tang @ 2026-01-28 14:54 UTC (<a href="../../b5d6c6d7-5a85-4c8a-907b-7c12a2c88ae6@phytium.com.cn/">permalink</a> / <a href="../../b5d6c6d7-5a85-4c8a-907b-7c12a2c88ae6@phytium.com.cn/raw">raw</a>)
  To: Chao Liu, Alistair Francis, Daniel Henrique Barboza,
	Palmer Dabbelt, Weiwei Li, Liu Zhiwei, Fabiano Rosas,
	Laurent Vivier, Paolo Bonzini
  Cc: <a href="../../../qemu-devel/?t=20260128150341">qemu-devel</a>, <a href="../../../qemu-riscv/?t=20260128150341">qemu-riscv</a>, hust-os-kernel-patches

Hi Chao,

On 2026/1/28 20:09, Chao Liu wrote:
<span class="q">&gt; Hi,
&gt;
&gt; This patch series adds a bare-metal qtest for the RISC-V IOMMU using the
&gt; iommu-testdev framework. The test exercises address translation paths
&gt; without requiring a full guest OS boot.
</span>

Thanks a lot for working on this and for sending the series.

It's great to see iommu-testdev being used so soon — it’s only been a 
week since it was added, and you already have a nice RISC-V IOMMU 
translation test based on it.


Best regards,

Tao


<span class="q">&gt;
&gt; Motivation
&gt; ----------
&gt;
&gt; The existing RISC-V IOMMU qtest (riscv-iommu-test.c) focuses on PCI device
&gt; enumeration and register-level validation:
&gt; - PCI configuration space verification (vendor/device ID)
&gt; - Register reset value checks
&gt; - Queue initialization procedures (CQ/FQ/PQ)
&gt;
&gt; However, it does not test the actual address translation functionality.
&gt; This new test fills that gap by using iommu-testdev to trigger DMA
&gt; transactions and validate the IOMMU's translation logic.
&gt;
&gt; Comparison with Existing Test
&gt; -----------------------------
&gt;
&gt; | Feature               | riscv-iommu-test.c | iommu-riscv-test.c (new) |
&gt; |-----------------------|--------------------|--------------------------|
&gt; | PCI config            | Yes                | No                       |
&gt; | Register reset        | Yes                | No                       |
&gt; | Queue init            | Yes                | Yes (via helper)         |
&gt; | Bare translation      | No                 | Yes                      |
&gt; | S-stage (SV39)        | No                 | Yes                      |
&gt; | G-stage (SV39x4)      | No                 | Yes                      |
&gt; | Nested translation    | No                 | Yes                      |
&gt; | DMA verification      | No                 | Yes                      |
&gt; | Uses iommu-testdev    | No                 | Yes                      |
&gt;
&gt; The new test provides:
&gt; - Device context (DC) configuration and validation
&gt; - SV39 page table walks for S-stage translation
&gt; - SV39x4 page table walks for G-stage translation
&gt; - Nested translation combining both stages
&gt; - FCTL register constraint validation
&gt; - End-to-end DMA verification
&gt;
&gt; Note: The current implementation only supports SV39/SV39x4. Support for
&gt; SV48/SV48x4/SV57/SV57x4 can be added in future patches.
&gt;
&gt; Testing
&gt; -------
&gt;
&gt; QTEST_QEMU_BINARY=./build/qemu-system-riscv64 \n&gt;    ./build/tests/qtest/iommu-riscv-test --tap -k
&gt;
&gt; Question for Maintainers
&gt; ------------------------
&gt;
&gt; The existing riscv-iommu-test.c and the new iommu-riscv-test.c serve
&gt; complementary purposes. Would it be beneficial to merge these two tests
&gt; into a single source file for easier maintenance? This would consolidate
&gt; all RISC-V IOMMU testing in one place while preserving both the
&gt; register-level and translation-level test coverage.
&gt;
&gt; Thanks,
&gt; Chao
&gt;
&gt; Chao Liu (2):
&gt;    tests/qtest/libqos: Add RISC-V IOMMU helper library
&gt;    tests/qtest: Add RISC-V IOMMU bare-metal test
&gt;
&gt;   MAINTAINERS                          |   2 +
&gt;   tests/qtest/iommu-riscv-test.c       | 279 +++++++++++++++++++
&gt;   tests/qtest/libqos/meson.build       |   2 +-
&gt;   tests/qtest/libqos/qos-riscv-iommu.c | 400 +++++++++++++++++++++++++++
&gt;   tests/qtest/libqos/qos-riscv-iommu.h | 172 ++++++++++++
&gt;   tests/qtest/meson.build              |   5 +-
&gt;   6 files changed, 858 insertions(+), 2 deletions(-)
&gt;   create mode 100644 tests/qtest/iommu-riscv-test.c
&gt;   create mode 100644 tests/qtest/libqos/qos-riscv-iommu.c
&gt;   create mode 100644 tests/qtest/libqos/qos-riscv-iommu.h
&gt;
&gt; --
&gt; 2.52.0
</span>




<a href="#m24f461ed1166131dbfd5c478e2d918856776bc5d" id="e24f461ed1166131dbfd5c478e2d918856776bc5d">^</a> <a href="../../b5d6c6d7-5a85-4c8a-907b-7c12a2c88ae6@phytium.com.cn/">permalink</a> <a href="../../b5d6c6d7-5a85-4c8a-907b-7c12a2c88ae6@phytium.com.cn/raw">raw</a> <a href="../../b5d6c6d7-5a85-4c8a-907b-7c12a2c88ae6@phytium.com.cn/#R">reply</a>	[<a href="../../b5d6c6d7-5a85-4c8a-907b-7c12a2c88ae6@phytium.com.cn/T/#u"><b>flat</b></a>|<a href="../../b5d6c6d7-5a85-4c8a-907b-7c12a2c88ae6@phytium.com.cn/t/#u">nested</a>] <a href="#r24f461ed1166131dbfd5c478e2d918856776bc5d">13+ messages in thread</a></pre><hr><pre><a href="#e47ec136efcc6562c3cb0be5024eb931e13b96868" id="m47ec136efcc6562c3cb0be5024eb931e13b96868">*</a> <b>Re: [RFC PATCH v1 1/2] tests/qtest/libqos: Add RISC-V IOMMU helper library</b>
  2026-01-28 12:09 ` <a href="#m9559a467360037b0fb0cd48d1cbad2b91a076885">[RFC PATCH v1 1/2] tests/qtest/libqos: Add RISC-V IOMMU helper library</a> Chao Liu
  2026-01-28 14:30   ` <a href="#mcb58b9919dda00cefe12d0ce47612540c7bdda90">Daniel Henrique Barboza</a>
<b>@ 2026-01-28 15:23   ` Tao Tang</b>
  2026-01-28 15:45     ` <a href="#md4ab43b6667cfd798638f36984d5dfce06909dc3">Chao Liu</a>
  2026-01-29  1:59   ` <a href="#md2721ada56e836596debf9456a222cba2cf28cb7">Tao Tang</a>
  <a href="#r47ec136efcc6562c3cb0be5024eb931e13b96868">2 siblings, 1 reply; 13+ messages in thread</a>
From: Tao Tang @ 2026-01-28 15:23 UTC (<a href="../../d11e9d1e-a209-4142-a742-170fcecefbf7@phytium.com.cn/">permalink</a> / <a href="../../d11e9d1e-a209-4142-a742-170fcecefbf7@phytium.com.cn/raw">raw</a>)
  To: Chao Liu, Alistair Francis, Daniel Henrique Barboza,
	Palmer Dabbelt, Weiwei Li, Liu Zhiwei, Fabiano Rosas,
	Laurent Vivier, Paolo Bonzini
  Cc: <a href="../../../qemu-devel/?t=20260128152350">qemu-devel</a>, <a href="../../../qemu-riscv/?t=20260128152350">qemu-riscv</a>, hust-os-kernel-patches

Hi Chao,

On 2026/1/28 20:09, Chao Liu wrote:
<span class="q">&gt; Introduce a libqos helper module for RISC-V IOMMU testing with
&gt; iommu-testdev. The helper provides routines to:
&gt;
&gt; - Build device contexts (DC) and 3-level page tables for SV39/SV39x4
&gt; - Program command queue (CQ), fault queue (FQ), and DDTP registers
&gt;    following the RISC-V IOMMU specification
&gt; - Execute DMA translations and verify results
&gt;
&gt; The current implementation supports SV39 for S-stage and SV39x4 for
&gt; G-stage translation. Support for SV48/SV48x4/SV57/SV57x4 can be added
&gt; in future patches.
&gt;
&gt; Signed-off-by: Chao Liu &lt;chao.liu.zevorn@gmail.com&gt;
&gt; ---
&gt;   MAINTAINERS                          |   1 +
&gt;   tests/qtest/libqos/meson.build       |   2 +-
&gt;   tests/qtest/libqos/qos-riscv-iommu.c | 400 +++++++++++++++++++++++++++
&gt;   tests/qtest/libqos/qos-riscv-iommu.h | 172 ++++++++++++
&gt;   4 files changed, 574 insertions(+), 1 deletion(-)
&gt;   create mode 100644 tests/qtest/libqos/qos-riscv-iommu.c
&gt;   create mode 100644 tests/qtest/libqos/qos-riscv-iommu.h
&gt;
&gt; diff --git a/MAINTAINERS b/MAINTAINERS
&gt; index dc31be033e..894e05bd2c 100644
&gt; --- a/MAINTAINERS
&gt; +++ b/MAINTAINERS
&gt; @@ -3583,6 +3583,7 @@ M: Tao Tang &lt;tangtao1634@phytium.com.cn&gt;
&gt;   S: Maintained
&gt;   F: tests/qtest/libqos/qos-iommu*
&gt;   F: tests/qtest/libqos/qos-smmuv3*
&gt; +F: tests/qtest/libqos/qos-riscv-iommu*
&gt;   
&gt;   Device Fuzzing
&gt;   M: Alexander Bulekov &lt;alxndr@bu.edu&gt;
&gt; diff --git a/tests/qtest/libqos/meson.build b/tests/qtest/libqos/meson.build
&gt; index b4daec808f..4a69acad0d 100644
&gt; --- a/tests/qtest/libqos/meson.build
&gt; +++ b/tests/qtest/libqos/meson.build
&gt; @@ -71,7 +71,7 @@ if have_virtfs
&gt;   endif
&gt;   
&gt;   if config_all_devices.has_key('CONFIG_RISCV_IOMMU')
&gt; -  libqos_srcs += files('riscv-iommu.c')
&gt; +  libqos_srcs += files('riscv-iommu.c', 'qos-riscv-iommu.c')
&gt;   endif
&gt;   if config_all_devices.has_key('CONFIG_TPCI200')
&gt;     libqos_srcs += files('tpci200.c')
&gt; diff --git a/tests/qtest/libqos/qos-riscv-iommu.c b/tests/qtest/libqos/qos-riscv-iommu.c
&gt; new file mode 100644
&gt; index 0000000000..34ed3df84a
&gt; --- /dev/null
&gt; +++ b/tests/qtest/libqos/qos-riscv-iommu.c
&gt; @@ -0,0 +1,400 @@
&gt; +/*
&gt; + * QOS RISC-V IOMMU Module
&gt; + *
&gt; + * This module provides RISC-V IOMMU-specific helper functions for libqos tests,
&gt; + * encapsulating RISC-V IOMMU setup, and assertions.
&gt; + *
&gt; + * Copyright (c) 2026 Chao Liu &lt;chao.liu.zevorn@gmail.com&gt;
&gt; + *
&gt; + * SPDX-License-Identifier: GPL-2.0-or-later
&gt; + */
&gt; +
&gt; +#include "qemu/osdep.h"
&gt; +#include "qemu/bitops.h"
&gt; +#include "hw/riscv/riscv-iommu-bits.h"
&gt; +#include "tests/qtest/libqos/pci.h"
&gt; +#include "qos-iommu-testdev.h"
&gt; +#include "qos-riscv-iommu.h"
&gt; +
&gt; +/* Apply space offset to address */
&gt; +static inline uint64_t qriommu_apply_space_offs(uint64_t address)
&gt; +{
&gt; +    return address + QRIOMMU_SPACE_OFFS;
&gt; +}
</span>

In the original SMMU/iommu-testdev work, I introduced a similar “base 
offset” mainly to make room for future expansion where the same test 
code needs to exercise multiple security domains (e.g., Arm Non-secure 
vs Secure vs Realm), which in QEMU is reflected via distinct address 
spaces / MemTxAttrs (the space field).

I’m not very familiar with the RISC-V security model. In RISC-V, do you 
foresee a comparable need to test multiple “security states” for DMA 
transactions?

<span class="q">&gt; +
&gt; +static uint64_t qriommu_encode_pte(uint64_t pa, uint64_t attrs)
&gt; +{
&gt; +    return ((pa &gt;&gt; 12) &lt;&lt; 10) | attrs;
&gt; +}
&gt; +
&gt; +static void qriommu_wait_for_queue_active(QTestState *qts, uint64_t iommu_base,
&gt; +                                          uint32_t queue_csr, uint32_t on_bit)
&gt; +{
&gt; +    guint64 timeout_us = 2 * 1000 * 1000;
&gt; +    gint64 start_time = g_get_monotonic_time();
&gt; +    uint32_t reg;
&gt; +
&gt; +    for (;;) {
&gt; +        qtest_clock_step(qts, 100);
&gt; +
&gt; +        reg = qtest_readl(qts, iommu_base + queue_csr);
&gt; +        if (reg &amp; on_bit) {
&gt; +            return;
&gt; +        }
&gt; +        g_assert(g_get_monotonic_time() - start_time &lt;= timeout_us);
&gt; +    }
&gt; +}
&gt; +
&gt; +uint32_t qriommu_expected_dma_result(QRIOMMUTestContext *ctx)
&gt; +{
&gt; +    return ctx-&gt;config.expected_result;
&gt; +}
&gt; +
&gt; +uint32_t qriommu_build_dma_attrs(void)
&gt; +{
&gt; +    /* RISC-V IOMMU uses standard AXI attributes */
&gt; +    return 0;
&gt; +}
&gt; +
&gt; +uint32_t qriommu_setup_and_enable_translation(QRIOMMUTestContext *ctx)
&gt; +{
&gt; +    uint32_t build_result;
&gt; +
&gt; +    /* Build page tables and RISC-V IOMMU structures first */
&gt; +    build_result = qriommu_build_translation(
&gt; +                       ctx-&gt;qts, ctx-&gt;config.trans_mode,
&gt; +                       ctx-&gt;device_id);
&gt; +    if (build_result != 0) {
&gt; +        g_test_message("Build failed: mode=%u device_id=%u status=0x%x",
&gt; +                       ctx-&gt;config.trans_mode, ctx-&gt;device_id, build_result);
&gt; +        ctx-&gt;trans_status = build_result;
&gt; +        return ctx-&gt;trans_status;
&gt; +    }
&gt; +
&gt; +    /* Program RISC-V IOMMU registers */
&gt; +    qriommu_program_regs(ctx-&gt;qts, ctx-&gt;iommu_base);
&gt; +
&gt; +    ctx-&gt;trans_status = 0;
&gt; +    return ctx-&gt;trans_status;
&gt; +}
&gt; +
&gt; +static bool qriommu_validate_test_result(QRIOMMUTestContext *ctx)
&gt; +{
&gt; +    uint32_t expected = qriommu_expected_dma_result(ctx);
&gt; +    g_test_message("-&gt; Validating result: expected=0x%x actual=0x%x",
&gt; +                   expected, ctx-&gt;dma_result);
&gt; +    return (ctx-&gt;dma_result == expected);
&gt; +}
&gt; +
&gt; +static uint32_t qriommu_single_translation_setup(void *opaque)
&gt; +{
&gt; +    return qriommu_setup_and_enable_translation(opaque);
&gt; +}
&gt; +
&gt; +static uint32_t qriommu_single_translation_attrs(void *opaque)
&gt; +{
&gt; +    return qriommu_build_dma_attrs();
&gt; +}
&gt; +
&gt; +static bool qriommu_single_translation_validate(void *opaque)
&gt; +{
&gt; +    return qriommu_validate_test_result(opaque);
&gt; +}
&gt; +
&gt; +static void qriommu_single_translation_report(void *opaque,
&gt; +                                              uint32_t dma_result)
&gt; +{
&gt; +    QRIOMMUTestContext *ctx = opaque;
&gt; +
&gt; +    if (dma_result != 0) {
&gt; +        g_test_message("DMA failed: mode=%u result=0x%x",
&gt; +                       ctx-&gt;config.trans_mode, dma_result);
&gt; +    } else {
&gt; +        g_test_message("-&gt; DMA succeeded: mode=%u",
&gt; +                       ctx-&gt;config.trans_mode);
&gt; +    }
&gt; +}
&gt; +
&gt; +void qriommu_run_translation_case(QTestState *qts, QPCIDevice *dev,
&gt; +                                  QPCIBar bar, uint64_t iommu_base,
&gt; +                                  const QRIOMMUTestConfig *cfg)
&gt; +{
&gt; +    QRIOMMUTestContext ctx = {
&gt; +        .qts = qts,
&gt; +        .dev = dev,
&gt; +        .bar = bar,
&gt; +        .iommu_base = iommu_base,
&gt; +        .config = *cfg,
&gt; +        .device_id = dev-&gt;devfn,
&gt; +    };
&gt; +
&gt; +    QOSIOMMUTestdevDmaCfg dma = {
&gt; +        .dev = dev,
&gt; +        .bar = bar,
&gt; +        .iova = QRIOMMU_IOVA,
&gt; +        .gpa = ctx.config.dma_gpa,
&gt; +        .len = ctx.config.dma_len,
&gt; +    };
&gt; +
&gt; +    qtest_memset(qts, cfg-&gt;dma_gpa, 0x00, cfg-&gt;dma_len);
&gt; +    qos_iommu_testdev_single_translation(&amp;dma, &amp;ctx,
&gt; +                                         qriommu_single_translation_setup,
&gt; +                                         qriommu_single_translation_attrs,
&gt; +                                         qriommu_single_translation_validate,
&gt; +                                         qriommu_single_translation_report,
&gt; +                                         &amp;ctx.dma_result);
&gt; +
&gt; +    if (ctx.dma_result == 0 &amp;&amp; ctx.config.expected_result == 0) {
&gt; +        g_autofree uint8_t *buf = NULL;
&gt; +
&gt; +        buf = g_malloc(ctx.config.dma_len);
&gt; +        qtest_memread(ctx.qts, ctx.config.dma_gpa, buf, ctx.config.dma_len);
&gt; +
&gt; +        for (int i = 0; i &lt; ctx.config.dma_len; i++) {
&gt; +            uint8_t expected;
&gt; +
&gt; +            expected = (ITD_DMA_WRITE_VAL &gt;&gt; ((i % 4) * 8)) &amp; 0xff;
&gt; +            g_assert_cmpuint(buf[i], ==, expected);
&gt; +        }
&gt; +    }
&gt; +}
&gt; +
&gt; +static uint32_t qriommu_get_table_index(uint64_t addr, int level)
&gt; +{
&gt; +    /* SV39: 39-bit virtual address, 3-level page table */
&gt; +    switch (level) {
&gt; +    case 0:
&gt; +        return (addr &gt;&gt; 30) &amp; 0x1ff;   /* L0: bits [38:30] */
&gt; +    case 1:
&gt; +        return (addr &gt;&gt; 21) &amp; 0x1ff;   /* L1: bits [29:21] */
&gt; +    case 2:
&gt; +        return (addr &gt;&gt; 12) &amp; 0x1ff;   /* L2: bits [20:12] */
&gt; +    default:
&gt; +        g_assert_not_reached();
&gt; +    }
&gt; +}
&gt; +
&gt; +static uint64_t qriommu_get_table_addr(uint64_t base, int level, uint64_t iova)
&gt; +{
&gt; +    uint32_t index = qriommu_get_table_index(iova, level);
&gt; +    return (base &amp; QRIOMMU_PTE_PPN_MASK) + (index * 8);
&gt; +}
&gt; +
&gt; +static void qriommu_map_leaf(QTestState *qts, uint64_t root_pa,
&gt; +                             uint64_t l0_pa, uint64_t l1_pa,
&gt; +                             uint64_t l0_pte_val, uint64_t l1_pte_val,
&gt; +                             uint64_t va, uint64_t pa, uint64_t leaf_attrs)
&gt; +{
&gt; +    uint64_t l0_addr = qriommu_get_table_addr(root_pa, 0, va);
&gt; +    uint64_t l1_addr = qriommu_get_table_addr(l0_pa, 1, va);
&gt; +    uint64_t l2_addr = qriommu_get_table_addr(l1_pa, 2, va);
&gt; +
&gt; +    qtest_writeq(qts, l0_addr, l0_pte_val);
&gt; +    qtest_writeq(qts, l1_addr, l1_pte_val);
&gt; +    qtest_writeq(qts, l2_addr, qriommu_encode_pte(pa, leaf_attrs));
&gt; +}
&gt; +
&gt; +static uint64_t qriommu_get_pte_attrs(QRIOMMUTransMode mode, bool is_leaf)
</span>

mode doesn't seem to be used?

<span class="q">&gt; +{
&gt; +    if (!is_leaf) {
&gt; +        return QRIOMMU_NON_LEAF_PTE_MASK;
&gt; +    }
&gt; +
&gt; +    /* For leaf PTE, set RWX permissions */
&gt; +    return QRIOMMU_LEAF_PTE_RW_MASK;
&gt; +}
&gt; +
&gt; ------------------------------&lt;snip&gt;------------------------------
&gt;
&gt;
&gt;
&gt; ------------------------------&lt;snip&gt;------------------------------
&gt; diff --git a/tests/qtest/libqos/qos-riscv-iommu.h b/tests/qtest/libqos/qos-riscv-iommu.h
&gt; new file mode 100644
&gt; index 0000000000..1f4efbf682
&gt; --- /dev/null
&gt; +++ b/tests/qtest/libqos/qos-riscv-iommu.h
&gt; @@ -0,0 +1,172 @@
&gt; +/*
&gt; + * QOS RISC-V IOMMU Module
&gt; + *
&gt; + * This module provides RISC-V IOMMU-specific helper functions for libqos tests,
&gt; + * encapsulating RISC-V IOMMU setup, and assertions.
&gt; + *
&gt; + * Copyright (c) 2026 Chao Liu &lt;chao.liu.zevorn@gmail.com&gt;
&gt; + *
&gt; + * SPDX-License-Identifier: GPL-2.0-or-later
&gt; + */
&gt; +
&gt; +#ifndef QTEST_LIBQOS_RISCV_IOMMU_H
&gt; +#define QTEST_LIBQOS_RISCV_IOMMU_H
&gt; +
&gt; +#include "hw/misc/iommu-testdev.h"
&gt; +
&gt; +/* RISC-V IOMMU MMIO register base for virt machine */
&gt; +#define VIRT_RISCV_IOMMU_BASE      0x0000000003010000ull
&gt; +
&gt; +/* RISC-V IOMMU queue and table base addresses */
&gt; +#define QRIOMMU_CQ_BASE_ADDR       0x000000000e160000ull
&gt; +#define QRIOMMU_FQ_BASE_ADDR       0x000000000e170000ull
&gt; +
&gt; +/* RISC-V IOMMU queue sizing */
&gt; +#define QRIOMMU_QUEUE_ENTRIES  1024
&gt; +#define QRIOMMU_CQ_ENTRY_SIZE  16
&gt; +#define QRIOMMU_FQ_ENTRY_SIZE  32
&gt; +
&gt; +/*
&gt; + * Translation tables and descriptors for RISC-V IOMMU.
&gt; + * Similar to ARM SMMUv3, but using RISC-V IOMMU terminology:
&gt; + * - Device Context (DC) instead of STE
&gt; + * - First-stage context (FSC) for S-stage translation
&gt; + * - IOHGATP for G-stage translation
&gt; + *
&gt; + * Granule size: 4KB pages
&gt; + * Page table levels: 3 levels for SV39 (L0, L1, L2)
&gt; + * IOVA size: 39-bit virtual address space
&gt; + */
&gt; +#define QRIOMMU_IOVA                0x0000000080604567ull
&gt; +#define QRIOMMU_IOHGATP             0x0000000000010000ull
&gt; +#define QRIOMMU_DDT_BASE            0x0000000000014000ull
&gt; +#define QRIOMMU_DC_BASE             (QRIOMMU_DDT_BASE)
&gt; +
&gt; +#define QRIOMMU_L0_PTE_VAL          0x0000000000011000ull
&gt; +#define QRIOMMU_L1_PTE_VAL          0x0000000000012000ull
&gt; +#define QRIOMMU_L2_PTE_VAL          0x0000000000013000ull
&gt; +
&gt; +#define QRIOMMU_G_IOHGATP           0x0000000000020000ull
&gt; +#define QRIOMMU_G_L0_PTE_VAL        0x0000000000021000ull
&gt; +#define QRIOMMU_G_L1_PTE_VAL        0x0000000000022000ull
&gt; +
&gt; +/* RISC-V page table entry masks */
&gt; +#define QRIOMMU_PTE_V               0x0000000000000001ull
&gt; +#define QRIOMMU_PTE_R               0x0000000000000002ull
&gt; +#define QRIOMMU_PTE_W               0x0000000000000004ull
&gt; +#define QRIOMMU_PTE_X               0x0000000000000008ull
&gt; +#define QRIOMMU_PTE_U               0x0000000000000010ull
&gt; +#define QRIOMMU_PTE_G               0x0000000000000020ull
&gt; +#define QRIOMMU_PTE_A               0x0000000000000040ull
&gt; +#define QRIOMMU_PTE_D               0x0000000000000080ull
</span>

I'm not entirely sure if there are similar definitions in the RISC-V 
header files, but if there are, I think we should consider reusing those 
definitions instead of redefining them.


Besides the correctness of the RISC-V page-table construction may need 
RISC-V experts to review closely.


Thanks,

Tao

<span class="q">&gt; +
&gt; +#define QRIOMMU_NON_LEAF_PTE_MASK   (QRIOMMU_PTE_V)
&gt; +#define QRIOMMU_LEAF_PTE_RW_MASK    (QRIOMMU_PTE_V | QRIOMMU_PTE_R | \n&gt; +                                     QRIOMMU_PTE_W | QRIOMMU_PTE_A | \n&gt; +                                     QRIOMMU_PTE_D)
&gt; +#define QRIOMMU_PTE_PPN_MASK        0x003ffffffffffc00ull
&gt; +
&gt; +/* Address-space base offset for test tables */
&gt; +#define QRIOMMU_SPACE_OFFS          0x0000000080000000ull
&gt; +
&gt; +typedef enum QRIOMMUTransMode {
&gt; +    QRIOMMU_TM_BARE         = 0,    /* No translation (pass-through) */
&gt; +    QRIOMMU_TM_S_STAGE_ONLY = 1,    /* First-stage only (S-stage) */
&gt; +    QRIOMMU_TM_G_STAGE_ONLY = 2,    /* Second-stage only (G-stage) */
&gt; +    QRIOMMU_TM_NESTED       = 3,    /* Nested translation (S + G) */
&gt; +} QRIOMMUTransMode;
&gt; +
&gt; +typedef struct QRIOMMUTestConfig {
&gt; +    QRIOMMUTransMode trans_mode;    /* Translation mode */
&gt; +    uint64_t dma_gpa;               /* GPA for readback validation */
&gt; +    uint32_t dma_len;               /* DMA length for testing */
&gt; +    uint32_t expected_result;       /* Expected DMA result */
&gt; +} QRIOMMUTestConfig;
&gt; +
&gt; +typedef struct QRIOMMUTestContext {
&gt; +    QTestState *qts;                /* QTest state handle */
&gt; +    QPCIDevice *dev;                /* PCI device handle */
&gt; +    QPCIBar bar;                    /* PCI BAR for MMIO access */
&gt; +    QRIOMMUTestConfig config;       /* Test configuration */
&gt; +    uint64_t iommu_base;            /* RISC-V IOMMU base address */
&gt; +    uint32_t trans_status;          /* Translation configuration status */
&gt; +    uint32_t dma_result;            /* DMA operation result */
&gt; +    uint32_t device_id;             /* Device ID for the test */
&gt; +} QRIOMMUTestContext;
&gt; +
&gt; +/*
&gt; + * qriommu_setup_and_enable_translation - Complete translation setup and enable
&gt; + *
&gt; + * @ctx: Test context containing configuration and device handles
&gt; + *
&gt; + * Returns: Translation status (0 = success, non-zero = error)
&gt; + *
&gt; + * This function performs the complete translation setup sequence:
&gt; + * 1. Builds all required RISC-V IOMMU structures (DC, page tables)
&gt; + * 2. Programs RISC-V IOMMU registers
&gt; + * 3. Returns configuration status
&gt; + */
&gt; +uint32_t qriommu_setup_and_enable_translation(QRIOMMUTestContext *ctx);
&gt; +
&gt; +/*
&gt; + * qriommu_build_translation - Build RISC-V IOMMU translation structures
&gt; + *
&gt; + * @qts: QTest state handle
&gt; + * @mode: Translation mode (BARE, S_STAGE_ONLY, G_STAGE_ONLY, NESTED)
&gt; + * @device_id: Device ID
&gt; + *
&gt; + * Returns: Build status (0 = success, non-zero = error)
&gt; + *
&gt; + * Constructs all necessary RISC-V IOMMU translation structures in guest memory:
&gt; + * - Device Context (DC) for the given device ID
&gt; + * - First-stage context (FSC) if S-stage translation is involved
&gt; + * - Complete page table hierarchy based on translation mode
&gt; + */
&gt; +uint32_t qriommu_build_translation(QTestState *qts, QRIOMMUTransMode mode,
&gt; +                                   uint32_t device_id);
&gt; +
&gt; +/*
&gt; + * qriommu_program_regs - Program all required RISC-V IOMMU registers
&gt; + *
&gt; + * @qts: QTest state handle
&gt; + * @iommu_base: RISC-V IOMMU base address
&gt; + *
&gt; + * Programs RISC-V IOMMU registers:
&gt; + * - Device Directory Table Pointer (DDTP)
&gt; + * - Command queue (base, head, tail)
&gt; + * - Fault queue (base, head, tail)
&gt; + * - Control and status registers
&gt; + */
&gt; +void qriommu_program_regs(QTestState *qts, uint64_t iommu_base);
&gt; +
&gt; +/*
&gt; + * qriommu_setup_translation_tables - Setup RISC-V IOMMU page table hierarchy
&gt; + *
&gt; + * @qts: QTest state handle
&gt; + * @iova: Input Virtual Address to translate
&gt; + * @mode: Translation mode
&gt; + *
&gt; + * This function builds the complete page table structure for translating
&gt; + * the given IOVA through the RISC-V IOMMU. The structure varies based on mode:
&gt; + *
&gt; + * - BARE: No translation (pass-through)
&gt; + * - S_STAGE_ONLY: Single S-stage walk (IOVA -&gt; PA)
&gt; + * - G_STAGE_ONLY: Single G-stage walk (IPA -&gt; PA)
&gt; + * - NESTED: S-stage walk (IOVA -&gt; IPA) + G-stage walk (IPA -&gt; PA)
&gt; + */
&gt; +void qriommu_setup_translation_tables(QTestState *qts,
&gt; +                                      uint64_t iova,
&gt; +                                      QRIOMMUTransMode mode);
&gt; +
&gt; +/* High-level test execution helpers */
&gt; +void qriommu_run_translation_case(QTestState *qts, QPCIDevice *dev,
&gt; +                                  QPCIBar bar, uint64_t iommu_base,
&gt; +                                  const QRIOMMUTestConfig *cfg);
&gt; +
&gt; +/* Calculate expected DMA result */
&gt; +uint32_t qriommu_expected_dma_result(QRIOMMUTestContext *ctx);
&gt; +
&gt; +/* Build DMA attributes for RISC-V IOMMU */
&gt; +uint32_t qriommu_build_dma_attrs(void);
&gt; +
&gt; +#endif /* QTEST_LIBQOS_RISCV_IOMMU_H */
</span>



<a href="#m47ec136efcc6562c3cb0be5024eb931e13b96868" id="e47ec136efcc6562c3cb0be5024eb931e13b96868">^</a> <a href="../../d11e9d1e-a209-4142-a742-170fcecefbf7@phytium.com.cn/">permalink</a> <a href="../../d11e9d1e-a209-4142-a742-170fcecefbf7@phytium.com.cn/raw">raw</a> <a href="../../d11e9d1e-a209-4142-a742-170fcecefbf7@phytium.com.cn/#R">reply</a>	[<a href="../../d11e9d1e-a209-4142-a742-170fcecefbf7@phytium.com.cn/T/#u"><b>flat</b></a>|<a href="../../d11e9d1e-a209-4142-a742-170fcecefbf7@phytium.com.cn/t/#u">nested</a>] <a href="#r47ec136efcc6562c3cb0be5024eb931e13b96868">13+ messages in thread</a></pre><hr><pre><a href="#eed032f1adb576354a7b019f27ef1f7f96608a772" id="med032f1adb576354a7b019f27ef1f7f96608a772">*</a> <b>Re: [RFC PATCH v1 2/2] tests/qtest: Add RISC-V IOMMU bare-metal test</b>
  2026-01-28 12:09 ` <a href="#m351dceb4c1fd03d15423922990cc16cc7f3f55d9">[RFC PATCH v1 2/2] tests/qtest: Add RISC-V IOMMU bare-metal test</a> Chao Liu
  2026-01-28 14:30   ` <a href="#m225bb7c105a86bd5763acc6b70063b62327f191d">Daniel Henrique Barboza</a>
<b>@ 2026-01-28 15:36   ` Tao Tang</b>
  2026-01-28 16:17     ` <a href="#m3092fd884052bbb4a29074f98ad96f50e0a66bfa">Chao Liu</a>
  <a href="#red032f1adb576354a7b019f27ef1f7f96608a772">1 sibling, 1 reply; 13+ messages in thread</a>
From: Tao Tang @ 2026-01-28 15:36 UTC (<a href="../../e51d2f40-2afa-4e6b-a2ca-2b1d83f5f371@phytium.com.cn/">permalink</a> / <a href="../../e51d2f40-2afa-4e6b-a2ca-2b1d83f5f371@phytium.com.cn/raw">raw</a>)
  To: Chao Liu, Alistair Francis, Daniel Henrique Barboza,
	Palmer Dabbelt, Weiwei Li, Liu Zhiwei, Fabiano Rosas,
	Laurent Vivier, Paolo Bonzini
  Cc: <a href="../../../qemu-devel/?t=20260128153648">qemu-devel</a>, <a href="../../../qemu-riscv/?t=20260128153648">qemu-riscv</a>, hust-os-kernel-patches

Hi Chao,

On 2026/1/28 20:09, Chao Liu wrote:
<span class="q">&gt; Add a qtest suite for the RISC-V IOMMU PCI device on the virt machine.
&gt; The test exercises bare, S-stage, G-stage, and nested translation paths
&gt; using iommu-testdev and the qos-riscv-iommu helpers.
&gt;
&gt; The test validates:
&gt; - Device context (DC) configuration
&gt; - SV39 page table walks for S-stage translation
&gt; - SV39x4 page table walks for G-stage translation
&gt; - Nested translation combining both stages
&gt; - FCTL register constraints
&gt;
&gt; This provides regression coverage for the RISC-V IOMMU implementation
&gt; without requiring a full guest OS boot.
&gt;
&gt; Signed-off-by: Chao Liu &lt;chao.liu.zevorn@gmail.com&gt;
&gt; ---
&gt;   MAINTAINERS                    |   1 +
&gt;   tests/qtest/iommu-riscv-test.c | 279 +++++++++++++++++++++++++++++++++
&gt;   tests/qtest/meson.build        |   5 +-
&gt;   3 files changed, 284 insertions(+), 1 deletion(-)
&gt;   create mode 100644 tests/qtest/iommu-riscv-test.c
&gt;
&gt; diff --git a/MAINTAINERS b/MAINTAINERS
&gt; index 894e05bd2c..c7400c83d2 100644
&gt; --- a/MAINTAINERS
&gt; +++ b/MAINTAINERS
&gt; @@ -347,6 +347,7 @@ F: common-user/host/riscv*
&gt;   F: tests/functional/riscv32
&gt;   F: tests/functional/riscv64
&gt;   F: tests/tcg/riscv64/
&gt; +F: tests/qtest/iommu-riscv-test.c
&gt;   
&gt;   RISC-V XThead* extensions
&gt;   M: Christoph Muellner &lt;christoph.muellner@vrull.eu&gt;
&gt; diff --git a/tests/qtest/iommu-riscv-test.c b/tests/qtest/iommu-riscv-test.c
&gt; new file mode 100644
&gt; index 0000000000..9438578e1e
&gt; --- /dev/null
&gt; +++ b/tests/qtest/iommu-riscv-test.c
&gt; @@ -0,0 +1,279 @@
&gt; +/*
&gt; + * QTest testcase for RISC-V IOMMU with iommu-testdev
&gt; + *
&gt; + * This QTest file is used to test the RISC-V IOMMU with iommu-testdev so that
&gt; + * we can test RISC-V IOMMU without any guest kernel or firmware.
&gt; + *
&gt; + * Copyright (c) 2026 Chao Liu &lt;chao.liu.zevorn@gmail.com&gt;
&gt; + *
&gt; + * SPDX-License-Identifier: GPL-2.0-or-later
&gt; + */
&gt; +
&gt; +#include "qemu/osdep.h"
&gt; +#include "libqtest.h"
&gt; +#include "libqos/pci.h"
&gt; +#include "libqos/generic-pcihost.h"
&gt; +#include "hw/pci/pci_regs.h"
&gt; +#include "hw/misc/iommu-testdev.h"
&gt; +#include "hw/riscv/riscv-iommu-bits.h"
&gt; +#include "libqos/qos-riscv-iommu.h"
&gt; +#include "libqos/riscv-iommu.h"
&gt; +
&gt; +#define DMA_LEN           4
&gt; +
&gt; +/* RISC-V virt machine PCI configuration */
&gt; +#define RISCV_GPEX_PIO_BASE        0x3000000
&gt; +#define RISCV_BUS_PIO_LIMIT        0x10000
&gt; +#define RISCV_BUS_MMIO_ALLOC_PTR   0x40000000
&gt; +#define RISCV_BUS_MMIO_LIMIT       0x80000000
&gt; +#define RISCV_ECAM_ALLOC_PTR       0x30000000
&gt; +
&gt; +typedef struct RiscvIommuTestState {
&gt; +    QTestState *qts;
&gt; +    QGenericPCIBus gbus;
&gt; +    QPCIDevice *iommu_dev;
&gt; +    QPCIDevice *testdev;
&gt; +    QPCIBar testdev_bar;
&gt; +    uint64_t iommu_base;
&gt; +} RiscvIommuTestState;
&gt; +
&gt; +static void riscv_config_qpci_bus(QGenericPCIBus *qpci)
&gt; +{
&gt; +    qpci-&gt;gpex_pio_base = RISCV_GPEX_PIO_BASE;
&gt; +    qpci-&gt;bus.pio_limit = RISCV_BUS_PIO_LIMIT;
&gt; +    qpci-&gt;bus.mmio_alloc_ptr = RISCV_BUS_MMIO_ALLOC_PTR;
&gt; +    qpci-&gt;bus.mmio_limit = RISCV_BUS_MMIO_LIMIT;
&gt; +    qpci-&gt;ecam_alloc_ptr = RISCV_ECAM_ALLOC_PTR;
&gt; +}
&gt; +
&gt; +static uint64_t riscv_iommu_expected_gpa(uint64_t iova)
&gt; +{
&gt; +    return QRIOMMU_SPACE_OFFS + QRIOMMU_L2_PTE_VAL + (iova &amp; 0xfff);
&gt; +}
&gt; +
&gt; +static void save_fn(QPCIDevice *dev, int devfn, void *data)
&gt; +{
&gt; +    QPCIDevice **pdev = (QPCIDevice **) data;
&gt; +    uint16_t vendor = qpci_config_readw(dev, 0);
&gt; +    uint16_t device = qpci_config_readw(dev, 2);
&gt; +
&gt; +    g_test_message("Found PCI device: vendor=0x%04x device=0x%04x devfn=0x%02x",
&gt; +                   vendor, device, devfn);
&gt; +
&gt; +    if (!*pdev) {
&gt; +        *pdev = dev;
&gt; +    }
&gt; +}
&gt; +
&gt; +static QPCIDevice *find_riscv_iommu_pci(QGenericPCIBus *gbus,
&gt; +                                        uint64_t *iommu_base)
&gt; +{
&gt; +    QPCIDevice *iommu_dev = NULL;
&gt; +    QPCIBar iommu_bar;
&gt; +
&gt; +    g_test_message("Searching for riscv-iommu-pci "
&gt; +                   "(vendor=0x%04x, device=0x%04x)",
&gt; +                   RISCV_IOMMU_PCI_VENDOR_ID, RISCV_IOMMU_PCI_DEVICE_ID);
&gt; +
&gt; +    qpci_device_foreach(&amp;gbus-&gt;bus, RISCV_IOMMU_PCI_VENDOR_ID,
&gt; +                        RISCV_IOMMU_PCI_DEVICE_ID, save_fn, &amp;iommu_dev);
&gt; +
&gt; +    if (!iommu_dev) {
&gt; +        g_test_message("riscv-iommu-pci device not found!");
&gt; +        return NULL;
&gt; +    }
&gt; +
&gt; +    g_test_message("Found riscv-iommu-pci at devfn=0x%02x", iommu_dev-&gt;devfn);
&gt; +
&gt; +    qpci_device_enable(iommu_dev);
&gt; +    iommu_bar = qpci_iomap(iommu_dev, 0, NULL);
&gt; +    g_assert_false(iommu_bar.is_io);
&gt; +
&gt; +    *iommu_base = iommu_bar.addr;
&gt; +    g_test_message("RISC-V IOMMU MMIO base address: 0x%lx", *iommu_base);
</span>

There was a cross-compilation error on mingw64:

../tests/qtest/iommu-riscv-test.c: In function 'find_riscv_iommu_pci':
../tests/qtest/iommu-riscv-test.c:93:57: error: format '%lx' expects 
argument of type 'long unsigned int', but argument 2 has type 'uint64_t' 
{aka 'long long unsigned int'} [-Werror=format=]
 &nbsp; &nbsp;93 |&nbsp; &nbsp; &nbsp;g_test_message("RISC-V IOMMU MMIO base address: 0x%lx", 
*iommu_base);
 &nbsp; &nbsp; &nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;~~^ 
 &nbsp;~~~~~~~~~~~
 &nbsp; &nbsp; &nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp;|
 &nbsp; &nbsp; &nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| 
 &nbsp;uint64_t {aka long long unsigned int}
 &nbsp; &nbsp; &nbsp; | &nbsp;long unsigned int
 &nbsp; &nbsp; &nbsp; |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;%llx

I think we should use PRIx64 instead.

You can check the result in this link [1]. And try it again with 
Pierrick's downstream fork [2]

[1] <a href="https://github.com/hnusdr/qemu/actions/runs/21438370066/job/61734760185">https://github.com/hnusdr/qemu/actions/runs/21438370066/job/61734760185</a>

[2] <a href="https://github.com/pbo-linaro/qemu/">https://github.com/pbo-linaro/qemu/</a>


Thanks,

Tao

<span class="q">&gt; +
&gt; +    return iommu_dev;
&gt; +}
&gt; +
&gt; +static QPCIDevice *find_iommu_testdev(QGenericPCIBus *gbus, QPCIBar *bar)
&gt; +{
&gt; +    QPCIDevice *dev = NULL;
&gt; +
&gt; +    g_test_message("Searching for iommu-testdev (vendor=0x%04x, device=0x%04x)",
&gt; +                   IOMMU_TESTDEV_VENDOR_ID, IOMMU_TESTDEV_DEVICE_ID);
&gt; +
&gt; +    qpci_device_foreach(&amp;gbus-&gt;bus, IOMMU_TESTDEV_VENDOR_ID,
&gt; +                        IOMMU_TESTDEV_DEVICE_ID, save_fn, &amp;dev);
&gt; +    g_assert(dev);
&gt; +
&gt; +    qpci_device_enable(dev);
&gt; +    *bar = qpci_iomap(dev, 0, NULL);
&gt; +    g_assert_false(bar-&gt;is_io);
&gt; +
&gt; +    return dev;
&gt; +}
&gt; +
&gt; +static bool riscv_iommu_test_setup(RiscvIommuTestState *state)
&gt; +{
&gt; +    if (!qtest_has_machine("virt")) {
&gt; +        g_test_skip("virt machine not available");
&gt; +        return false;
&gt; +    }
&gt; +
&gt; +    state-&gt;qts = qtest_init("-machine virt,acpi=off "
&gt; +                            "-cpu max -smp 1 -m 512 -net none "
&gt; +                            "-device riscv-iommu-pci "
&gt; +                            "-device iommu-testdev");
&gt; +
&gt; +    qpci_init_generic(&amp;state-&gt;gbus, state-&gt;qts, NULL, false);
&gt; +    riscv_config_qpci_bus(&amp;state-&gt;gbus);
&gt; +
&gt; +    state-&gt;iommu_dev = find_riscv_iommu_pci(&amp;state-&gt;gbus, &amp;state-&gt;iommu_base);
&gt; +    g_assert(state-&gt;iommu_dev);
&gt; +
&gt; +    state-&gt;testdev = find_iommu_testdev(&amp;state-&gt;gbus, &amp;state-&gt;testdev_bar);
&gt; +    g_assert(state-&gt;testdev);
&gt; +
&gt; +    return true;
&gt; +}
&gt; +
&gt; +static void riscv_iommu_test_teardown(RiscvIommuTestState *state)
&gt; +{
&gt; +    qtest_quit(state-&gt;qts);
&gt; +}
&gt; +
&gt; +static uint64_t riscv_iommu_check(QTestState *qts, uint64_t iommu_base,
&gt; +                                  QRIOMMUTransMode mode)
&gt; +{
&gt; +    uint64_t cap;
&gt; +    uint64_t ddtp;
&gt; +    uint32_t cqcsr;
&gt; +    uint32_t fqcsr;
&gt; +    uint32_t pqcsr;
&gt; +    uint32_t fctl;
&gt; +    uint32_t fctl_mask;
&gt; +    uint32_t fctl_desired;
&gt; +    uint32_t igs;
&gt; +
&gt; +    cap = qtest_readq(qts, iommu_base + RISCV_IOMMU_REG_CAP);
&gt; +    g_assert_cmpuint((uint32_t)(cap &amp; RISCV_IOMMU_CAP_VERSION), ==,
&gt; +                     RISCV_IOMMU_SPEC_DOT_VER);
&gt; +
&gt; +    fctl = qtest_readl(qts, iommu_base + RISCV_IOMMU_REG_FCTL);
&gt; +    igs = (cap &amp; RISCV_IOMMU_CAP_IGS) &gt;&gt; 28;
&gt; +    g_assert_cmpuint(igs, &lt;=, RISCV_IOMMU_CAP_IGS_BOTH);
&gt; +
&gt; +    fctl_mask = RISCV_IOMMU_FCTL_BE | RISCV_IOMMU_FCTL_WSI |
&gt; +                RISCV_IOMMU_FCTL_GXL;
&gt; +    fctl_desired = fctl &amp; ~fctl_mask;
&gt; +    if (igs == RISCV_IOMMU_CAP_IGS_WSI) {
&gt; +        fctl_desired |= RISCV_IOMMU_FCTL_WSI;
&gt; +    }
&gt; +
&gt; +    if ((fctl &amp; fctl_mask) != (fctl_desired &amp; fctl_mask)) {
&gt; +        ddtp = qtest_readq(qts, iommu_base + RISCV_IOMMU_REG_DDTP);
&gt; +        cqcsr = qtest_readl(qts, iommu_base + RISCV_IOMMU_REG_CQCSR);
&gt; +        fqcsr = qtest_readl(qts, iommu_base + RISCV_IOMMU_REG_FQCSR);
&gt; +        pqcsr = qtest_readl(qts, iommu_base + RISCV_IOMMU_REG_PQCSR);
&gt; +
&gt; +        g_assert_cmpuint((uint32_t)(ddtp &amp; RISCV_IOMMU_DDTP_MODE), ==,
&gt; +                         RISCV_IOMMU_DDTP_MODE_OFF);
&gt; +        g_assert_cmpuint(cqcsr &amp; RISCV_IOMMU_CQCSR_CQON, ==, 0);
&gt; +        g_assert_cmpuint(fqcsr &amp; RISCV_IOMMU_FQCSR_FQON, ==, 0);
&gt; +        g_assert_cmpuint(pqcsr &amp; RISCV_IOMMU_PQCSR_PQON, ==, 0);
&gt; +
&gt; +        qtest_writel(qts, iommu_base + RISCV_IOMMU_REG_FCTL, fctl_desired);
&gt; +        fctl = qtest_readl(qts, iommu_base + RISCV_IOMMU_REG_FCTL);
&gt; +    }
&gt; +
&gt; +    g_assert_cmpuint(fctl &amp; fctl_mask, ==, fctl_desired &amp; fctl_mask);
&gt; +
&gt; +    if (mode == QRIOMMU_TM_S_STAGE_ONLY || mode == QRIOMMU_TM_NESTED) {
&gt; +        g_assert((cap &amp; RISCV_IOMMU_CAP_SV39) != 0);
&gt; +    }
&gt; +    if (mode == QRIOMMU_TM_G_STAGE_ONLY || mode == QRIOMMU_TM_NESTED) {
&gt; +        g_assert((cap &amp; RISCV_IOMMU_CAP_SV39X4) != 0);
&gt; +        g_assert_cmpuint(fctl &amp; RISCV_IOMMU_FCTL_GXL, ==, 0);
&gt; +    }
&gt; +
&gt; +    return cap;
&gt; +}
&gt; +
&gt; +static void run_riscv_iommu_translation(const QRIOMMUTestConfig *cfg)
&gt; +{
&gt; +    RiscvIommuTestState state = { 0 };
&gt; +
&gt; +    if (!riscv_iommu_test_setup(&amp;state)) {
&gt; +        return;
&gt; +    }
&gt; +
&gt; +    riscv_iommu_check(state.qts, state.iommu_base, cfg-&gt;trans_mode);
&gt; +
&gt; +    g_test_message("### RISC-V IOMMU translation mode=%d ###",
&gt; +                   cfg-&gt;trans_mode);
&gt; +    qriommu_run_translation_case(state.qts, state.testdev, state.testdev_bar,
&gt; +                                 state.iommu_base, cfg);
&gt; +    riscv_iommu_test_teardown(&amp;state);
&gt; +}
&gt; +
&gt; +static void test_riscv_iommu_bare(void)
&gt; +{
&gt; +    QRIOMMUTestConfig cfg = {
&gt; +        .trans_mode = QRIOMMU_TM_BARE,
&gt; +        .dma_gpa = QRIOMMU_IOVA,
&gt; +        .dma_len = DMA_LEN,
&gt; +        .expected_result = 0,
&gt; +    };
&gt; +
&gt; +    run_riscv_iommu_translation(&amp;cfg);
&gt; +}
&gt; +
&gt; +static void test_riscv_iommu_s_stage_only(void)
&gt; +{
&gt; +    QRIOMMUTestConfig cfg = {
&gt; +        .trans_mode = QRIOMMU_TM_S_STAGE_ONLY,
&gt; +        .dma_gpa = riscv_iommu_expected_gpa(QRIOMMU_IOVA),
&gt; +        .dma_len = DMA_LEN,
&gt; +        .expected_result = 0,
&gt; +    };
&gt; +
&gt; +    run_riscv_iommu_translation(&amp;cfg);
&gt; +}
&gt; +
&gt; +static void test_riscv_iommu_g_stage_only(void)
&gt; +{
&gt; +    QRIOMMUTestConfig cfg = {
&gt; +        .trans_mode = QRIOMMU_TM_G_STAGE_ONLY,
&gt; +        .dma_gpa = riscv_iommu_expected_gpa(QRIOMMU_IOVA),
&gt; +        .dma_len = DMA_LEN,
&gt; +        .expected_result = 0,
&gt; +    };
&gt; +
&gt; +    run_riscv_iommu_translation(&amp;cfg);
&gt; +}
&gt; +
&gt; +static void test_riscv_iommu_nested(void)
&gt; +{
&gt; +    QRIOMMUTestConfig cfg = {
&gt; +        .trans_mode = QRIOMMU_TM_NESTED,
&gt; +        .dma_gpa = riscv_iommu_expected_gpa(QRIOMMU_IOVA),
&gt; +        .dma_len = DMA_LEN,
&gt; +        .expected_result = 0,
&gt; +    };
&gt; +
&gt; +    run_riscv_iommu_translation(&amp;cfg);
&gt; +}
&gt; +
&gt; +int main(int argc, char **argv)
&gt; +{
&gt; +    g_test_init(&amp;argc, &amp;argv, NULL);
&gt; +    qtest_add_func("/iommu-testdev/translation/bare",
&gt; +                   test_riscv_iommu_bare);
&gt; +    qtest_add_func("/iommu-testdev/translation/s-stage-only",
&gt; +                   test_riscv_iommu_s_stage_only);
&gt; +    qtest_add_func("/iommu-testdev/translation/g-stage-only",
&gt; +                   test_riscv_iommu_g_stage_only);
&gt; +    qtest_add_func("/iommu-testdev/translation/ns-nested",
&gt; +                   test_riscv_iommu_nested);
&gt; +    return g_test_run();
&gt; +}
&gt; diff --git a/tests/qtest/meson.build b/tests/qtest/meson.build
&gt; index a8b09d065f..eb45e0f97d 100644
&gt; --- a/tests/qtest/meson.build
&gt; +++ b/tests/qtest/meson.build
&gt; @@ -286,7 +286,10 @@ qtests_riscv32 = \n&gt;     (config_all_devices.has_key('CONFIG_SIFIVE_E_AON') ? ['sifive-e-aon-watchdog-test'] : [])
&gt;   
&gt;   qtests_riscv64 = ['riscv-csr-test'] + \n&gt; -  (unpack_edk2_blobs ? ['bios-tables-test'] : [])
&gt; +  (unpack_edk2_blobs ? ['bios-tables-test'] : []) + \n&gt; +  (config_all_devices.has_key('CONFIG_IOMMU_TESTDEV') and
&gt; +   config_all_devices.has_key('CONFIG_RISCV_IOMMU') ?
&gt; +   ['iommu-riscv-test'] : [])
&gt;   
&gt;   qos_test_ss = ss.source_set()
&gt;   qos_test_ss.add(
</span>


<a href="#med032f1adb576354a7b019f27ef1f7f96608a772" id="eed032f1adb576354a7b019f27ef1f7f96608a772">^</a> <a href="../../e51d2f40-2afa-4e6b-a2ca-2b1d83f5f371@phytium.com.cn/">permalink</a> <a href="../../e51d2f40-2afa-4e6b-a2ca-2b1d83f5f371@phytium.com.cn/raw">raw</a> <a href="../../e51d2f40-2afa-4e6b-a2ca-2b1d83f5f371@phytium.com.cn/#R">reply</a>	[<a href="../../e51d2f40-2afa-4e6b-a2ca-2b1d83f5f371@phytium.com.cn/T/#u"><b>flat</b></a>|<a href="../../e51d2f40-2afa-4e6b-a2ca-2b1d83f5f371@phytium.com.cn/t/#u">nested</a>] <a href="#red032f1adb576354a7b019f27ef1f7f96608a772">13+ messages in thread</a></pre><hr><pre><a href="#ed4ab43b6667cfd798638f36984d5dfce06909dc3" id="md4ab43b6667cfd798638f36984d5dfce06909dc3">*</a> <b>Re: [RFC PATCH v1 1/2] tests/qtest/libqos: Add RISC-V IOMMU helper library</b>
  2026-01-28 15:23   ` <a href="#m47ec136efcc6562c3cb0be5024eb931e13b96868">Tao Tang</a>
<b>@ 2026-01-28 15:45     ` Chao Liu</b>
  <a href="#rd4ab43b6667cfd798638f36984d5dfce06909dc3">0 siblings, 0 replies; 13+ messages in thread</a>
From: Chao Liu @ 2026-01-28 15:45 UTC (<a href="../../d89f2510-22ac-47b4-adc6-b23e5cf6306e@gmail.com/">permalink</a> / <a href="../../d89f2510-22ac-47b4-adc6-b23e5cf6306e@gmail.com/raw">raw</a>)
  To: Tao Tang, Alistair Francis, Daniel Henrique Barboza,
	Palmer Dabbelt, Weiwei Li, Liu Zhiwei, Fabiano Rosas,
	Laurent Vivier, Paolo Bonzini
  Cc: <a href="../../../qemu-devel/?t=20260128154731">qemu-devel</a>, <a href="../../../qemu-riscv/?t=20260128154731">qemu-riscv</a>, hust-os-kernel-patches

Hi Tao,

Thanks for the review!

On 1/28/2026 11:23 PM, Tao Tang wrote:
<span class="q">&gt; Hi Chao,
&gt;
&gt; On 2026/1/28 20:09, Chao Liu wrote:
&gt;&gt; Introduce a libqos helper module for RISC-V IOMMU testing with
&gt;&gt; iommu-testdev. The helper provides routines to:
&gt;&gt;
&gt;&gt; - Build device contexts (DC) and 3-level page tables for SV39/SV39x4
&gt;&gt; - Program command queue (CQ), fault queue (FQ), and DDTP registers
&gt;&gt; &nbsp;&nbsp; following the RISC-V IOMMU specification
&gt;&gt; - Execute DMA translations and verify results
&gt;&gt;
&gt;&gt; The current implementation supports SV39 for S-stage and SV39x4 for
&gt;&gt; G-stage translation. Support for SV48/SV48x4/SV57/SV57x4 can be added
&gt;&gt; in future patches.
&gt;&gt;
&gt;&gt; Signed-off-by: Chao Liu &lt;chao.liu.zevorn@gmail.com&gt;
&gt;&gt; ---
&gt;&gt; &nbsp; MAINTAINERS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; 1 +
&gt;&gt; &nbsp; tests/qtest/libqos/meson.build&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; 2 +-
&gt;&gt; &nbsp; tests/qtest/libqos/qos-riscv-iommu.c | 400 +++++++++++++++++++++++++++
&gt;&gt; &nbsp; tests/qtest/libqos/qos-riscv-iommu.h | 172 ++++++++++++
&gt;&gt; &nbsp; 4 files changed, 574 insertions(+), 1 deletion(-)
&gt;&gt; &nbsp; create mode 100644 tests/qtest/libqos/qos-riscv-iommu.c
&gt;&gt; &nbsp; create mode 100644 tests/qtest/libqos/qos-riscv-iommu.h
&gt;&gt;
&gt;&gt; diff --git a/MAINTAINERS b/MAINTAINERS
&gt;&gt; index dc31be033e..894e05bd2c 100644
&gt;&gt; --- a/MAINTAINERS
&gt;&gt; +++ b/MAINTAINERS
&gt;&gt; @@ -3583,6 +3583,7 @@ M: Tao Tang &lt;tangtao1634@phytium.com.cn&gt;
&gt;&gt; &nbsp; S: Maintained
&gt;&gt; &nbsp; F: tests/qtest/libqos/qos-iommu*
&gt;&gt; &nbsp; F: tests/qtest/libqos/qos-smmuv3*
&gt;&gt; +F: tests/qtest/libqos/qos-riscv-iommu*
&gt;&gt; &nbsp; &nbsp; Device Fuzzing
&gt;&gt; &nbsp; M: Alexander Bulekov &lt;alxndr@bu.edu&gt;
&gt;&gt; diff --git a/tests/qtest/libqos/meson.build b/tests/qtest/libqos/meson.build
&gt;&gt; index b4daec808f..4a69acad0d 100644
&gt;&gt; --- a/tests/qtest/libqos/meson.build
&gt;&gt; +++ b/tests/qtest/libqos/meson.build
&gt;&gt; @@ -71,7 +71,7 @@ if have_virtfs
&gt;&gt; &nbsp; endif
&gt;&gt; &nbsp; &nbsp; if config_all_devices.has_key('CONFIG_RISCV_IOMMU')
&gt;&gt; -&nbsp; libqos_srcs += files('riscv-iommu.c')
&gt;&gt; +&nbsp; libqos_srcs += files('riscv-iommu.c', 'qos-riscv-iommu.c')
&gt;&gt; &nbsp; endif
&gt;&gt; &nbsp; if config_all_devices.has_key('CONFIG_TPCI200')
&gt;&gt; &nbsp;&nbsp;&nbsp; libqos_srcs += files('tpci200.c')
&gt;&gt; diff --git a/tests/qtest/libqos/qos-riscv-iommu.c b/tests/qtest/libqos/qos-riscv-iommu.c
&gt;&gt; new file mode 100644
&gt;&gt; index 0000000000..34ed3df84a
&gt;&gt; --- /dev/null
&gt;&gt; +++ b/tests/qtest/libqos/qos-riscv-iommu.c
&gt;&gt; @@ -0,0 +1,400 @@
&gt;&gt; +/*
&gt;&gt; + * QOS RISC-V IOMMU Module
&gt;&gt; + *
&gt;&gt; + * This module provides RISC-V IOMMU-specific helper functions for libqos tests,
&gt;&gt; + * encapsulating RISC-V IOMMU setup, and assertions.
&gt;&gt; + *
&gt;&gt; + * Copyright (c) 2026 Chao Liu &lt;chao.liu.zevorn@gmail.com&gt;
&gt;&gt; + *
&gt;&gt; + * SPDX-License-Identifier: GPL-2.0-or-later
&gt;&gt; + */
&gt;&gt; +
&gt;&gt; +#include "qemu/osdep.h"
&gt;&gt; +#include "qemu/bitops.h"
&gt;&gt; +#include "hw/riscv/riscv-iommu-bits.h"
&gt;&gt; +#include "tests/qtest/libqos/pci.h"
&gt;&gt; +#include "qos-iommu-testdev.h"
&gt;&gt; +#include "qos-riscv-iommu.h"
&gt;&gt; +
&gt;&gt; +/* Apply space offset to address */
&gt;&gt; +static inline uint64_t qriommu_apply_space_offs(uint64_t address)
&gt;&gt; +{
&gt;&gt; +&nbsp;&nbsp;&nbsp; return address + QRIOMMU_SPACE_OFFS;
&gt;&gt; +}
&gt;
&gt;
&gt; In the original SMMU/iommu-testdev work, I introduced a similar “base offset” mainly to make room for future expansion where the same test code needs to exercise multiple security domains (e.g., Arm Non-secure vs Secure vs Realm), which in QEMU is reflected via distinct address spaces / MemTxAttrs (the space field).
&gt;
&gt; I’m not very familiar with the RISC-V security model. In RISC-V, do you foresee a comparable need to test multiple “security states” for DMA transactions?
&gt;
</span>Good question. RISC-V currently doesn't have a TrustZone-like security
model with multiple security domains (Secure/Non-secure/Realm) like ARM.
However, RISC-V does have the Hypervisor extension (H-extension) with
VS/VU modes, and there's a draft WorldGuard extension for security
isolation.

For now, the QRIOMMU_SPACE_OFFS is mainly used to avoid address conflicts
with other memory regions in the QEMU virt machine. If future RISC-V
security extensions require multi-domain testing, we can extend this
infrastructure accordingly.
<span class="q">&gt;&gt; +
&gt;&gt; +static uint64_t qriommu_encode_pte(uint64_t pa, uint64_t attrs)
&gt;&gt; +{
&gt;&gt; +&nbsp;&nbsp;&nbsp; return ((pa &gt;&gt; 12) &lt;&lt; 10) | attrs;
&gt;&gt; +}
&gt;&gt; +
&gt;&gt; +static void qriommu_wait_for_queue_active(QTestState *qts, uint64_t iommu_base,
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t queue_csr, uint32_t on_bit)
&gt;&gt; +{
&gt;&gt; +&nbsp;&nbsp;&nbsp; guint64 timeout_us = 2 * 1000 * 1000;
&gt;&gt; +&nbsp;&nbsp;&nbsp; gint64 start_time = g_get_monotonic_time();
&gt;&gt; +&nbsp;&nbsp;&nbsp; uint32_t reg;
&gt;&gt; +
&gt;&gt; +&nbsp;&nbsp;&nbsp; for (;;) {
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qtest_clock_step(qts, 100);
&gt;&gt; +
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reg = qtest_readl(qts, iommu_base + queue_csr);
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (reg &amp; on_bit) {
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_assert(g_get_monotonic_time() - start_time &lt;= timeout_us);
&gt;&gt; +&nbsp;&nbsp;&nbsp; }
&gt;&gt; +}
&gt;&gt; +
&gt;&gt; +uint32_t qriommu_expected_dma_result(QRIOMMUTestContext *ctx)
&gt;&gt; +{
&gt;&gt; +&nbsp;&nbsp;&nbsp; return ctx-&gt;config.expected_result;
&gt;&gt; +}
&gt;&gt; +
&gt;&gt; +uint32_t qriommu_build_dma_attrs(void)
&gt;&gt; +{
&gt;&gt; +&nbsp;&nbsp;&nbsp; /* RISC-V IOMMU uses standard AXI attributes */
&gt;&gt; +&nbsp;&nbsp;&nbsp; return 0;
&gt;&gt; +}
&gt;&gt; +
&gt;&gt; +uint32_t qriommu_setup_and_enable_translation(QRIOMMUTestContext *ctx)
&gt;&gt; +{
&gt;&gt; +&nbsp;&nbsp;&nbsp; uint32_t build_result;
&gt;&gt; +
&gt;&gt; +&nbsp;&nbsp;&nbsp; /* Build page tables and RISC-V IOMMU structures first */
&gt;&gt; +&nbsp;&nbsp;&nbsp; build_result = qriommu_build_translation(
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ctx-&gt;qts, ctx-&gt;config.trans_mode,
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ctx-&gt;device_id);
&gt;&gt; +&nbsp;&nbsp;&nbsp; if (build_result != 0) {
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_test_message("Build failed: mode=%u device_id=%u status=0x%x",
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ctx-&gt;config.trans_mode, ctx-&gt;device_id, build_result);
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ctx-&gt;trans_status = build_result;
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ctx-&gt;trans_status;
&gt;&gt; +&nbsp;&nbsp;&nbsp; }
&gt;&gt; +
&gt;&gt; +&nbsp;&nbsp;&nbsp; /* Program RISC-V IOMMU registers */
&gt;&gt; +&nbsp;&nbsp;&nbsp; qriommu_program_regs(ctx-&gt;qts, ctx-&gt;iommu_base);
&gt;&gt; +
&gt;&gt; +&nbsp;&nbsp;&nbsp; ctx-&gt;trans_status = 0;
&gt;&gt; +&nbsp;&nbsp;&nbsp; return ctx-&gt;trans_status;
&gt;&gt; +}
&gt;&gt; +
&gt;&gt; +static bool qriommu_validate_test_result(QRIOMMUTestContext *ctx)
&gt;&gt; +{
&gt;&gt; +&nbsp;&nbsp;&nbsp; uint32_t expected = qriommu_expected_dma_result(ctx);
&gt;&gt; +&nbsp;&nbsp;&nbsp; g_test_message("-&gt; Validating result: expected=0x%x actual=0x%x",
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; expected, ctx-&gt;dma_result);
&gt;&gt; +&nbsp;&nbsp;&nbsp; return (ctx-&gt;dma_result == expected);
&gt;&gt; +}
&gt;&gt; +
&gt;&gt; +static uint32_t qriommu_single_translation_setup(void *opaque)
&gt;&gt; +{
&gt;&gt; +&nbsp;&nbsp;&nbsp; return qriommu_setup_and_enable_translation(opaque);
&gt;&gt; +}
&gt;&gt; +
&gt;&gt; +static uint32_t qriommu_single_translation_attrs(void *opaque)
&gt;&gt; +{
&gt;&gt; +&nbsp;&nbsp;&nbsp; return qriommu_build_dma_attrs();
&gt;&gt; +}
&gt;&gt; +
&gt;&gt; +static bool qriommu_single_translation_validate(void *opaque)
&gt;&gt; +{
&gt;&gt; +&nbsp;&nbsp;&nbsp; return qriommu_validate_test_result(opaque);
&gt;&gt; +}
&gt;&gt; +
&gt;&gt; +static void qriommu_single_translation_report(void *opaque,
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t dma_result)
&gt;&gt; +{
&gt;&gt; +&nbsp;&nbsp;&nbsp; QRIOMMUTestContext *ctx = opaque;
&gt;&gt; +
&gt;&gt; +&nbsp;&nbsp;&nbsp; if (dma_result != 0) {
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_test_message("DMA failed: mode=%u result=0x%x",
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ctx-&gt;config.trans_mode, dma_result);
&gt;&gt; +&nbsp;&nbsp;&nbsp; } else {
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_test_message("-&gt; DMA succeeded: mode=%u",
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ctx-&gt;config.trans_mode);
&gt;&gt; +&nbsp;&nbsp;&nbsp; }
&gt;&gt; +}
&gt;&gt; +
&gt;&gt; +void qriommu_run_translation_case(QTestState *qts, QPCIDevice *dev,
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QPCIBar bar, uint64_t iommu_base,
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const QRIOMMUTestConfig *cfg)
&gt;&gt; +{
&gt;&gt; +&nbsp;&nbsp;&nbsp; QRIOMMUTestContext ctx = {
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .qts = qts,
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .dev = dev,
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .bar = bar,
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .iommu_base = iommu_base,
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .config = *cfg,
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .device_id = dev-&gt;devfn,
&gt;&gt; +&nbsp;&nbsp;&nbsp; };
&gt;&gt; +
&gt;&gt; +&nbsp;&nbsp;&nbsp; QOSIOMMUTestdevDmaCfg dma = {
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .dev = dev,
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .bar = bar,
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .iova = QRIOMMU_IOVA,
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .gpa = ctx.config.dma_gpa,
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .len = ctx.config.dma_len,
&gt;&gt; +&nbsp;&nbsp;&nbsp; };
&gt;&gt; +
&gt;&gt; +&nbsp;&nbsp;&nbsp; qtest_memset(qts, cfg-&gt;dma_gpa, 0x00, cfg-&gt;dma_len);
&gt;&gt; +&nbsp;&nbsp;&nbsp; qos_iommu_testdev_single_translation(&amp;dma, &amp;ctx,
&gt;&gt; + qriommu_single_translation_setup,
&gt;&gt; + qriommu_single_translation_attrs,
&gt;&gt; + qriommu_single_translation_validate,
&gt;&gt; + qriommu_single_translation_report,
&gt;&gt; + &amp;ctx.dma_result);
&gt;&gt; +
&gt;&gt; +&nbsp;&nbsp;&nbsp; if (ctx.dma_result == 0 &amp;&amp; ctx.config.expected_result == 0) {
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_autofree uint8_t *buf = NULL;
&gt;&gt; +
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buf = g_malloc(ctx.config.dma_len);
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qtest_memread(ctx.qts, ctx.config.dma_gpa, buf, ctx.config.dma_len);
&gt;&gt; +
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; ctx.config.dma_len; i++) {
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint8_t expected;
&gt;&gt; +
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; expected = (ITD_DMA_WRITE_VAL &gt;&gt; ((i % 4) * 8)) &amp; 0xff;
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_assert_cmpuint(buf[i], ==, expected);
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&gt;&gt; +&nbsp;&nbsp;&nbsp; }
&gt;&gt; +}
&gt;&gt; +
&gt;&gt; +static uint32_t qriommu_get_table_index(uint64_t addr, int level)
&gt;&gt; +{
&gt;&gt; +&nbsp;&nbsp;&nbsp; /* SV39: 39-bit virtual address, 3-level page table */
&gt;&gt; +&nbsp;&nbsp;&nbsp; switch (level) {
&gt;&gt; +&nbsp;&nbsp;&nbsp; case 0:
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (addr &gt;&gt; 30) &amp; 0x1ff;&nbsp;&nbsp; /* L0: bits [38:30] */
&gt;&gt; +&nbsp;&nbsp;&nbsp; case 1:
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (addr &gt;&gt; 21) &amp; 0x1ff;&nbsp;&nbsp; /* L1: bits [29:21] */
&gt;&gt; +&nbsp;&nbsp;&nbsp; case 2:
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (addr &gt;&gt; 12) &amp; 0x1ff;&nbsp;&nbsp; /* L2: bits [20:12] */
&gt;&gt; +&nbsp;&nbsp;&nbsp; default:
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_assert_not_reached();
&gt;&gt; +&nbsp;&nbsp;&nbsp; }
&gt;&gt; +}
&gt;&gt; +
&gt;&gt; +static uint64_t qriommu_get_table_addr(uint64_t base, int level, uint64_t iova)
&gt;&gt; +{
&gt;&gt; +&nbsp;&nbsp;&nbsp; uint32_t index = qriommu_get_table_index(iova, level);
&gt;&gt; +&nbsp;&nbsp;&nbsp; return (base &amp; QRIOMMU_PTE_PPN_MASK) + (index * 8);
&gt;&gt; +}
&gt;&gt; +
&gt;&gt; +static void qriommu_map_leaf(QTestState *qts, uint64_t root_pa,
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t l0_pa, uint64_t l1_pa,
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t l0_pte_val, uint64_t l1_pte_val,
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t va, uint64_t pa, uint64_t leaf_attrs)
&gt;&gt; +{
&gt;&gt; +&nbsp;&nbsp;&nbsp; uint64_t l0_addr = qriommu_get_table_addr(root_pa, 0, va);
&gt;&gt; +&nbsp;&nbsp;&nbsp; uint64_t l1_addr = qriommu_get_table_addr(l0_pa, 1, va);
&gt;&gt; +&nbsp;&nbsp;&nbsp; uint64_t l2_addr = qriommu_get_table_addr(l1_pa, 2, va);
&gt;&gt; +
&gt;&gt; +&nbsp;&nbsp;&nbsp; qtest_writeq(qts, l0_addr, l0_pte_val);
&gt;&gt; +&nbsp;&nbsp;&nbsp; qtest_writeq(qts, l1_addr, l1_pte_val);
&gt;&gt; +&nbsp;&nbsp;&nbsp; qtest_writeq(qts, l2_addr, qriommu_encode_pte(pa, leaf_attrs));
&gt;&gt; +}
&gt;&gt; +
&gt;&gt; +static uint64_t qriommu_get_pte_attrs(QRIOMMUTransMode mode, bool is_leaf)
&gt;
&gt;
&gt; mode doesn't seem to be used?
&gt;
</span>You're right. The `mode` parameter is currently unused. I'll remove it
in the next version.
<span class="q">&gt;&gt; +{
&gt;&gt; +&nbsp;&nbsp;&nbsp; if (!is_leaf) {
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return QRIOMMU_NON_LEAF_PTE_MASK;
&gt;&gt; +&nbsp;&nbsp;&nbsp; }
&gt;&gt; +
&gt;&gt; +&nbsp;&nbsp;&nbsp; /* For leaf PTE, set RWX permissions */
&gt;&gt; +&nbsp;&nbsp;&nbsp; return QRIOMMU_LEAF_PTE_RW_MASK;
&gt;&gt; +}
&gt;&gt; +
&gt;&gt; ------------------------------&lt;snip&gt;------------------------------
&gt;&gt;
&gt;&gt;
&gt;&gt;
&gt;&gt; ------------------------------&lt;snip&gt;------------------------------
&gt;&gt; diff --git a/tests/qtest/libqos/qos-riscv-iommu.h b/tests/qtest/libqos/qos-riscv-iommu.h
&gt;&gt; new file mode 100644
&gt;&gt; index 0000000000..1f4efbf682
&gt;&gt; --- /dev/null
&gt;&gt; +++ b/tests/qtest/libqos/qos-riscv-iommu.h
&gt;&gt; @@ -0,0 +1,172 @@
&gt;&gt; +/*
&gt;&gt; + * QOS RISC-V IOMMU Module
&gt;&gt; + *
&gt;&gt; + * This module provides RISC-V IOMMU-specific helper functions for libqos tests,
&gt;&gt; + * encapsulating RISC-V IOMMU setup, and assertions.
&gt;&gt; + *
&gt;&gt; + * Copyright (c) 2026 Chao Liu &lt;chao.liu.zevorn@gmail.com&gt;
&gt;&gt; + *
&gt;&gt; + * SPDX-License-Identifier: GPL-2.0-or-later
&gt;&gt; + */
&gt;&gt; +
&gt;&gt; +#ifndef QTEST_LIBQOS_RISCV_IOMMU_H
&gt;&gt; +#define QTEST_LIBQOS_RISCV_IOMMU_H
&gt;&gt; +
&gt;&gt; +#include "hw/misc/iommu-testdev.h"
&gt;&gt; +
&gt;&gt; +/* RISC-V IOMMU MMIO register base for virt machine */
&gt;&gt; +#define VIRT_RISCV_IOMMU_BASE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0000000003010000ull
&gt;&gt; +
&gt;&gt; +/* RISC-V IOMMU queue and table base addresses */
&gt;&gt; +#define QRIOMMU_CQ_BASE_ADDR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x000000000e160000ull
&gt;&gt; +#define QRIOMMU_FQ_BASE_ADDR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x000000000e170000ull
&gt;&gt; +
&gt;&gt; +/* RISC-V IOMMU queue sizing */
&gt;&gt; +#define QRIOMMU_QUEUE_ENTRIES&nbsp; 1024
&gt;&gt; +#define QRIOMMU_CQ_ENTRY_SIZE&nbsp; 16
&gt;&gt; +#define QRIOMMU_FQ_ENTRY_SIZE&nbsp; 32
&gt;&gt; +
&gt;&gt; +/*
&gt;&gt; + * Translation tables and descriptors for RISC-V IOMMU.
&gt;&gt; + * Similar to ARM SMMUv3, but using RISC-V IOMMU terminology:
&gt;&gt; + * - Device Context (DC) instead of STE
&gt;&gt; + * - First-stage context (FSC) for S-stage translation
&gt;&gt; + * - IOHGATP for G-stage translation
&gt;&gt; + *
&gt;&gt; + * Granule size: 4KB pages
&gt;&gt; + * Page table levels: 3 levels for SV39 (L0, L1, L2)
&gt;&gt; + * IOVA size: 39-bit virtual address space
&gt;&gt; + */
&gt;&gt; +#define QRIOMMU_IOVA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0000000080604567ull
&gt;&gt; +#define QRIOMMU_IOHGATP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0000000000010000ull
&gt;&gt; +#define QRIOMMU_DDT_BASE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0000000000014000ull
&gt;&gt; +#define QRIOMMU_DC_BASE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (QRIOMMU_DDT_BASE)
&gt;&gt; +
&gt;&gt; +#define QRIOMMU_L0_PTE_VAL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0000000000011000ull
&gt;&gt; +#define QRIOMMU_L1_PTE_VAL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0000000000012000ull
&gt;&gt; +#define QRIOMMU_L2_PTE_VAL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0000000000013000ull
&gt;&gt; +
&gt;&gt; +#define QRIOMMU_G_IOHGATP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0000000000020000ull
&gt;&gt; +#define QRIOMMU_G_L0_PTE_VAL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0000000000021000ull
&gt;&gt; +#define QRIOMMU_G_L1_PTE_VAL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0000000000022000ull
&gt;&gt; +
&gt;&gt; +/* RISC-V page table entry masks */
&gt;&gt; +#define QRIOMMU_PTE_V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0000000000000001ull
&gt;&gt; +#define QRIOMMU_PTE_R&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0000000000000002ull
&gt;&gt; +#define QRIOMMU_PTE_W&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0000000000000004ull
&gt;&gt; +#define QRIOMMU_PTE_X&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0000000000000008ull
&gt;&gt; +#define QRIOMMU_PTE_U&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0000000000000010ull
&gt;&gt; +#define QRIOMMU_PTE_G&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0000000000000020ull
&gt;&gt; +#define QRIOMMU_PTE_A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0000000000000040ull
&gt;&gt; +#define QRIOMMU_PTE_D&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0000000000000080ull
&gt;
&gt;
&gt; I'm not entirely sure if there are similar definitions in the RISC-V header files, but if there are, I think we should consider reusing those definitions instead of redefining them.
&gt;
&gt;
&gt; Besides the correctness of the RISC-V page-table construction may need RISC-V experts to review closely.
&gt;
</span>Good catch. I found that `target/riscv/cpu_bits.h` already defines these
PTE bits (PTE_V, PTE_R, PTE_W, etc.). I'll reuse those definitions
instead of redefining them in the next version.


Thanks,
Chao
<span class="q">&gt;
&gt; Thanks,
&gt;
&gt; Tao
&gt;
&gt;&gt; +
&gt;&gt; +#define QRIOMMU_NON_LEAF_PTE_MASK&nbsp;&nbsp; (QRIOMMU_PTE_V)
&gt;&gt; +#define QRIOMMU_LEAF_PTE_RW_MASK&nbsp;&nbsp;&nbsp; (QRIOMMU_PTE_V | QRIOMMU_PTE_R | \n&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QRIOMMU_PTE_W | QRIOMMU_PTE_A | \n&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QRIOMMU_PTE_D)
&gt;&gt; +#define QRIOMMU_PTE_PPN_MASK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x003ffffffffffc00ull
&gt;&gt; +
&gt;&gt; +/* Address-space base offset for test tables */
&gt;&gt; +#define QRIOMMU_SPACE_OFFS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0000000080000000ull
&gt;&gt; +
&gt;&gt; +typedef enum QRIOMMUTransMode {
&gt;&gt; +&nbsp;&nbsp;&nbsp; QRIOMMU_TM_BARE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0,&nbsp;&nbsp;&nbsp; /* No translation (pass-through) */
&gt;&gt; +&nbsp;&nbsp;&nbsp; QRIOMMU_TM_S_STAGE_ONLY = 1,&nbsp;&nbsp;&nbsp; /* First-stage only (S-stage) */
&gt;&gt; +&nbsp;&nbsp;&nbsp; QRIOMMU_TM_G_STAGE_ONLY = 2,&nbsp;&nbsp;&nbsp; /* Second-stage only (G-stage) */
&gt;&gt; +&nbsp;&nbsp;&nbsp; QRIOMMU_TM_NESTED&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 3,&nbsp;&nbsp;&nbsp; /* Nested translation (S + G) */
&gt;&gt; +} QRIOMMUTransMode;
&gt;&gt; +
&gt;&gt; +typedef struct QRIOMMUTestConfig {
&gt;&gt; +&nbsp;&nbsp;&nbsp; QRIOMMUTransMode trans_mode;&nbsp;&nbsp;&nbsp; /* Translation mode */
&gt;&gt; +&nbsp;&nbsp;&nbsp; uint64_t dma_gpa;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* GPA for readback validation */
&gt;&gt; +&nbsp;&nbsp;&nbsp; uint32_t dma_len;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* DMA length for testing */
&gt;&gt; +&nbsp;&nbsp;&nbsp; uint32_t expected_result;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Expected DMA result */
&gt;&gt; +} QRIOMMUTestConfig;
&gt;&gt; +
&gt;&gt; +typedef struct QRIOMMUTestContext {
&gt;&gt; +&nbsp;&nbsp;&nbsp; QTestState *qts;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* QTest state handle */
&gt;&gt; +&nbsp;&nbsp;&nbsp; QPCIDevice *dev;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* PCI device handle */
&gt;&gt; +&nbsp;&nbsp;&nbsp; QPCIBar bar;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* PCI BAR for MMIO access */
&gt;&gt; +&nbsp;&nbsp;&nbsp; QRIOMMUTestConfig config;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Test configuration */
&gt;&gt; +&nbsp;&nbsp;&nbsp; uint64_t iommu_base;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* RISC-V IOMMU base address */
&gt;&gt; +&nbsp;&nbsp;&nbsp; uint32_t trans_status;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Translation configuration status */
&gt;&gt; +&nbsp;&nbsp;&nbsp; uint32_t dma_result;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* DMA operation result */
&gt;&gt; +&nbsp;&nbsp;&nbsp; uint32_t device_id;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Device ID for the test */
&gt;&gt; +} QRIOMMUTestContext;
&gt;&gt; +
&gt;&gt; +/*
&gt;&gt; + * qriommu_setup_and_enable_translation - Complete translation setup and enable
&gt;&gt; + *
&gt;&gt; + * @ctx: Test context containing configuration and device handles
&gt;&gt; + *
&gt;&gt; + * Returns: Translation status (0 = success, non-zero = error)
&gt;&gt; + *
&gt;&gt; + * This function performs the complete translation setup sequence:
&gt;&gt; + * 1. Builds all required RISC-V IOMMU structures (DC, page tables)
&gt;&gt; + * 2. Programs RISC-V IOMMU registers
&gt;&gt; + * 3. Returns configuration status
&gt;&gt; + */
&gt;&gt; +uint32_t qriommu_setup_and_enable_translation(QRIOMMUTestContext *ctx);
&gt;&gt; +
&gt;&gt; +/*
&gt;&gt; + * qriommu_build_translation - Build RISC-V IOMMU translation structures
&gt;&gt; + *
&gt;&gt; + * @qts: QTest state handle
&gt;&gt; + * @mode: Translation mode (BARE, S_STAGE_ONLY, G_STAGE_ONLY, NESTED)
&gt;&gt; + * @device_id: Device ID
&gt;&gt; + *
&gt;&gt; + * Returns: Build status (0 = success, non-zero = error)
&gt;&gt; + *
&gt;&gt; + * Constructs all necessary RISC-V IOMMU translation structures in guest memory:
&gt;&gt; + * - Device Context (DC) for the given device ID
&gt;&gt; + * - First-stage context (FSC) if S-stage translation is involved
&gt;&gt; + * - Complete page table hierarchy based on translation mode
&gt;&gt; + */
&gt;&gt; +uint32_t qriommu_build_translation(QTestState *qts, QRIOMMUTransMode mode,
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint32_t device_id);
&gt;&gt; +
&gt;&gt; +/*
&gt;&gt; + * qriommu_program_regs - Program all required RISC-V IOMMU registers
&gt;&gt; + *
&gt;&gt; + * @qts: QTest state handle
&gt;&gt; + * @iommu_base: RISC-V IOMMU base address
&gt;&gt; + *
&gt;&gt; + * Programs RISC-V IOMMU registers:
&gt;&gt; + * - Device Directory Table Pointer (DDTP)
&gt;&gt; + * - Command queue (base, head, tail)
&gt;&gt; + * - Fault queue (base, head, tail)
&gt;&gt; + * - Control and status registers
&gt;&gt; + */
&gt;&gt; +void qriommu_program_regs(QTestState *qts, uint64_t iommu_base);
&gt;&gt; +
&gt;&gt; +/*
&gt;&gt; + * qriommu_setup_translation_tables - Setup RISC-V IOMMU page table hierarchy
&gt;&gt; + *
&gt;&gt; + * @qts: QTest state handle
&gt;&gt; + * @iova: Input Virtual Address to translate
&gt;&gt; + * @mode: Translation mode
&gt;&gt; + *
&gt;&gt; + * This function builds the complete page table structure for translating
&gt;&gt; + * the given IOVA through the RISC-V IOMMU. The structure varies based on mode:
&gt;&gt; + *
&gt;&gt; + * - BARE: No translation (pass-through)
&gt;&gt; + * - S_STAGE_ONLY: Single S-stage walk (IOVA -&gt; PA)
&gt;&gt; + * - G_STAGE_ONLY: Single G-stage walk (IPA -&gt; PA)
&gt;&gt; + * - NESTED: S-stage walk (IOVA -&gt; IPA) + G-stage walk (IPA -&gt; PA)
&gt;&gt; + */
&gt;&gt; +void qriommu_setup_translation_tables(QTestState *qts,
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t iova,
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QRIOMMUTransMode mode);
&gt;&gt; +
&gt;&gt; +/* High-level test execution helpers */
&gt;&gt; +void qriommu_run_translation_case(QTestState *qts, QPCIDevice *dev,
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QPCIBar bar, uint64_t iommu_base,
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const QRIOMMUTestConfig *cfg);
&gt;&gt; +
&gt;&gt; +/* Calculate expected DMA result */
&gt;&gt; +uint32_t qriommu_expected_dma_result(QRIOMMUTestContext *ctx);
&gt;&gt; +
&gt;&gt; +/* Build DMA attributes for RISC-V IOMMU */
&gt;&gt; +uint32_t qriommu_build_dma_attrs(void);
&gt;&gt; +
&gt;&gt; +#endif /* QTEST_LIBQOS_RISCV_IOMMU_H */
&gt;
&gt;
</span>

<a href="#md4ab43b6667cfd798638f36984d5dfce06909dc3" id="ed4ab43b6667cfd798638f36984d5dfce06909dc3">^</a> <a href="../../d89f2510-22ac-47b4-adc6-b23e5cf6306e@gmail.com/">permalink</a> <a href="../../d89f2510-22ac-47b4-adc6-b23e5cf6306e@gmail.com/raw">raw</a> <a href="../../d89f2510-22ac-47b4-adc6-b23e5cf6306e@gmail.com/#R">reply</a>	[<a href="../../d89f2510-22ac-47b4-adc6-b23e5cf6306e@gmail.com/T/#u"><b>flat</b></a>|<a href="../../d89f2510-22ac-47b4-adc6-b23e5cf6306e@gmail.com/t/#u">nested</a>] <a href="#rd4ab43b6667cfd798638f36984d5dfce06909dc3">13+ messages in thread</a></pre><hr><pre><a href="#e3092fd884052bbb4a29074f98ad96f50e0a66bfa" id="m3092fd884052bbb4a29074f98ad96f50e0a66bfa">*</a> <b>Re: [RFC PATCH v1 2/2] tests/qtest: Add RISC-V IOMMU bare-metal test</b>
  2026-01-28 15:36   ` <a href="#med032f1adb576354a7b019f27ef1f7f96608a772">Tao Tang</a>
<b>@ 2026-01-28 16:17     ` Chao Liu</b>
  <a href="#r3092fd884052bbb4a29074f98ad96f50e0a66bfa">0 siblings, 0 replies; 13+ messages in thread</a>
From: Chao Liu @ 2026-01-28 16:17 UTC (<a href="../../4acb0030-8667-476d-a500-717140ae49c5@gmail.com/">permalink</a> / <a href="../../4acb0030-8667-476d-a500-717140ae49c5@gmail.com/raw">raw</a>)
  To: Tao Tang, Alistair Francis, Daniel Henrique Barboza,
	Palmer Dabbelt, Weiwei Li, Liu Zhiwei, Fabiano Rosas,
	Laurent Vivier, Paolo Bonzini
  Cc: <a href="../../../qemu-devel/?t=20260128161950">qemu-devel</a>, <a href="../../../qemu-riscv/?t=20260128161950">qemu-riscv</a>, hust-os-kernel-patches

Hi Tao,

On 1/28/2026 11:36 PM, Tao Tang wrote:
<span class="q">&gt; Hi Chao,
&gt;
&gt; On 2026/1/28 20:09, Chao Liu wrote:
&gt;&gt; Add a qtest suite for the RISC-V IOMMU PCI device on the virt machine.
&gt;&gt; The test exercises bare, S-stage, G-stage, and nested translation paths
&gt;&gt; using iommu-testdev and the qos-riscv-iommu helpers.
&gt;&gt;
&gt;&gt; The test validates:
&gt;&gt; - Device context (DC) configuration
&gt;&gt; - SV39 page table walks for S-stage translation
&gt;&gt; - SV39x4 page table walks for G-stage translation
&gt;&gt; - Nested translation combining both stages
&gt;&gt; - FCTL register constraints
&gt;&gt;
&gt;&gt; This provides regression coverage for the RISC-V IOMMU implementation
&gt;&gt; without requiring a full guest OS boot.
&gt;&gt;
&gt;&gt; Signed-off-by: Chao Liu &lt;chao.liu.zevorn@gmail.com&gt;
&gt;&gt; ---
&gt;&gt; &nbsp; MAINTAINERS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; 1 +
&gt;&gt; &nbsp; tests/qtest/iommu-riscv-test.c | 279 +++++++++++++++++++++++++++++++++
&gt;&gt; &nbsp; tests/qtest/meson.build&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; 5 +-
&gt;&gt; &nbsp; 3 files changed, 284 insertions(+), 1 deletion(-)
&gt;&gt; &nbsp; create mode 100644 tests/qtest/iommu-riscv-test.c
&gt;&gt;
&gt;&gt; diff --git a/MAINTAINERS b/MAINTAINERS
&gt;&gt; index 894e05bd2c..c7400c83d2 100644
&gt;&gt; --- a/MAINTAINERS
&gt;&gt; +++ b/MAINTAINERS
&gt;&gt; @@ -347,6 +347,7 @@ F: common-user/host/riscv*
&gt;&gt; &nbsp; F: tests/functional/riscv32
&gt;&gt; &nbsp; F: tests/functional/riscv64
&gt;&gt; &nbsp; F: tests/tcg/riscv64/
&gt;&gt; +F: tests/qtest/iommu-riscv-test.c
&gt;&gt; &nbsp; &nbsp; RISC-V XThead* extensions
&gt;&gt; &nbsp; M: Christoph Muellner &lt;christoph.muellner@vrull.eu&gt;
&gt;&gt; diff --git a/tests/qtest/iommu-riscv-test.c b/tests/qtest/iommu-riscv-test.c
&gt;&gt; new file mode 100644
&gt;&gt; index 0000000000..9438578e1e
&gt;&gt; --- /dev/null
&gt;&gt; +++ b/tests/qtest/iommu-riscv-test.c
&gt;&gt; @@ -0,0 +1,279 @@
&gt;&gt; +/*
&gt;&gt; + * QTest testcase for RISC-V IOMMU with iommu-testdev
&gt;&gt; + *
&gt;&gt; + * This QTest file is used to test the RISC-V IOMMU with iommu-testdev so that
&gt;&gt; + * we can test RISC-V IOMMU without any guest kernel or firmware.
&gt;&gt; + *
&gt;&gt; + * Copyright (c) 2026 Chao Liu &lt;chao.liu.zevorn@gmail.com&gt;
&gt;&gt; + *
&gt;&gt; + * SPDX-License-Identifier: GPL-2.0-or-later
&gt;&gt; + */
&gt;&gt; +
&gt;&gt; +#include "qemu/osdep.h"
&gt;&gt; +#include "libqtest.h"
&gt;&gt; +#include "libqos/pci.h"
&gt;&gt; +#include "libqos/generic-pcihost.h"
&gt;&gt; +#include "hw/pci/pci_regs.h"
&gt;&gt; +#include "hw/misc/iommu-testdev.h"
&gt;&gt; +#include "hw/riscv/riscv-iommu-bits.h"
&gt;&gt; +#include "libqos/qos-riscv-iommu.h"
&gt;&gt; +#include "libqos/riscv-iommu.h"
&gt;&gt; +
&gt;&gt; +#define DMA_LEN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4
&gt;&gt; +
&gt;&gt; +/* RISC-V virt machine PCI configuration */
&gt;&gt; +#define RISCV_GPEX_PIO_BASE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x3000000
&gt;&gt; +#define RISCV_BUS_PIO_LIMIT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x10000
&gt;&gt; +#define RISCV_BUS_MMIO_ALLOC_PTR&nbsp;&nbsp; 0x40000000
&gt;&gt; +#define RISCV_BUS_MMIO_LIMIT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x80000000
&gt;&gt; +#define RISCV_ECAM_ALLOC_PTR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x30000000
&gt;&gt; +
&gt;&gt; +typedef struct RiscvIommuTestState {
&gt;&gt; +&nbsp;&nbsp;&nbsp; QTestState *qts;
&gt;&gt; +&nbsp;&nbsp;&nbsp; QGenericPCIBus gbus;
&gt;&gt; +&nbsp;&nbsp;&nbsp; QPCIDevice *iommu_dev;
&gt;&gt; +&nbsp;&nbsp;&nbsp; QPCIDevice *testdev;
&gt;&gt; +&nbsp;&nbsp;&nbsp; QPCIBar testdev_bar;
&gt;&gt; +&nbsp;&nbsp;&nbsp; uint64_t iommu_base;
&gt;&gt; +} RiscvIommuTestState;
&gt;&gt; +
&gt;&gt; +static void riscv_config_qpci_bus(QGenericPCIBus *qpci)
&gt;&gt; +{
&gt;&gt; +&nbsp;&nbsp;&nbsp; qpci-&gt;gpex_pio_base = RISCV_GPEX_PIO_BASE;
&gt;&gt; +&nbsp;&nbsp;&nbsp; qpci-&gt;bus.pio_limit = RISCV_BUS_PIO_LIMIT;
&gt;&gt; +&nbsp;&nbsp;&nbsp; qpci-&gt;bus.mmio_alloc_ptr = RISCV_BUS_MMIO_ALLOC_PTR;
&gt;&gt; +&nbsp;&nbsp;&nbsp; qpci-&gt;bus.mmio_limit = RISCV_BUS_MMIO_LIMIT;
&gt;&gt; +&nbsp;&nbsp;&nbsp; qpci-&gt;ecam_alloc_ptr = RISCV_ECAM_ALLOC_PTR;
&gt;&gt; +}
&gt;&gt; +
&gt;&gt; +static uint64_t riscv_iommu_expected_gpa(uint64_t iova)
&gt;&gt; +{
&gt;&gt; +&nbsp;&nbsp;&nbsp; return QRIOMMU_SPACE_OFFS + QRIOMMU_L2_PTE_VAL + (iova &amp; 0xfff);
&gt;&gt; +}
&gt;&gt; +
&gt;&gt; +static void save_fn(QPCIDevice *dev, int devfn, void *data)
&gt;&gt; +{
&gt;&gt; +&nbsp;&nbsp;&nbsp; QPCIDevice **pdev = (QPCIDevice **) data;
&gt;&gt; +&nbsp;&nbsp;&nbsp; uint16_t vendor = qpci_config_readw(dev, 0);
&gt;&gt; +&nbsp;&nbsp;&nbsp; uint16_t device = qpci_config_readw(dev, 2);
&gt;&gt; +
&gt;&gt; +&nbsp;&nbsp;&nbsp; g_test_message("Found PCI device: vendor=0x%04x device=0x%04x devfn=0x%02x",
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vendor, device, devfn);
&gt;&gt; +
&gt;&gt; +&nbsp;&nbsp;&nbsp; if (!*pdev) {
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pdev = dev;
&gt;&gt; +&nbsp;&nbsp;&nbsp; }
&gt;&gt; +}
&gt;&gt; +
&gt;&gt; +static QPCIDevice *find_riscv_iommu_pci(QGenericPCIBus *gbus,
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uint64_t *iommu_base)
&gt;&gt; +{
&gt;&gt; +&nbsp;&nbsp;&nbsp; QPCIDevice *iommu_dev = NULL;
&gt;&gt; +&nbsp;&nbsp;&nbsp; QPCIBar iommu_bar;
&gt;&gt; +
&gt;&gt; +&nbsp;&nbsp;&nbsp; g_test_message("Searching for riscv-iommu-pci "
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "(vendor=0x%04x, device=0x%04x)",
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RISCV_IOMMU_PCI_VENDOR_ID, RISCV_IOMMU_PCI_DEVICE_ID);
&gt;&gt; +
&gt;&gt; +&nbsp;&nbsp;&nbsp; qpci_device_foreach(&amp;gbus-&gt;bus, RISCV_IOMMU_PCI_VENDOR_ID,
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RISCV_IOMMU_PCI_DEVICE_ID, save_fn, &amp;iommu_dev);
&gt;&gt; +
&gt;&gt; +&nbsp;&nbsp;&nbsp; if (!iommu_dev) {
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_test_message("riscv-iommu-pci device not found!");
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return NULL;
&gt;&gt; +&nbsp;&nbsp;&nbsp; }
&gt;&gt; +
&gt;&gt; +&nbsp;&nbsp;&nbsp; g_test_message("Found riscv-iommu-pci at devfn=0x%02x", iommu_dev-&gt;devfn);
&gt;&gt; +
&gt;&gt; +&nbsp;&nbsp;&nbsp; qpci_device_enable(iommu_dev);
&gt;&gt; +&nbsp;&nbsp;&nbsp; iommu_bar = qpci_iomap(iommu_dev, 0, NULL);
&gt;&gt; +&nbsp;&nbsp;&nbsp; g_assert_false(iommu_bar.is_io);
&gt;&gt; +
&gt;&gt; +&nbsp;&nbsp;&nbsp; *iommu_base = iommu_bar.addr;
&gt;&gt; +&nbsp;&nbsp;&nbsp; g_test_message("RISC-V IOMMU MMIO base address: 0x%lx", *iommu_base);
&gt;
&gt;
&gt; There was a cross-compilation error on mingw64:
&gt;
&gt; ../tests/qtest/iommu-riscv-test.c: In function 'find_riscv_iommu_pci':
&gt; ../tests/qtest/iommu-riscv-test.c:93:57: error: format '%lx' expects argument of type 'long unsigned int', but argument 2 has type 'uint64_t' {aka 'long long unsigned int'} [-Werror=format=]
&gt; &nbsp; &nbsp;93 |&nbsp; &nbsp; &nbsp;g_test_message("RISC-V IOMMU MMIO base address: 0x%lx", *iommu_base);
&gt; &nbsp; &nbsp; &nbsp; | &nbsp;~~^ &nbsp;~~~~~~~~~~~
&gt; &nbsp; &nbsp; &nbsp; | &nbsp;| &nbsp;|
&gt; &nbsp; &nbsp; &nbsp; | &nbsp;| &nbsp;uint64_t {aka long long unsigned int}
&gt; &nbsp; &nbsp; &nbsp; | &nbsp;long unsigned int
&gt; &nbsp; &nbsp; &nbsp; | &nbsp;%llx
&gt;
&gt; I think we should use PRIx64 instead.
</span>
|Good catch. I'll fix this by using PRIx64 in the next version:|

|-&nbsp; &nbsp; g_test_message("RISC-V IOMMU MMIO base address: 0x%lx", *iommu_base);
+&nbsp; &nbsp; g_test_message("RISC-V IOMMU MMIO base address: 0x%" PRIx64, *iommu_base);|

<span class="q">&gt;
&gt; You can check the result in this link [1]. And try it again with Pierrick's downstream fork [2]
&gt;
&gt; [1] <a href="https://github.com/hnusdr/qemu/actions/runs/21438370066/job/61734760185">https://github.com/hnusdr/qemu/actions/runs/21438370066/job/61734760185</a>
&gt;
&gt; [2] <a href="https://github.com/pbo-linaro/qemu/">https://github.com/pbo-linaro/qemu/</a>
&gt;
&gt;
</span>|Thanks for the CI links. I'll validate the v2 series with Pierrick's
qemu-ci workflow before sending.

Thanks,
Chao|

<span class="q">&gt; Thanks,
&gt;
&gt; Tao
&gt;
&gt;&gt; +
&gt;&gt; +&nbsp;&nbsp;&nbsp; return iommu_dev;
&gt;&gt; +}
&gt;&gt; +
&gt;&gt; +static QPCIDevice *find_iommu_testdev(QGenericPCIBus *gbus, QPCIBar *bar)
&gt;&gt; +{
&gt;&gt; +&nbsp;&nbsp;&nbsp; QPCIDevice *dev = NULL;
&gt;&gt; +
&gt;&gt; +&nbsp;&nbsp;&nbsp; g_test_message("Searching for iommu-testdev (vendor=0x%04x, device=0x%04x)",
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IOMMU_TESTDEV_VENDOR_ID, IOMMU_TESTDEV_DEVICE_ID);
&gt;&gt; +
&gt;&gt; +&nbsp;&nbsp;&nbsp; qpci_device_foreach(&amp;gbus-&gt;bus, IOMMU_TESTDEV_VENDOR_ID,
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IOMMU_TESTDEV_DEVICE_ID, save_fn, &amp;dev);
&gt;&gt; +&nbsp;&nbsp;&nbsp; g_assert(dev);
&gt;&gt; +
&gt;&gt; +&nbsp;&nbsp;&nbsp; qpci_device_enable(dev);
&gt;&gt; +&nbsp;&nbsp;&nbsp; *bar = qpci_iomap(dev, 0, NULL);
&gt;&gt; +&nbsp;&nbsp;&nbsp; g_assert_false(bar-&gt;is_io);
&gt;&gt; +
&gt;&gt; +&nbsp;&nbsp;&nbsp; return dev;
&gt;&gt; +}
&gt;&gt; +
&gt;&gt; +static bool riscv_iommu_test_setup(RiscvIommuTestState *state)
&gt;&gt; +{
&gt;&gt; +&nbsp;&nbsp;&nbsp; if (!qtest_has_machine("virt")) {
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_test_skip("virt machine not available");
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;
&gt;&gt; +&nbsp;&nbsp;&nbsp; }
&gt;&gt; +
&gt;&gt; +&nbsp;&nbsp;&nbsp; state-&gt;qts = qtest_init("-machine virt,acpi=off "
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "-cpu max -smp 1 -m 512 -net none "
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "-device riscv-iommu-pci "
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "-device iommu-testdev");
&gt;&gt; +
&gt;&gt; +&nbsp;&nbsp;&nbsp; qpci_init_generic(&amp;state-&gt;gbus, state-&gt;qts, NULL, false);
&gt;&gt; +&nbsp;&nbsp;&nbsp; riscv_config_qpci_bus(&amp;state-&gt;gbus);
&gt;&gt; +
&gt;&gt; +&nbsp;&nbsp;&nbsp; state-&gt;iommu_dev = find_riscv_iommu_pci(&amp;state-&gt;gbus, &amp;state-&gt;iommu_base);
&gt;&gt; +&nbsp;&nbsp;&nbsp; g_assert(state-&gt;iommu_dev);
&gt;&gt; +
&gt;&gt; +&nbsp;&nbsp;&nbsp; state-&gt;testdev = find_iommu_testdev(&amp;state-&gt;gbus, &amp;state-&gt;testdev_bar);
&gt;&gt; +&nbsp;&nbsp;&nbsp; g_assert(state-&gt;testdev);
&gt;&gt; +
&gt;&gt; +&nbsp;&nbsp;&nbsp; return true;
&gt;&gt; +}
&gt;&gt; +
&gt;&gt; +static void riscv_iommu_test_teardown(RiscvIommuTestState *state)
&gt;&gt; +{
&gt;&gt; +&nbsp;&nbsp;&nbsp; qtest_quit(state-&gt;qts);
&gt;&gt; +}
&gt;&gt; +
&gt;&gt; +static uint64_t riscv_iommu_check(QTestState *qts, uint64_t iommu_base,
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; QRIOMMUTransMode mode)
&gt;&gt; +{
&gt;&gt; +&nbsp;&nbsp;&nbsp; uint64_t cap;
&gt;&gt; +&nbsp;&nbsp;&nbsp; uint64_t ddtp;
&gt;&gt; +&nbsp;&nbsp;&nbsp; uint32_t cqcsr;
&gt;&gt; +&nbsp;&nbsp;&nbsp; uint32_t fqcsr;
&gt;&gt; +&nbsp;&nbsp;&nbsp; uint32_t pqcsr;
&gt;&gt; +&nbsp;&nbsp;&nbsp; uint32_t fctl;
&gt;&gt; +&nbsp;&nbsp;&nbsp; uint32_t fctl_mask;
&gt;&gt; +&nbsp;&nbsp;&nbsp; uint32_t fctl_desired;
&gt;&gt; +&nbsp;&nbsp;&nbsp; uint32_t igs;
&gt;&gt; +
&gt;&gt; +&nbsp;&nbsp;&nbsp; cap = qtest_readq(qts, iommu_base + RISCV_IOMMU_REG_CAP);
&gt;&gt; +&nbsp;&nbsp;&nbsp; g_assert_cmpuint((uint32_t)(cap &amp; RISCV_IOMMU_CAP_VERSION), ==,
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RISCV_IOMMU_SPEC_DOT_VER);
&gt;&gt; +
&gt;&gt; +&nbsp;&nbsp;&nbsp; fctl = qtest_readl(qts, iommu_base + RISCV_IOMMU_REG_FCTL);
&gt;&gt; +&nbsp;&nbsp;&nbsp; igs = (cap &amp; RISCV_IOMMU_CAP_IGS) &gt;&gt; 28;
&gt;&gt; +&nbsp;&nbsp;&nbsp; g_assert_cmpuint(igs, &lt;=, RISCV_IOMMU_CAP_IGS_BOTH);
&gt;&gt; +
&gt;&gt; +&nbsp;&nbsp;&nbsp; fctl_mask = RISCV_IOMMU_FCTL_BE | RISCV_IOMMU_FCTL_WSI |
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RISCV_IOMMU_FCTL_GXL;
&gt;&gt; +&nbsp;&nbsp;&nbsp; fctl_desired = fctl &amp; ~fctl_mask;
&gt;&gt; +&nbsp;&nbsp;&nbsp; if (igs == RISCV_IOMMU_CAP_IGS_WSI) {
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fctl_desired |= RISCV_IOMMU_FCTL_WSI;
&gt;&gt; +&nbsp;&nbsp;&nbsp; }
&gt;&gt; +
&gt;&gt; +&nbsp;&nbsp;&nbsp; if ((fctl &amp; fctl_mask) != (fctl_desired &amp; fctl_mask)) {
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ddtp = qtest_readq(qts, iommu_base + RISCV_IOMMU_REG_DDTP);
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cqcsr = qtest_readl(qts, iommu_base + RISCV_IOMMU_REG_CQCSR);
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fqcsr = qtest_readl(qts, iommu_base + RISCV_IOMMU_REG_FQCSR);
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pqcsr = qtest_readl(qts, iommu_base + RISCV_IOMMU_REG_PQCSR);
&gt;&gt; +
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_assert_cmpuint((uint32_t)(ddtp &amp; RISCV_IOMMU_DDTP_MODE), ==,
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RISCV_IOMMU_DDTP_MODE_OFF);
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_assert_cmpuint(cqcsr &amp; RISCV_IOMMU_CQCSR_CQON, ==, 0);
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_assert_cmpuint(fqcsr &amp; RISCV_IOMMU_FQCSR_FQON, ==, 0);
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_assert_cmpuint(pqcsr &amp; RISCV_IOMMU_PQCSR_PQON, ==, 0);
&gt;&gt; +
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qtest_writel(qts, iommu_base + RISCV_IOMMU_REG_FCTL, fctl_desired);
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fctl = qtest_readl(qts, iommu_base + RISCV_IOMMU_REG_FCTL);
&gt;&gt; +&nbsp;&nbsp;&nbsp; }
&gt;&gt; +
&gt;&gt; +&nbsp;&nbsp;&nbsp; g_assert_cmpuint(fctl &amp; fctl_mask, ==, fctl_desired &amp; fctl_mask);
&gt;&gt; +
&gt;&gt; +&nbsp;&nbsp;&nbsp; if (mode == QRIOMMU_TM_S_STAGE_ONLY || mode == QRIOMMU_TM_NESTED) {
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_assert((cap &amp; RISCV_IOMMU_CAP_SV39) != 0);
&gt;&gt; +&nbsp;&nbsp;&nbsp; }
&gt;&gt; +&nbsp;&nbsp;&nbsp; if (mode == QRIOMMU_TM_G_STAGE_ONLY || mode == QRIOMMU_TM_NESTED) {
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_assert((cap &amp; RISCV_IOMMU_CAP_SV39X4) != 0);
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g_assert_cmpuint(fctl &amp; RISCV_IOMMU_FCTL_GXL, ==, 0);
&gt;&gt; +&nbsp;&nbsp;&nbsp; }
&gt;&gt; +
&gt;&gt; +&nbsp;&nbsp;&nbsp; return cap;
&gt;&gt; +}
&gt;&gt; +
&gt;&gt; +static void run_riscv_iommu_translation(const QRIOMMUTestConfig *cfg)
&gt;&gt; +{
&gt;&gt; +&nbsp;&nbsp;&nbsp; RiscvIommuTestState state = { 0 };
&gt;&gt; +
&gt;&gt; +&nbsp;&nbsp;&nbsp; if (!riscv_iommu_test_setup(&amp;state)) {
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;
&gt;&gt; +&nbsp;&nbsp;&nbsp; }
&gt;&gt; +
&gt;&gt; +&nbsp;&nbsp;&nbsp; riscv_iommu_check(state.qts, state.iommu_base, cfg-&gt;trans_mode);
&gt;&gt; +
&gt;&gt; +&nbsp;&nbsp;&nbsp; g_test_message("### RISC-V IOMMU translation mode=%d ###",
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cfg-&gt;trans_mode);
&gt;&gt; +&nbsp;&nbsp;&nbsp; qriommu_run_translation_case(state.qts, state.testdev, state.testdev_bar,
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; state.iommu_base, cfg);
&gt;&gt; +&nbsp;&nbsp;&nbsp; riscv_iommu_test_teardown(&amp;state);
&gt;&gt; +}
&gt;&gt; +
&gt;&gt; +static void test_riscv_iommu_bare(void)
&gt;&gt; +{
&gt;&gt; +&nbsp;&nbsp;&nbsp; QRIOMMUTestConfig cfg = {
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .trans_mode = QRIOMMU_TM_BARE,
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .dma_gpa = QRIOMMU_IOVA,
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .dma_len = DMA_LEN,
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .expected_result = 0,
&gt;&gt; +&nbsp;&nbsp;&nbsp; };
&gt;&gt; +
&gt;&gt; +&nbsp;&nbsp;&nbsp; run_riscv_iommu_translation(&amp;cfg);
&gt;&gt; +}
&gt;&gt; +
&gt;&gt; +static void test_riscv_iommu_s_stage_only(void)
&gt;&gt; +{
&gt;&gt; +&nbsp;&nbsp;&nbsp; QRIOMMUTestConfig cfg = {
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .trans_mode = QRIOMMU_TM_S_STAGE_ONLY,
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .dma_gpa = riscv_iommu_expected_gpa(QRIOMMU_IOVA),
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .dma_len = DMA_LEN,
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .expected_result = 0,
&gt;&gt; +&nbsp;&nbsp;&nbsp; };
&gt;&gt; +
&gt;&gt; +&nbsp;&nbsp;&nbsp; run_riscv_iommu_translation(&amp;cfg);
&gt;&gt; +}
&gt;&gt; +
&gt;&gt; +static void test_riscv_iommu_g_stage_only(void)
&gt;&gt; +{
&gt;&gt; +&nbsp;&nbsp;&nbsp; QRIOMMUTestConfig cfg = {
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .trans_mode = QRIOMMU_TM_G_STAGE_ONLY,
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .dma_gpa = riscv_iommu_expected_gpa(QRIOMMU_IOVA),
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .dma_len = DMA_LEN,
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .expected_result = 0,
&gt;&gt; +&nbsp;&nbsp;&nbsp; };
&gt;&gt; +
&gt;&gt; +&nbsp;&nbsp;&nbsp; run_riscv_iommu_translation(&amp;cfg);
&gt;&gt; +}
&gt;&gt; +
&gt;&gt; +static void test_riscv_iommu_nested(void)
&gt;&gt; +{
&gt;&gt; +&nbsp;&nbsp;&nbsp; QRIOMMUTestConfig cfg = {
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .trans_mode = QRIOMMU_TM_NESTED,
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .dma_gpa = riscv_iommu_expected_gpa(QRIOMMU_IOVA),
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .dma_len = DMA_LEN,
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .expected_result = 0,
&gt;&gt; +&nbsp;&nbsp;&nbsp; };
&gt;&gt; +
&gt;&gt; +&nbsp;&nbsp;&nbsp; run_riscv_iommu_translation(&amp;cfg);
&gt;&gt; +}
&gt;&gt; +
&gt;&gt; +int main(int argc, char **argv)
&gt;&gt; +{
&gt;&gt; +&nbsp;&nbsp;&nbsp; g_test_init(&amp;argc, &amp;argv, NULL);
&gt;&gt; +&nbsp;&nbsp;&nbsp; qtest_add_func("/iommu-testdev/translation/bare",
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; test_riscv_iommu_bare);
&gt;&gt; +&nbsp;&nbsp;&nbsp; qtest_add_func("/iommu-testdev/translation/s-stage-only",
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; test_riscv_iommu_s_stage_only);
&gt;&gt; +&nbsp;&nbsp;&nbsp; qtest_add_func("/iommu-testdev/translation/g-stage-only",
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; test_riscv_iommu_g_stage_only);
&gt;&gt; +&nbsp;&nbsp;&nbsp; qtest_add_func("/iommu-testdev/translation/ns-nested",
&gt;&gt; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; test_riscv_iommu_nested);
&gt;&gt; +&nbsp;&nbsp;&nbsp; return g_test_run();
&gt;&gt; +}
&gt;&gt; diff --git a/tests/qtest/meson.build b/tests/qtest/meson.build
&gt;&gt; index a8b09d065f..eb45e0f97d 100644
&gt;&gt; --- a/tests/qtest/meson.build
&gt;&gt; +++ b/tests/qtest/meson.build
&gt;&gt; @@ -286,7 +286,10 @@ qtests_riscv32 = \n&gt;&gt; &nbsp;&nbsp;&nbsp; (config_all_devices.has_key('CONFIG_SIFIVE_E_AON') ? ['sifive-e-aon-watchdog-test'] : [])
&gt;&gt; &nbsp; &nbsp; qtests_riscv64 = ['riscv-csr-test'] + \n&gt;&gt; -&nbsp; (unpack_edk2_blobs ? ['bios-tables-test'] : [])
&gt;&gt; +&nbsp; (unpack_edk2_blobs ? ['bios-tables-test'] : []) + \n&gt;&gt; +&nbsp; (config_all_devices.has_key('CONFIG_IOMMU_TESTDEV') and
&gt;&gt; +&nbsp;&nbsp; config_all_devices.has_key('CONFIG_RISCV_IOMMU') ?
&gt;&gt; +&nbsp;&nbsp; ['iommu-riscv-test'] : [])
&gt;&gt; &nbsp; &nbsp; qos_test_ss = ss.source_set()
&gt;&gt; &nbsp; qos_test_ss.add(
&gt;
</span>

<a href="#m3092fd884052bbb4a29074f98ad96f50e0a66bfa" id="e3092fd884052bbb4a29074f98ad96f50e0a66bfa">^</a> <a href="../../4acb0030-8667-476d-a500-717140ae49c5@gmail.com/">permalink</a> <a href="../../4acb0030-8667-476d-a500-717140ae49c5@gmail.com/raw">raw</a> <a href="../../4acb0030-8667-476d-a500-717140ae49c5@gmail.com/#R">reply</a>	[<a href="../../4acb0030-8667-476d-a500-717140ae49c5@gmail.com/T/#u"><b>flat</b></a>|<a href="../../4acb0030-8667-476d-a500-717140ae49c5@gmail.com/t/#u">nested</a>] <a href="#r3092fd884052bbb4a29074f98ad96f50e0a66bfa">13+ messages in thread</a></pre><hr><pre><a href="#ed2e478315f3a497a04cf4723c11de56fce9a1c9b" id="md2e478315f3a497a04cf4723c11de56fce9a1c9b">*</a> <b>Re: [RFC PATCH v1 0/2] tests/qtest: Add RISC-V IOMMU bare-metal test using iommu-testdev</b>
  2026-01-28 14:42 ` <a href="#m3469b37b570b142238cad69d7b5d435673adf0f8">[RFC PATCH v1 0/2] tests/qtest: Add RISC-V IOMMU bare-metal test using iommu-testdev</a> Daniel Henrique Barboza
<b>@ 2026-01-28 16:25   ` Chao Liu</b>
  <a href="#rd2e478315f3a497a04cf4723c11de56fce9a1c9b">0 siblings, 0 replies; 13+ messages in thread</a>
From: Chao Liu @ 2026-01-28 16:25 UTC (<a href="../../4a717b95-e7c7-4a9a-b98f-37df63602a2a@gmail.com/">permalink</a> / <a href="../../4a717b95-e7c7-4a9a-b98f-37df63602a2a@gmail.com/raw">raw</a>)
  To: Daniel Henrique Barboza, Alistair Francis, Palmer Dabbelt,
	Weiwei Li, Liu Zhiwei, Fabiano Rosas, Laurent Vivier,
	Paolo Bonzini, Tao Tang
  Cc: <a href="../../../qemu-devel/?t=20260128162702">qemu-devel</a>, <a href="../../../qemu-riscv/?t=20260128162702">qemu-riscv</a>, hust-os-kernel-patches

Hi Daniel,

Thanks for the review and the kind words!

On 1/28/2026 10:42 PM, Daniel Henrique Barboza wrote:
<span class="q">&gt;
&gt;
&gt; On 1/28/2026 9:09 AM, Chao Liu wrote:
&gt;&gt; Hi,
&gt;&gt;
&gt;&gt; This patch series adds a bare-metal qtest for the RISC-V IOMMU using the
&gt;&gt; iommu-testdev framework. The test exercises address translation paths
&gt;&gt; without requiring a full guest OS boot.
&gt;&gt;
&gt;&gt; Motivation
&gt;&gt; ----------
&gt;&gt;
&gt;&gt; The existing RISC-V IOMMU qtest (riscv-iommu-test.c) focuses on PCI device
&gt;&gt; enumeration and register-level validation:
&gt;&gt; - PCI configuration space verification (vendor/device ID)
&gt;&gt; - Register reset value checks
&gt;&gt; - Queue initialization procedures (CQ/FQ/PQ)
&gt;&gt;
&gt;&gt; However, it does not test the actual address translation functionality.
&gt;&gt; This new test fills that gap by using iommu-testdev to trigger DMA
&gt;&gt; transactions and validate the IOMMU's translation logic.
&gt;&gt;
&gt;&gt; Comparison with Existing Test
&gt;&gt; -----------------------------
&gt;&gt;
&gt;&gt; | Feature&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | riscv-iommu-test.c | iommu-riscv-test.c (new) |
&gt;&gt; |-----------------------|--------------------|--------------------------|
&gt;&gt; | PCI config&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | No&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
&gt;&gt; | Register reset&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | No&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
&gt;&gt; | Queue init&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Yes (via helper)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
&gt;&gt; | Bare translation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | No&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
&gt;&gt; | S-stage (SV39)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | No&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
&gt;&gt; | G-stage (SV39x4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | No&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
&gt;&gt; | Nested translation&nbsp;&nbsp;&nbsp; | No&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
&gt;&gt; | DMA verification&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | No&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
&gt;&gt; | Uses iommu-testdev&nbsp;&nbsp;&nbsp; | No&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Yes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
&gt;&gt;
&gt;&gt; The new test provides:
&gt;&gt; - Device context (DC) configuration and validation
&gt;&gt; - SV39 page table walks for S-stage translation
&gt;&gt; - SV39x4 page table walks for G-stage translation
&gt;&gt; - Nested translation combining both stages
&gt;&gt; - FCTL register constraint validation
&gt;&gt; - End-to-end DMA verification
&gt;
&gt; I have a customized environment just to test IOMMU stuff (boot an Ubuntu emulated RISC-V host, see if the riscv-iommu works with a PCI net card). And even then this kind of test is limited by the amount of stuff the current Linux driver is capable of doing. And yet I have to at least give it a try with every IOMMU change/fix sent ... This new test will give us additional coverage that neither the existing test nor my manual testing can provide.
&gt;
&gt; Thank you for the time and effort putting into this work. This is really remarkable.
&gt;
</span>I'm glad this patch series can help us better test the RISC-V IOMMU.
The iommu-testdev framework makes it possible to exercise translation
paths directly without booting a full guest OS, which should make
regression testing much faster and more deterministic.
<span class="q">&gt;&gt;
&gt;&gt; Note: The current implementation only supports SV39/SV39x4. Support for
&gt;&gt; SV48/SV48x4/SV57/SV57x4 can be added in future patches.
&gt;&gt;
&gt;&gt; Testing
&gt;&gt; -------
&gt;&gt;
&gt;&gt; QTEST_QEMU_BINARY=./build/qemu-system-riscv64 \n&gt;&gt; &nbsp;&nbsp; ./build/tests/qtest/iommu-riscv-test --tap -k
&gt;&gt;
&gt;&gt; Question for Maintainers
&gt;&gt; ------------------------
&gt;&gt;
&gt;&gt; The existing riscv-iommu-test.c and the new iommu-riscv-test.c serve
&gt;&gt; complementary purposes. Would it be beneficial to merge these two tests
&gt;&gt; into a single source file for easier maintenance? This would consolidate
&gt;&gt; all RISC-V IOMMU testing in one place while preserving both the
&gt;&gt; register-level and translation-level test coverage.
&gt;
&gt; I'll give my non-maintainer opinion because I happen to be the author of riscv-iommu-test.c: as long as we preserve the existing tests for both files I'm ok with it. Maybe there are code re-use opportunities that will be exposed when merging the 2 together.
&gt;
&gt; But I believe this can wait. We should push this upstream first (or at least get it queued into the maintainer's tree).
&gt;
&gt;
</span>I share the same view. That's exactly why I didn't merge them directly
in this series - the two tests serve different purposes (register-level
vs translation-level), and keeping them separate for now makes the
review process cleaner. We can explore merging opportunities later once
this is upstream.

Thanks,
Chao
<span class="q">&gt; Thanks,
&gt; Daniel
&gt;
&gt;&gt;
&gt;&gt; Thanks,
&gt;&gt; Chao
&gt;&gt;
&gt;&gt; Chao Liu (2):
&gt;&gt; &nbsp;&nbsp; tests/qtest/libqos: Add RISC-V IOMMU helper library
&gt;&gt; &nbsp;&nbsp; tests/qtest: Add RISC-V IOMMU bare-metal test
&gt;&gt;
&gt;&gt; &nbsp; MAINTAINERS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; 2 +
&gt;&gt; &nbsp; tests/qtest/iommu-riscv-test.c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 279 +++++++++++++++++++
&gt;&gt; &nbsp; tests/qtest/libqos/meson.build&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; 2 +-
&gt;&gt; &nbsp; tests/qtest/libqos/qos-riscv-iommu.c | 400 +++++++++++++++++++++++++++
&gt;&gt; &nbsp; tests/qtest/libqos/qos-riscv-iommu.h | 172 ++++++++++++
&gt;&gt; &nbsp; tests/qtest/meson.build&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; 5 +-
&gt;&gt; &nbsp; 6 files changed, 858 insertions(+), 2 deletions(-)
&gt;&gt; &nbsp; create mode 100644 tests/qtest/iommu-riscv-test.c
&gt;&gt; &nbsp; create mode 100644 tests/qtest/libqos/qos-riscv-iommu.c
&gt;&gt; &nbsp; create mode 100644 tests/qtest/libqos/qos-riscv-iommu.h
&gt;&gt;
&gt;&gt; -- 
&gt;&gt; 2.52.0
&gt;&gt;
&gt;
</span>

<a href="#md2e478315f3a497a04cf4723c11de56fce9a1c9b" id="ed2e478315f3a497a04cf4723c11de56fce9a1c9b">^</a> <a href="../../4a717b95-e7c7-4a9a-b98f-37df63602a2a@gmail.com/">permalink</a> <a href="../../4a717b95-e7c7-4a9a-b98f-37df63602a2a@gmail.com/raw">raw</a> <a href="../../4a717b95-e7c7-4a9a-b98f-37df63602a2a@gmail.com/#R">reply</a>	[<a href="../../4a717b95-e7c7-4a9a-b98f-37df63602a2a@gmail.com/T/#u"><b>flat</b></a>|<a href="../../4a717b95-e7c7-4a9a-b98f-37df63602a2a@gmail.com/t/#u">nested</a>] <a href="#rd2e478315f3a497a04cf4723c11de56fce9a1c9b">13+ messages in thread</a></pre><hr><pre><a href="#ed2721ada56e836596debf9456a222cba2cf28cb7" id="md2721ada56e836596debf9456a222cba2cf28cb7">*</a> <b>Re: [RFC PATCH v1 1/2] tests/qtest/libqos: Add RISC-V IOMMU helper library</b>
  2026-01-28 12:09 ` <a href="#m9559a467360037b0fb0cd48d1cbad2b91a076885">[RFC PATCH v1 1/2] tests/qtest/libqos: Add RISC-V IOMMU helper library</a> Chao Liu
  2026-01-28 14:30   ` <a href="#mcb58b9919dda00cefe12d0ce47612540c7bdda90">Daniel Henrique Barboza</a>
  2026-01-28 15:23   ` <a href="#m47ec136efcc6562c3cb0be5024eb931e13b96868">Tao Tang</a>
<b>@ 2026-01-29  1:59   ` Tao Tang</b>
  <a href="#rd2721ada56e836596debf9456a222cba2cf28cb7">2 siblings, 0 replies; 13+ messages in thread</a>
From: Tao Tang @ 2026-01-29  1:59 UTC (<a href="../../7377fc98-c2f2-44d9-bb5e-0ea81fe7a369@phytium.com.cn/">permalink</a> / <a href="../../7377fc98-c2f2-44d9-bb5e-0ea81fe7a369@phytium.com.cn/raw">raw</a>)
  To: Chao Liu, Alistair Francis, Daniel Henrique Barboza,
	Palmer Dabbelt, Weiwei Li, Liu Zhiwei, Fabiano Rosas,
	Laurent Vivier, Paolo Bonzini
  Cc: <a href="../../../qemu-devel/?t=20260129020106">qemu-devel</a>, <a href="../../../qemu-riscv/?t=20260129020106">qemu-riscv</a>, hust-os-kernel-patches

Hi Chao,

On 2026/1/28 20:09, Chao Liu wrote:
<span class="q">&gt; Introduce a libqos helper module for RISC-V IOMMU testing with
&gt; iommu-testdev. The helper provides routines to:
&gt;
&gt; - Build device contexts (DC) and 3-level page tables for SV39/SV39x4
&gt; - Program command queue (CQ), fault queue (FQ), and DDTP registers
&gt;    following the RISC-V IOMMU specification
&gt; - Execute DMA translations and verify results
&gt;
&gt; The current implementation supports SV39 for S-stage and SV39x4 for
&gt; G-stage translation. Support for SV48/SV48x4/SV57/SV57x4 can be added
&gt; in future patches.
&gt;
&gt; Signed-off-by: Chao Liu &lt;chao.liu.zevorn@gmail.com&gt;
&gt; ---
&gt;   MAINTAINERS                          |   1 +
&gt;   tests/qtest/libqos/meson.build       |   2 +-
&gt;   tests/qtest/libqos/qos-riscv-iommu.c | 400 +++++++++++++++++++++++++++
&gt;   tests/qtest/libqos/qos-riscv-iommu.h | 172 ++++++++++++
&gt;   4 files changed, 574 insertions(+), 1 deletion(-)
&gt;   create mode 100644 tests/qtest/libqos/qos-riscv-iommu.c
&gt;   create mode 100644 tests/qtest/libqos/qos-riscv-iommu.h
&gt;
&gt; diff --git a/MAINTAINERS b/MAINTAINERS
&gt; index dc31be033e..894e05bd2c 100644
&gt; --- a/MAINTAINERS
&gt; +++ b/MAINTAINERS
&gt; @@ -3583,6 +3583,7 @@ M: Tao Tang &lt;tangtao1634@phytium.com.cn&gt;
&gt;   S: Maintained
&gt;   F: tests/qtest/libqos/qos-iommu*
&gt;   F: tests/qtest/libqos/qos-smmuv3*
&gt; +F: tests/qtest/libqos/qos-riscv-iommu*
&gt;   
&gt;   Device Fuzzing
&gt;   M: Alexander Bulekov &lt;alxndr@bu.edu&gt;
&gt; diff --git a/tests/qtest/libqos/meson.build b/tests/qtest/libqos/meson.build
&gt; index b4daec808f..4a69acad0d 100644
&gt; --- a/tests/qtest/libqos/meson.build
&gt; +++ b/tests/qtest/libqos/meson.build
&gt; @@ -71,7 +71,7 @@ if have_virtfs
&gt;   endif
&gt;   
&gt;   if config_all_devices.has_key('CONFIG_RISCV_IOMMU')
&gt; -  libqos_srcs += files('riscv-iommu.c')
&gt; +  libqos_srcs += files('riscv-iommu.c', 'qos-riscv-iommu.c')
&gt;   endif
&gt;   if config_all_devices.has_key('CONFIG_TPCI200')
&gt;     libqos_srcs += files('tpci200.c')
&gt; diff --git a/tests/qtest/libqos/qos-riscv-iommu.c b/tests/qtest/libqos/qos-riscv-iommu.c
&gt; new file mode 100644
&gt; index 0000000000..34ed3df84a
&gt; --- /dev/null
&gt; +++ b/tests/qtest/libqos/qos-riscv-iommu.c
&gt; @@ -0,0 +1,400 @@
&gt; +/*
&gt; + * QOS RISC-V IOMMU Module
&gt; + *
&gt; + * This module provides RISC-V IOMMU-specific helper functions for libqos tests,
&gt; + * encapsulating RISC-V IOMMU setup, and assertions.
&gt; + *
&gt; + * Copyright (c) 2026 Chao Liu &lt;chao.liu.zevorn@gmail.com&gt;
&gt; + *
&gt; + * SPDX-License-Identifier: GPL-2.0-or-later
&gt; + */
&gt; +
&gt; +#include "qemu/osdep.h"
&gt; +#include "qemu/bitops.h"
&gt; +#include "hw/riscv/riscv-iommu-bits.h"
&gt; +#include "tests/qtest/libqos/pci.h"
&gt; +#include "qos-iommu-testdev.h"
&gt; +#include "qos-riscv-iommu.h"
&gt; +
&gt; +/* Apply space offset to address */
&gt; +static inline uint64_t qriommu_apply_space_offs(uint64_t address)
&gt; +{
&gt; +    return address + QRIOMMU_SPACE_OFFS;
&gt; +}
&gt; +
&gt; +static uint64_t qriommu_encode_pte(uint64_t pa, uint64_t attrs)
&gt; +{
&gt; +    return ((pa &gt;&gt; 12) &lt;&lt; 10) | attrs;
&gt; +}
&gt; +
&gt; +static void qriommu_wait_for_queue_active(QTestState *qts, uint64_t iommu_base,
&gt; +                                          uint32_t queue_csr, uint32_t on_bit)
&gt; +{
&gt; +    guint64 timeout_us = 2 * 1000 * 1000;
&gt; +    gint64 start_time = g_get_monotonic_time();
&gt; +    uint32_t reg;
&gt; +
&gt; +    for (;;) {
&gt; +        qtest_clock_step(qts, 100);
&gt; +
&gt; +        reg = qtest_readl(qts, iommu_base + queue_csr);
&gt; +        if (reg &amp; on_bit) {
&gt; +            return;
&gt; +        }
&gt; +        g_assert(g_get_monotonic_time() - start_time &lt;= timeout_us);
&gt; +    }
&gt; +}
&gt; +
&gt; +uint32_t qriommu_expected_dma_result(QRIOMMUTestContext *ctx)
&gt; +{
&gt; +    return ctx-&gt;config.expected_result;
&gt; +}
&gt; +
&gt; +uint32_t qriommu_build_dma_attrs(void)
&gt; +{
&gt; +    /* RISC-V IOMMU uses standard AXI attributes */
&gt; +    return 0;
&gt; +}
&gt; +
&gt; +uint32_t qriommu_setup_and_enable_translation(QRIOMMUTestContext *ctx)
&gt; +{
&gt; +    uint32_t build_result;
&gt; +
&gt; +    /* Build page tables and RISC-V IOMMU structures first */
&gt; +    build_result = qriommu_build_translation(
&gt; +                       ctx-&gt;qts, ctx-&gt;config.trans_mode,
&gt; +                       ctx-&gt;device_id);
&gt; +    if (build_result != 0) {
&gt; +        g_test_message("Build failed: mode=%u device_id=%u status=0x%x",
&gt; +                       ctx-&gt;config.trans_mode, ctx-&gt;device_id, build_result);
&gt; +        ctx-&gt;trans_status = build_result;
&gt; +        return ctx-&gt;trans_status;
&gt; +    }
&gt; +
&gt; +    /* Program RISC-V IOMMU registers */
&gt; +    qriommu_program_regs(ctx-&gt;qts, ctx-&gt;iommu_base);
&gt; +
&gt; +    ctx-&gt;trans_status = 0;
&gt; +    return ctx-&gt;trans_status;
&gt; +}
&gt; +
&gt; +static bool qriommu_validate_test_result(QRIOMMUTestContext *ctx)
&gt; +{
&gt; +    uint32_t expected = qriommu_expected_dma_result(ctx);
&gt; +    g_test_message("-&gt; Validating result: expected=0x%x actual=0x%x",
&gt; +                   expected, ctx-&gt;dma_result);
&gt; +    return (ctx-&gt;dma_result == expected);
&gt; +}
&gt; +
&gt; +static uint32_t qriommu_single_translation_setup(void *opaque)
&gt; +{
&gt; +    return qriommu_setup_and_enable_translation(opaque);
&gt; +}
&gt; +
&gt; +static uint32_t qriommu_single_translation_attrs(void *opaque)
&gt; +{
&gt; +    return qriommu_build_dma_attrs();
&gt; +}
&gt; +
&gt; +static bool qriommu_single_translation_validate(void *opaque)
&gt; +{
&gt; +    return qriommu_validate_test_result(opaque);
&gt; +}
&gt; +
&gt; +static void qriommu_single_translation_report(void *opaque,
&gt; +                                              uint32_t dma_result)
&gt; +{
&gt; +    QRIOMMUTestContext *ctx = opaque;
&gt; +
&gt; +    if (dma_result != 0) {
&gt; +        g_test_message("DMA failed: mode=%u result=0x%x",
&gt; +                       ctx-&gt;config.trans_mode, dma_result);
&gt; +    } else {
&gt; +        g_test_message("-&gt; DMA succeeded: mode=%u",
&gt; +                       ctx-&gt;config.trans_mode);
&gt; +    }
&gt; +}
&gt; +
&gt; +void qriommu_run_translation_case(QTestState *qts, QPCIDevice *dev,
&gt; +                                  QPCIBar bar, uint64_t iommu_base,
&gt; +                                  const QRIOMMUTestConfig *cfg)
&gt; +{
&gt; +    QRIOMMUTestContext ctx = {
&gt; +        .qts = qts,
&gt; +        .dev = dev,
&gt; +        .bar = bar,
&gt; +        .iommu_base = iommu_base,
&gt; +        .config = *cfg,
&gt; +        .device_id = dev-&gt;devfn,
&gt; +    };
&gt; +
&gt; +    QOSIOMMUTestdevDmaCfg dma = {
&gt; +        .dev = dev,
&gt; +        .bar = bar,
&gt; +        .iova = QRIOMMU_IOVA,
&gt; +        .gpa = ctx.config.dma_gpa,
&gt; +        .len = ctx.config.dma_len,
&gt; +    };
&gt; +
&gt; +    qtest_memset(qts, cfg-&gt;dma_gpa, 0x00, cfg-&gt;dma_len);
&gt; +    qos_iommu_testdev_single_translation(&amp;dma, &amp;ctx,
&gt; +                                         qriommu_single_translation_setup,
&gt; +                                         qriommu_single_translation_attrs,
&gt; +                                         qriommu_single_translation_validate,
&gt; +                                         qriommu_single_translation_report,
&gt; +                                         &amp;ctx.dma_result);
&gt; +
&gt; +    if (ctx.dma_result == 0 &amp;&amp; ctx.config.expected_result == 0) {
&gt; +        g_autofree uint8_t *buf = NULL;
</span>

Declarations should be at the beginning of blocks. See `Declarations` in 
docs/devel/style.rst. And we also had some discussion in another thread. 
As Alex mentioned in the thread below:

<a href="https://lore.kernel.org/qemu-devel/875xb8l4ns.fsf@draig.linaro.org/">https://lore.kernel.org/qemu-devel/875xb8l4ns.fsf@draig.linaro.org/</a>

<span class="q">&gt; +
&gt; +        buf = g_malloc(ctx.config.dma_len);
&gt; +        qtest_memread(ctx.qts, ctx.config.dma_gpa, buf, ctx.config.dma_len);
&gt; +
&gt; +        for (int i = 0; i &lt; ctx.config.dma_len; i++) {
</span>

This is correct. It is explicitly allowed by the special exemption for 
loop variables inside for loops in style.rst.

<span class="q">&gt; +            uint8_t expected;
&gt; +
&gt; +            expected = (ITD_DMA_WRITE_VAL &gt;&gt; ((i % 4) * 8)) &amp; 0xff;
&gt; +            g_assert_cmpuint(buf[i], ==, expected);
&gt; +        }
&gt; +    }
&gt; +}
&gt; +
&gt; +static uint32_t qriommu_get_table_index(uint64_t addr, int level)
&gt; +{
&gt; +    /* SV39: 39-bit virtual address, 3-level page table */
&gt; +    switch (level) {
&gt; +    case 0:
&gt; +        return (addr &gt;&gt; 30) &amp; 0x1ff;   /* L0: bits [38:30] */
&gt; +    case 1:
&gt; +        return (addr &gt;&gt; 21) &amp; 0x1ff;   /* L1: bits [29:21] */
&gt; +    case 2:
&gt; +        return (addr &gt;&gt; 12) &amp; 0x1ff;   /* L2: bits [20:12] */
&gt; +    default:
&gt; +        g_assert_not_reached();
&gt; +    }
&gt; +}
&gt; +
&gt; +static uint64_t qriommu_get_table_addr(uint64_t base, int level, uint64_t iova)
&gt; +{
&gt; +    uint32_t index = qriommu_get_table_index(iova, level);
&gt; +    return (base &amp; QRIOMMU_PTE_PPN_MASK) + (index * 8);
&gt; +}
&gt; +
&gt; +static void qriommu_map_leaf(QTestState *qts, uint64_t root_pa,
&gt; +                             uint64_t l0_pa, uint64_t l1_pa,
&gt; +                             uint64_t l0_pte_val, uint64_t l1_pte_val,
&gt; +                             uint64_t va, uint64_t pa, uint64_t leaf_attrs)
&gt; +{
&gt; +    uint64_t l0_addr = qriommu_get_table_addr(root_pa, 0, va);
&gt; +    uint64_t l1_addr = qriommu_get_table_addr(l0_pa, 1, va);
&gt; +    uint64_t l2_addr = qriommu_get_table_addr(l1_pa, 2, va);
&gt; +
&gt; +    qtest_writeq(qts, l0_addr, l0_pte_val);
&gt; +    qtest_writeq(qts, l1_addr, l1_pte_val);
&gt; +    qtest_writeq(qts, l2_addr, qriommu_encode_pte(pa, leaf_attrs));
&gt; +}
&gt; +
&gt; +static uint64_t qriommu_get_pte_attrs(QRIOMMUTransMode mode, bool is_leaf)
&gt; +{
&gt; +    if (!is_leaf) {
&gt; +        return QRIOMMU_NON_LEAF_PTE_MASK;
&gt; +    }
&gt; +
&gt; +    /* For leaf PTE, set RWX permissions */
&gt; +    return QRIOMMU_LEAF_PTE_RW_MASK;
&gt; +}
&gt; +
&gt; +void qriommu_setup_translation_tables(QTestState *qts,
&gt; +                                      uint64_t iova,
&gt; +                                      QRIOMMUTransMode mode)
&gt; +{
&gt; +    uint64_t s_root = 0, s_l0_pte_val = 0, s_l1_pte_val = 0;
&gt; +    uint64_t s_l0_addr = 0, s_l1_addr = 0, s_l2_addr = 0, s_l2_pte_val = 0;
&gt; +    uint64_t s_l0_pa = 0, s_l1_pa = 0;
&gt; +    uint64_t s_l2_pa = qriommu_apply_space_offs(QRIOMMU_L2_PTE_VAL);
&gt; +    uint64_t s_l0_pa_real = 0, s_l1_pa_real = 0;
&gt; +    uint64_t s_l2_pa_real = qriommu_apply_space_offs(QRIOMMU_L2_PTE_VAL);
&gt; +    uint64_t non_leaf_attrs = qriommu_get_pte_attrs(mode, false);
&gt; +    uint64_t leaf_attrs = qriommu_get_pte_attrs(mode, true);
&gt; +
&gt; +    if (mode != QRIOMMU_TM_G_STAGE_ONLY) {
&gt; +        /* Setup S-stage 3-level page tables (SV39) */
&gt; +        s_l0_pa = qriommu_apply_space_offs(QRIOMMU_L0_PTE_VAL);
&gt; +        s_l1_pa = qriommu_apply_space_offs(QRIOMMU_L1_PTE_VAL);
&gt; +        s_root = qriommu_apply_space_offs(
&gt; +            QRIOMMU_IOHGATP &amp; QRIOMMU_PTE_PPN_MASK);
&gt; +        s_l2_pa = qriommu_apply_space_offs(QRIOMMU_L2_PTE_VAL);
&gt; +
&gt; +        s_l0_pa_real = s_l0_pa;
&gt; +        s_l1_pa_real = s_l1_pa;
&gt; +        s_l2_pa_real = s_l2_pa;
&gt; +
&gt; +        if (mode == QRIOMMU_TM_NESTED) {
&gt; +            s_l0_pa = QRIOMMU_L0_PTE_VAL;
&gt; +            s_l1_pa = QRIOMMU_L1_PTE_VAL;
&gt; +            s_l2_pa = QRIOMMU_L2_PTE_VAL;
&gt; +
&gt; +            s_l0_pa_real = qriommu_apply_space_offs(QRIOMMU_L0_PTE_VAL);
&gt; +            s_l1_pa_real = qriommu_apply_space_offs(QRIOMMU_L1_PTE_VAL);
&gt; +            s_l2_pa_real = qriommu_apply_space_offs(QRIOMMU_L2_PTE_VAL);
&gt; +        }
&gt; +
&gt; +        s_l0_pte_val = qriommu_encode_pte(s_l0_pa, non_leaf_attrs);
&gt; +        s_l1_pte_val = qriommu_encode_pte(s_l1_pa, non_leaf_attrs);
&gt; +
&gt; +        s_l0_addr = qriommu_get_table_addr(s_root, 0, iova);
&gt; +        qtest_writeq(qts, s_l0_addr, s_l0_pte_val);
&gt; +
&gt; +        s_l1_addr = qriommu_get_table_addr(s_l0_pa_real, 1, iova);
&gt; +        qtest_writeq(qts, s_l1_addr, s_l1_pte_val);
&gt; +
&gt; +        s_l2_addr = qriommu_get_table_addr(s_l1_pa_real, 2, iova);
&gt; +        s_l2_pte_val = qriommu_encode_pte(s_l2_pa, leaf_attrs);
&gt; +        qtest_writeq(qts, s_l2_addr, s_l2_pte_val);
&gt; +    }
&gt; +
&gt; +    if (mode == QRIOMMU_TM_G_STAGE_ONLY || mode == QRIOMMU_TM_NESTED) {
&gt; +        uint64_t g_root = qriommu_apply_space_offs(
</span>

Same style issue in this if block.


Thanks,

Tao

<span class="q">&gt; +            QRIOMMU_G_IOHGATP &amp; QRIOMMU_PTE_PPN_MASK);
&gt; +        uint64_t g_l0_pa = qriommu_apply_space_offs(QRIOMMU_G_L0_PTE_VAL);
&gt; +        uint64_t g_l1_pa = qriommu_apply_space_offs(QRIOMMU_G_L1_PTE_VAL);
&gt; +        uint64_t g_l0_pte_val = qriommu_encode_pte(g_l0_pa, non_leaf_attrs);
&gt; +        uint64_t g_l1_pte_val = qriommu_encode_pte(g_l1_pa, non_leaf_attrs);
&gt; +
&gt; +        if (mode == QRIOMMU_TM_G_STAGE_ONLY) {
&gt; +            qriommu_map_leaf(qts, g_root, g_l0_pa, g_l1_pa,
&gt; +                             g_l0_pte_val, g_l1_pte_val,
&gt; +                             iova, s_l2_pa_real, leaf_attrs);
&gt; +        } else {
&gt; +            qriommu_map_leaf(qts, g_root, g_l0_pa, g_l1_pa,
&gt; +                             g_l0_pte_val, g_l1_pte_val,
&gt; +                             QRIOMMU_IOHGATP, s_root, leaf_attrs);
&gt; +            qriommu_map_leaf(qts, g_root, g_l0_pa, g_l1_pa,
&gt; +                             g_l0_pte_val, g_l1_pte_val,
&gt; +                             QRIOMMU_L0_PTE_VAL, s_l0_pa_real, leaf_attrs);
&gt; +            qriommu_map_leaf(qts, g_root, g_l0_pa, g_l1_pa,
&gt; +                             g_l0_pte_val, g_l1_pte_val,
&gt; +                             QRIOMMU_L1_PTE_VAL, s_l1_pa_real, leaf_attrs);
&gt; +            qriommu_map_leaf(qts, g_root, g_l0_pa, g_l1_pa,
&gt; +                             g_l0_pte_val, g_l1_pte_val,
&gt; +                             QRIOMMU_L2_PTE_VAL, s_l2_pa_real, leaf_attrs);
&gt; +        }
&gt; +    }
&gt; +}
</span>


<a href="#md2721ada56e836596debf9456a222cba2cf28cb7" id="ed2721ada56e836596debf9456a222cba2cf28cb7">^</a> <a href="../../7377fc98-c2f2-44d9-bb5e-0ea81fe7a369@phytium.com.cn/">permalink</a> <a href="../../7377fc98-c2f2-44d9-bb5e-0ea81fe7a369@phytium.com.cn/raw">raw</a> <a href="../../7377fc98-c2f2-44d9-bb5e-0ea81fe7a369@phytium.com.cn/#R">reply</a>	[<a href="../../7377fc98-c2f2-44d9-bb5e-0ea81fe7a369@phytium.com.cn/T/#u"><b>flat</b></a>|<a href="../../7377fc98-c2f2-44d9-bb5e-0ea81fe7a369@phytium.com.cn/t/#u">nested</a>] <a href="#rd2721ada56e836596debf9456a222cba2cf28cb7">13+ messages in thread</a></pre><hr><pre>end of thread, other threads:[<a href="../../?t=20260129020106">~2026-01-29  2:01 UTC</a> | <a href="../../">newest</a>]

<b id="t">Thread overview:</b> 13+ messages (download: <a href="../t.mbox.gz">mbox.gz</a> follow: <a href="../t.atom">Atom feed</a>
-- links below jump to the message on this page --
2026-01-28 12:09 <a href="#m73ac81ff33885a502d30d54b8cea4dcbaa767349" id="r73ac81ff33885a502d30d54b8cea4dcbaa767349">[RFC PATCH v1 0/2] tests/qtest: Add RISC-V IOMMU bare-metal test using iommu-testdev</a> Chao Liu
2026-01-28 12:09 ` <a href="#m9559a467360037b0fb0cd48d1cbad2b91a076885" id="r9559a467360037b0fb0cd48d1cbad2b91a076885">[RFC PATCH v1 1/2] tests/qtest/libqos: Add RISC-V IOMMU helper library</a> Chao Liu
2026-01-28 14:30   ` <a href="#mcb58b9919dda00cefe12d0ce47612540c7bdda90" id="rcb58b9919dda00cefe12d0ce47612540c7bdda90">Daniel Henrique Barboza</a>
2026-01-28 15:23   ` <a href="#m47ec136efcc6562c3cb0be5024eb931e13b96868" id="r47ec136efcc6562c3cb0be5024eb931e13b96868">Tao Tang</a>
2026-01-28 15:45     ` <a href="#md4ab43b6667cfd798638f36984d5dfce06909dc3" id="rd4ab43b6667cfd798638f36984d5dfce06909dc3">Chao Liu</a>
2026-01-29  1:59   ` <a href="#md2721ada56e836596debf9456a222cba2cf28cb7" id="rd2721ada56e836596debf9456a222cba2cf28cb7">Tao Tang</a>
2026-01-28 12:09 ` <a href="#m351dceb4c1fd03d15423922990cc16cc7f3f55d9" id="r351dceb4c1fd03d15423922990cc16cc7f3f55d9">[RFC PATCH v1 2/2] tests/qtest: Add RISC-V IOMMU bare-metal test</a> Chao Liu
2026-01-28 14:30   ` <a href="#m225bb7c105a86bd5763acc6b70063b62327f191d" id="r225bb7c105a86bd5763acc6b70063b62327f191d">Daniel Henrique Barboza</a>
2026-01-28 15:36   ` <a href="#med032f1adb576354a7b019f27ef1f7f96608a772" id="red032f1adb576354a7b019f27ef1f7f96608a772">Tao Tang</a>
2026-01-28 16:17     ` <a href="#m3092fd884052bbb4a29074f98ad96f50e0a66bfa" id="r3092fd884052bbb4a29074f98ad96f50e0a66bfa">Chao Liu</a>
2026-01-28 14:42 ` <a href="#m3469b37b570b142238cad69d7b5d435673adf0f8" id="r3469b37b570b142238cad69d7b5d435673adf0f8">[RFC PATCH v1 0/2] tests/qtest: Add RISC-V IOMMU bare-metal test using iommu-testdev</a> Daniel Henrique Barboza
2026-01-28 16:25   ` <a href="#md2e478315f3a497a04cf4723c11de56fce9a1c9b" id="rd2e478315f3a497a04cf4723c11de56fce9a1c9b">Chao Liu</a>
2026-01-28 14:54 ` <a href="#m24f461ed1166131dbfd5c478e2d918856776bc5d" id="r24f461ed1166131dbfd5c478e2d918856776bc5d">Tao Tang</a>
</pre><hr><pre>This is a public inbox, see <a href="../../_/text/mirror/">mirroring instructions</a>
for how to clone and mirror all data and code used for this inbox;
as well as URLs for NNTP newsgroup(s).</pre></body><div style="all: initial;"><div style="all: initial;" id="__hcfy__"></div></div><div id="immersive-translate-popup" style="all: initial"></div></html>