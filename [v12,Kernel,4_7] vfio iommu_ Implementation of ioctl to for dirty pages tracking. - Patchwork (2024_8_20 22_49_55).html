<!DOCTYPE html> <html xmlns=http://www.w3.org/1999/xhtml lang=en style><!--
 Page saved with SingleFile 
 url: https://patchwork.kernel.org/project/qemu-devel/patch/1581104554-10704-5-git-send-email-kwankhede@nvidia.com/ 
 saved date: Tue Aug 20 2024 22:49:55 GMT+0800 (中国标准时间)
--><meta charset=utf-8>
<title>[v12,Kernel,4/7] vfio iommu: Implementation of ioctl to for dirty pages tracking. - Patchwork</title>
<style>/*!
 * Bootstrap v3.2.0 (http://getbootstrap.com)
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 *//*! normalize.css v3.0.1 | MIT License | git.io/normalize */html{font-family:sans-serif;-webkit-text-size-adjust:100%;-ms-text-size-adjust:100%}body{margin:0}nav{display:block}template{display:none}a{background:0 0}a:active,a:hover{outline:0}h1{margin:.67em 0}svg:not(:root){overflow:hidden}pre{overflow:auto}button{margin:0;font:inherit;color:inherit}button{overflow:visible}button{text-transform:none}button{-webkit-appearance:button;cursor:pointer}button[disabled]{cursor:default}button::-moz-focus-inner,input::-moz-focus-inner{padding:0;border:0}table{border-spacing:0}@font-face{font-family:"Glyphicons Halflings";src:url(data:font/woff;base64,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)format("woff")}.glyphicon{position:relative;top:1px;display:inline-block;font-family:"Glyphicons Halflings";font-style:normal;font-weight:400;line-height:1;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.glyphicon-file:before{content:""}.glyphicon-info-sign:before{content:""}.glyphicon-gift:before{content:""}*{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}:before,:after{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}html{font-size:10px;-webkit-tap-highlight-color:rgba(0,0,0,0)}body{font-family:"Helvetica Neue",Helvetica,Arial,sans-serif;font-size:14px;line-height:1.42857143;color:#333;background-color:#fff}button{font-family:inherit;font-size:inherit;line-height:inherit}a{color:#428bca;text-decoration:none}a:hover,a:focus{color:#2a6496;text-decoration:underline}a:focus{outline:thin dotted;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}h1,h2{font-family:inherit;font-weight:500;line-height:1.1;color:inherit}h1,h2{margin-top:20px;margin-bottom:10px}h1{font-size:36px}p{margin:0 0 10px}@media (min-width:768px){}ul{margin-top:0}@media (min-width:768px){}pre{font-family:Menlo,Monaco,Consolas,"Courier New",monospace}pre{display:block;padding:9.5px;margin:0 0 10px;font-size:13px;color:#333;word-break:break-all;word-wrap:break-word;border:1px solid #ccc}@media (min-width:768px){}@media (min-width:992px){}@media (min-width:1200px){}.container-fluid{padding-right:15px;padding-left:15px;margin-right:auto;margin-left:auto}@media (min-width:768px){}@media (min-width:992px){}@media (min-width:1200px){}table{background-color:transparent}@media screen and (max-width:767px){}@media (min-width:768px){}@media (min-width:768px){}@media (min-width:768px){}@media (min-width:768px){}.btn{display:inline-block;padding:6px 12px;margin-bottom:0;font-size:14px;font-weight:400;line-height:1.42857143;text-align:center;white-space:nowrap;vertical-align:middle;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;background-image:none;border:1px solid transparent;border-radius:4px}.btn:focus,.btn:active:focus,.btn.active:focus{outline:thin dotted;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}.btn:hover,.btn:focus{color:#333;text-decoration:none}.btn:active,.btn.active{background-image:none;outline:0;-webkit-box-shadow:inset 0 3px 5px rgba(0,0,0,.125);box-shadow:inset 0 3px 5px rgba(0,0,0,.125)}.btn-default{color:#333;background-color:#fff;border-color:#ccc}.btn-default:hover,.btn-default:focus,.btn-default:active,.btn-default.active,.open>.dropdown-toggle.btn-default{color:#333;background-color:#e6e6e6;border-color:#adadad}.btn-default:active,.btn-default.active,.open>.dropdown-toggle.btn-default{background-image:none}.collapse{display:none}@media (min-width:768px){}.btn-group{position:relative;display:inline-block;vertical-align:middle}.btn-group>.btn{position:relative;float:left}.btn-group>.btn:hover,.btn-group-vertical>.btn:hover,.btn-group>.btn:focus,.btn-group-vertical>.btn:focus,.btn-group>.btn:active,.btn-group-vertical>.btn:active,.btn-group>.btn.active,.btn-group-vertical>.btn.active{z-index:2}.btn-group>.btn:focus,.btn-group-vertical>.btn:focus{outline:0}.btn-group .btn+.btn{margin-left:-1px}.btn-group>.btn:not(:first-child):not(:last-child):not(.dropdown-toggle){border-radius:0}.btn-group>.btn:first-child{margin-left:0}.btn-group>.btn:first-child:not(:last-child):not(.dropdown-toggle){border-top-right-radius:0;border-bottom-right-radius:0}.btn-group>.btn:last-child:not(:first-child),.btn-group>.dropdown-toggle:not(:first-child){border-top-left-radius:0;border-bottom-left-radius:0}.nav{padding-left:0;margin-bottom:0;list-style:none}.nav>li{position:relative;display:block}.nav>li>a{position:relative;display:block;padding:10px 15px}.nav>li>a:hover,.nav>li>a:focus{text-decoration:none;background-color:#eee}@media (min-width:768px){}@media (min-width:768px){}@media (min-width:768px){}@media (min-width:768px){}.navbar{position:relative;min-height:50px;margin-bottom:20px;border:1px solid transparent}@media (min-width:768px){.navbar{border-radius:4px}}@media (min-width:768px){.navbar-header{float:left}}.navbar-collapse{padding-right:15px;padding-left:15px;overflow-x:visible;-webkit-overflow-scrolling:touch;border-top:1px solid transparent;-webkit-box-shadow:inset 0 1px 0 rgba(255,255,255,.1);box-shadow:inset 0 1px 0 rgba(255,255,255,.1)}@media (min-width:768px){.navbar-collapse{width:auto;border-top:0;-webkit-box-shadow:none;box-shadow:none}.navbar-collapse.collapse{display:block!important;height:auto!important;padding-bottom:0;overflow:visible!important}.navbar-static-top .navbar-collapse{padding-right:0;padding-left:0}}@media (max-width:480px) and (orientation:landscape){}.container-fluid>.navbar-header,.container-fluid>.navbar-collapse{margin-right:-15px;margin-left:-15px}@media (min-width:768px){.container-fluid>.navbar-header,.container-fluid>.navbar-collapse{margin-right:0;margin-left:0}}.navbar-static-top{z-index:1000;border-width:0 0 1px}@media (min-width:768px){.navbar-static-top{border-radius:0}}@media (min-width:768px){}.navbar-brand{float:left;height:50px;padding:15px 15px;font-size:18px;line-height:20px}.navbar-brand:hover,.navbar-brand:focus{text-decoration:none}@media (min-width:768px){.navbar>.container-fluid .navbar-brand{margin-left:-15px}}@media (min-width:768px){}.navbar-nav{margin:7.5px -15px}.navbar-nav>li>a{padding-top:10px;padding-bottom:10px;line-height:20px}@media (max-width:767px){}@media (min-width:768px){.navbar-nav{float:left;margin:0}.navbar-nav>li{float:left}.navbar-nav>li>a{padding-top:15px;padding-bottom:15px}.navbar-nav.navbar-right:last-child{margin-right:-15px}}@media (min-width:768px){.navbar-right{float:right!important}}@media (min-width:768px){}@media (max-width:767px){}@media (min-width:768px){}@media (min-width:768px){}@media (max-width:767px){}.navbar-inverse{background-color:#222;border-color:#080808}.navbar-inverse .navbar-brand{color:#777}.navbar-inverse .navbar-brand:hover,.navbar-inverse .navbar-brand:focus{color:#fff;background-color:transparent}.navbar-inverse .navbar-nav>li>a:hover,.navbar-inverse .navbar-nav>li>a:focus{color:#fff;background-color:transparent}.navbar-inverse .navbar-collapse{border-color:#101010}@media (max-width:767px){}@media screen and (min-width:768px){}@-webkit-keyframes progress-bar-stripes{from{background-position:40px 0}to{background-position:0 0}}@-o-keyframes progress-bar-stripes{from{background-position:40px 0}to{background-position:0 0}}@keyframes progress-bar-stripes{from{background-position:40px 0}to{background-position:0 0}}@media (min-width:768px){}@media (min-width:992px){}@media screen and (min-width:768px){}.clearfix:before,.clearfix:after,.dl-horizontal dd:before,.dl-horizontal dd:after,.container:before,.container:after,.container-fluid:before,.container-fluid:after,.row:before,.row:after,.form-horizontal .form-group:before,.form-horizontal .form-group:after,.btn-toolbar:before,.btn-toolbar:after,.btn-group-vertical>.btn-group:before,.btn-group-vertical>.btn-group:after,.nav:before,.nav:after,.navbar:before,.navbar:after,.navbar-header:before,.navbar-header:after,.navbar-collapse:before,.navbar-collapse:after,.pager:before,.pager:after,.panel-body:before,.panel-body:after,.modal-footer:before,.modal-footer:after{display:table;content:" "}.clearfix:after,.dl-horizontal dd:after,.container:after,.container-fluid:after,.row:after,.form-horizontal .form-group:after,.btn-toolbar:after,.btn-group-vertical>.btn-group:after,.nav:after,.navbar:after,.navbar-header:after,.navbar-collapse:after,.pager:after,.panel-body:after,.modal-footer:after{clear:both}.pull-right{float:right!important}@-ms-viewport{width:device-width}@media (max-width:767px){}@media (max-width:767px){}@media (max-width:767px){}@media (max-width:767px){}@media (min-width:768px) and (max-width:991px){}@media (min-width:768px) and (max-width:991px){}@media (min-width:768px) and (max-width:991px){}@media (min-width:768px) and (max-width:991px){}@media (min-width:992px) and (max-width:1199px){}@media (min-width:992px) and (max-width:1199px){}@media (min-width:992px) and (max-width:1199px){}@media (min-width:992px) and (max-width:1199px){}@media (min-width:1200px){}@media (min-width:1200px){}@media (min-width:1200px){}@media (min-width:1200px){}@media (max-width:767px){}@media (min-width:768px) and (max-width:991px){}@media (min-width:992px) and (max-width:1199px){}@media (min-width:1200px){}</style>
<style>h2{font-size:25px;margin:18px 0 18px 0}pre{line-height:110%;background-color:white;border-radius:0}.navbar-inverse .navbar-nav>li>a{color:#999}.navbar-subbrand{float:left;height:50px;padding:15px 15px 15px 0;font-size:18px;line-height:20px}.navbar-subbrand{color:#999}table{border-collapse:collapse}#footer{padding:1em;font-size:small;text-align:center;color:#909090}#footer a{color:#909090}div.patchforms{margin-top:1em}table.patchmeta tr th,table.patchmeta tr td{text-align:left;padding:1px 10px;vertical-align:top}.comment .meta{background:#f0f0f0;padding:0.3em 0.5em}.comment .content{border:0}.patch .content{padding:1em}.quote{color:#007f00}span.p_header{color:#2e8b57;font-weight:bold}span.p_chunk{color:#a52a2a;font-weight:bold}span.p_context{color:#a020f0}span.p_add{color:#008b8b}span.p_del{color:#6a5acd}.signed-off-by{color:#672d45;font-weight:bold}</style>
<!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js">
    </script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/es5-shim/2.0.8/es5-shim.min.js"></script>
  <![endif]-->
<meta name=referrer content=no-referrer><style>.sf-hidden{display:none!important}</style><link rel=canonical href=https://patchwork.kernel.org/project/qemu-devel/patch/1581104554-10704-5-git-send-email-kwankhede@nvidia.com/><meta http-equiv=content-security-policy content="default-src 'none'; font-src 'self' data:; img-src 'self' data:; style-src 'unsafe-inline'; media-src 'self' data:; script-src 'unsafe-inline' data:; object-src 'self' data:; frame-src 'self' data:;"><style>img[src="data:,"],source[src="data:,"]{display:none!important}</style></head>
 <body>
 <nav class="navbar navbar-inverse navbar-static-top">
 <div class=container-fluid>
 <div class=navbar-header>
 <button type=button class="navbar-toggle collapsed sf-hidden" data-toggle=collapse data-target=#navbar-collapse>
 
 
 
 
 </button>
 <a class=navbar-brand href=https://patchwork.kernel.org/>Patchwork</a>
 <span class=navbar-subbrand>
 QEMU patches
 </span>
 </div>
 <div class="collapse navbar-collapse" id=navbar-collapse>
 <ul class="nav navbar-nav">
 <li>
 <a href=https://patchwork.kernel.org/project/qemu-devel/list/>
 <span class="glyphicon glyphicon-file"></span>
 Patches
 </a>
 </li>
 <li>
 <a href=https://patchwork.kernel.org/project/qemu-devel/bundles/>
 <span class="glyphicon glyphicon-gift"></span>
 Bundles
 </a>
 </li>
 <li>
 <a href=https://patchwork.kernel.org/project/qemu-devel/>
 <span class="glyphicon glyphicon-info-sign"></span>
 About this project
 </a>
 </li>
 </ul>
 <ul class="nav navbar-nav navbar-right">
 <li><a href=https://patchwork.kernel.org/user/login/>Login</a></li>
 <li><a href=https://patchwork.kernel.org/register/>Register</a></li>
 <li><a href=https://patchwork.kernel.org/mail/>Mail settings</a></li>
 </ul>
 </div>
 </div>
 </nav>
 <div class=container-fluid>
<div>
 <div class="btn-group pull-right">
 <button type=button class="btn btn-default btn-copy" data-clipboard-text=11371205 title="Copy to Clipboard">
 11371205
 </button>
 
 <a href=https://patchwork.kernel.org/project/qemu-devel/patch/1581104554-10704-5-git-send-email-kwankhede@nvidia.com/raw/ class="btn btn-default" role=button title="Download patch diff">diff</a>
 <a href=https://patchwork.kernel.org/project/qemu-devel/patch/1581104554-10704-5-git-send-email-kwankhede@nvidia.com/mbox/ class="btn btn-default" role=button title="Download patch mbox">mbox</a>
 
 
 <a href=https://patchwork.kernel.org/series/238547/mbox/ class="btn btn-default" role=button title="Download patch mbox with dependencies">series</a>
 
</div>
 <h1>[v12,Kernel,4/7] vfio iommu: Implementation of ioctl to for dirty pages tracking.</h1>
</div>
<table class=patchmeta>
 <tbody><tr>
 <th>Message ID</th>
 
 <td>1581104554-10704-5-git-send-email-kwankhede@nvidia.com (<a href=https://lore.kernel.org/r/1581104554-10704-5-git-send-email-kwankhede@nvidia.com>mailing list archive</a>)</td>
 
 </tr>
 <tr>
 <th>State</th>
 <td>New, archived</td>
 </tr>
 <tr>
 <th>Headers</th>
 <td><a id=togglepatchheaders href=javascript:void(0)>show</a>
 <div id=patchheaders class=patchheaders style=display:none>
 
 </div>
 </td>
 </tr>
 <tr>
 <th>Series</th>
 <td>
 <a href="https://patchwork.kernel.org/project/qemu-devel/list/?series=238547">
 KABIs to support migration for VFIO devices
 </a> |
 <a id=togglepatchseries href=javascript:void(0)>expand</a>
 <div id=patchseries class=submissionlist style=display:none>
 
 </div>
 </td>
 </tr>
</table>
<div class=patchforms>
 <div style=clear:both>
 </div>
</div>
<h2>Commit Message</h2>
<div class=comment>
<div class=meta>
 <span><a href="https://patchwork.kernel.org/project/qemu-devel/list/?submitter=153211">Kirti Wankhede</a></span>
 <span class=pull-right>Feb. 7, 2020, 7:42 p.m. UTC</span>
</div>
<pre class=content>VFIO_IOMMU_DIRTY_PAGES ioctl performs three operations:
- Start pinned and unpinned pages tracking while migration is active
- Stop pinned and unpinned dirty pages tracking. This is also used to
  stop dirty pages tracking if migration failed or cancelled.
- Get dirty pages bitmap. This ioctl returns bitmap of dirty pages, its
  user space application responsibility to copy content of dirty pages
  from source to destination during migration.

To prevent DoS attack, memory for bitmap is allocated per vfio_dma
structure. Bitmap size is calculated considering smallest supported page
size. Bitmap is allocated when dirty logging is enabled for those
vfio_dmas whose vpfn list is not empty or whole range is mapped, in
case of pass-through device.

There could be multiple option as to when bitmap should be populated:
* Polulate bitmap for already pinned pages when bitmap is allocated for
  a vfio_dma with the smallest supported page size. Updates bitmap from
  page pinning and unpinning functions. When user application queries
  bitmap, check if requested page size is same as page size used to
  populated bitmap. If it is equal, copy bitmap. But if not equal,
  re-populated bitmap according to requested page size and then copy to
  user.
  Pros: Bitmap gets populated on the fly after dirty tracking has
        started.
  Cons: If requested page size is different than smallest supported
        page size, then bitmap has to be re-populated again, with
        additional overhead of allocating bitmap memory again for
        re-population of bitmap.

* Populate bitmap when bitmap is queried by user application.
  Pros: Bitmap is populated with requested page size. This eliminates
        the need to re-populate bitmap if requested page size is
        different than smallest supported pages size.
  Cons: There is one time processing time, when bitmap is queried.

I prefer later option with simple logic and to eliminate over-head of
bitmap repopulation in case of differnt page sizes. Later option is
implemented in this patch.
<span class=signed-off-by>
Signed-off-by: Kirti Wankhede &lt;kwankhede@nvidia.com&gt;</span>
<span class=reviewed-by>Reviewed-by: Neo Jia &lt;cjia@nvidia.com&gt;</span>
---
 drivers/vfio/vfio_iommu_type1.c | 299 ++++++++++++++++++++++++++++++++++++++--
 1 file changed, 287 insertions(+), 12 deletions(-)
</pre>
</div>
<h2>Comments</h2>
<a name=23145975></a>
<div class=comment>
<div class=meta>
 <span><a href="https://patchwork.kernel.org/project/qemu-devel/list/?submitter=182909">Yan Zhao</a></span>
 <span class=pull-right>Feb. 10, 2020, 9:49 a.m. UTC | <a href=https://patchwork.kernel.org/comment/23145975/>#1</a></span>
</div>
<pre class=content>On Sat, Feb 08, 2020 at 03:42:31AM +0800, Kirti Wankhede wrote:
<span class=quote>&gt; VFIO_IOMMU_DIRTY_PAGES ioctl performs three operations:</span>
<span class=quote>&gt; - Start pinned and unpinned pages tracking while migration is active</span>
<span class=quote>&gt; - Stop pinned and unpinned dirty pages tracking. This is also used to</span>
<span class=quote>&gt;   stop dirty pages tracking if migration failed or cancelled.</span>
<span class=quote>&gt; - Get dirty pages bitmap. This ioctl returns bitmap of dirty pages, its</span>
<span class=quote>&gt;   user space application responsibility to copy content of dirty pages</span>
<span class=quote>&gt;   from source to destination during migration.</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; To prevent DoS attack, memory for bitmap is allocated per vfio_dma</span>
<span class=quote>&gt; structure. Bitmap size is calculated considering smallest supported page</span>
<span class=quote>&gt; size. Bitmap is allocated when dirty logging is enabled for those</span>
<span class=quote>&gt; vfio_dmas whose vpfn list is not empty or whole range is mapped, in</span>
<span class=quote>&gt; case of pass-through device.</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; There could be multiple option as to when bitmap should be populated:</span>
<span class=quote>&gt; * Polulate bitmap for already pinned pages when bitmap is allocated for</span>
<span class=quote>&gt;   a vfio_dma with the smallest supported page size. Updates bitmap from</span>
<span class=quote>&gt;   page pinning and unpinning functions. When user application queries</span>
<span class=quote>&gt;   bitmap, check if requested page size is same as page size used to</span>
<span class=quote>&gt;   populated bitmap. If it is equal, copy bitmap. But if not equal,</span>
<span class=quote>&gt;   re-populated bitmap according to requested page size and then copy to</span>
<span class=quote>&gt;   user.</span>
<span class=quote>&gt;   Pros: Bitmap gets populated on the fly after dirty tracking has</span>
<span class=quote>&gt;         started.</span>
<span class=quote>&gt;   Cons: If requested page size is different than smallest supported</span>
<span class=quote>&gt;         page size, then bitmap has to be re-populated again, with</span>
<span class=quote>&gt;         additional overhead of allocating bitmap memory again for</span>
<span class=quote>&gt;         re-population of bitmap.</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; * Populate bitmap when bitmap is queried by user application.</span>
<span class=quote>&gt;   Pros: Bitmap is populated with requested page size. This eliminates</span>
<span class=quote>&gt;         the need to re-populate bitmap if requested page size is</span>
<span class=quote>&gt;         different than smallest supported pages size.</span>
<span class=quote>&gt;   Cons: There is one time processing time, when bitmap is queried.</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; I prefer later option with simple logic and to eliminate over-head of</span>
<span class=quote>&gt; bitmap repopulation in case of differnt page sizes. Later option is</span>
<span class=quote>&gt; implemented in this patch.</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; Signed-off-by: Kirti Wankhede &lt;kwankhede@nvidia.com&gt;</span>
<span class=quote>&gt; Reviewed-by: Neo Jia &lt;cjia@nvidia.com&gt;</span>
<span class=quote>&gt; ---</span>
<span class=quote>&gt;  drivers/vfio/vfio_iommu_type1.c | 299 ++++++++++++++++++++++++++++++++++++++--</span>
<span class=quote>&gt;  1 file changed, 287 insertions(+), 12 deletions(-)</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; diff --git a/drivers/vfio/vfio_iommu_type1.c b/drivers/vfio/vfio_iommu_type1.c</span>
<span class=quote>&gt; index d386461e5d11..df358dc1c85b 100644</span>
<span class=quote>&gt; --- a/drivers/vfio/vfio_iommu_type1.c</span>
<span class=quote>&gt; +++ b/drivers/vfio/vfio_iommu_type1.c</span>
<span class=quote>&gt; @@ -70,6 +70,7 @@ struct vfio_iommu {</span>
<span class=quote>&gt;  	unsigned int		dma_avail;</span>
<span class=quote>&gt;  	bool			v2;</span>
<span class=quote>&gt;  	bool			nesting;</span>
<span class=quote>&gt; +	bool			dirty_page_tracking;</span>
<span class=quote>&gt;  };</span>
<span class=quote>&gt;  </span>
<span class=quote>&gt;  struct vfio_domain {</span>
<span class=quote>&gt; @@ -90,6 +91,7 @@ struct vfio_dma {</span>
<span class=quote>&gt;  	bool			lock_cap;	/* capable(CAP_IPC_LOCK) */</span>
<span class=quote>&gt;  	struct task_struct	*task;</span>
<span class=quote>&gt;  	struct rb_root		pfn_list;	/* Ex-user pinned pfn list */</span>
<span class=quote>&gt; +	unsigned long		*bitmap;</span>
<span class=quote>&gt;  };</span>
<span class=quote>&gt;  </span>
<span class=quote>&gt;  struct vfio_group {</span>
<span class=quote>&gt; @@ -125,6 +127,7 @@ struct vfio_regions {</span>
<span class=quote>&gt;  					(!list_empty(&amp;iommu-&gt;domain_list))</span>
<span class=quote>&gt;  </span>
<span class=quote>&gt;  static int put_pfn(unsigned long pfn, int prot);</span>
<span class=quote>&gt; +static unsigned long vfio_pgsize_bitmap(struct vfio_iommu *iommu);</span>
<span class=quote>&gt;  </span>
<span class=quote>&gt;  /*</span>
<span class=quote>&gt;   * This code handles mapping and unmapping of user data buffers</span>
<span class=quote>&gt; @@ -174,6 +177,57 @@ static void vfio_unlink_dma(struct vfio_iommu *iommu, struct vfio_dma *old)</span>
<span class=quote>&gt;  	rb_erase(&amp;old-&gt;node, &amp;iommu-&gt;dma_list);</span>
<span class=quote>&gt;  }</span>
<span class=quote>&gt;  </span>
<span class=quote>&gt; +static inline unsigned long dirty_bitmap_bytes(unsigned int npages)</span>
<span class=quote>&gt; +{</span>
<span class=quote>&gt; +	if (!npages)</span>
<span class=quote>&gt; +		return 0;</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +	return ALIGN(npages, BITS_PER_LONG) / sizeof(unsigned long);</span>
<span class=quote>&gt; +}</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +static int vfio_dma_bitmap_alloc(struct vfio_iommu *iommu,</span>
<span class=quote>&gt; +				 struct vfio_dma *dma, unsigned long pgsizes)</span>
<span class=quote>&gt; +{</span>
<span class=quote>&gt; +	unsigned long pgshift = __ffs(pgsizes);</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +	if (!RB_EMPTY_ROOT(&amp;dma-&gt;pfn_list) || dma-&gt;iommu_mapped) {</span>
<span class=quote>&gt; +		unsigned long npages = dma-&gt;size &gt;&gt; pgshift;</span>
<span class=quote>&gt; +		unsigned long bsize = dirty_bitmap_bytes(npages);</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +		dma-&gt;bitmap = kvzalloc(bsize, GFP_KERNEL);</span>
<span class=quote>&gt; +		if (!dma-&gt;bitmap)</span>
<span class=quote>&gt; +			return -ENOMEM;</span>
<span class=quote>&gt; +	}</span>
<span class=quote>&gt; +	return 0;</span>
<span class=quote>&gt; +}</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +static int vfio_dma_all_bitmap_alloc(struct vfio_iommu *iommu,</span>
<span class=quote>&gt; +				     unsigned long pgsizes)</span>
<span class=quote>&gt; +{</span>
<span class=quote>&gt; +	struct rb_node *n = rb_first(&amp;iommu-&gt;dma_list);</span>
<span class=quote>&gt; +	int ret;</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +	for (; n; n = rb_next(n)) {</span>
<span class=quote>&gt; +		struct vfio_dma *dma = rb_entry(n, struct vfio_dma, node);</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +		ret = vfio_dma_bitmap_alloc(iommu, dma, pgsizes);</span>
<span class=quote>&gt; +		if (ret)</span>
<span class=quote>&gt; +			return ret;</span>
<span class=quote>&gt; +	}</span>
<span class=quote>&gt; +	return 0;</span>
<span class=quote>&gt; +}</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +static void vfio_dma_all_bitmap_free(struct vfio_iommu *iommu)</span>
<span class=quote>&gt; +{</span>
<span class=quote>&gt; +	struct rb_node *n = rb_first(&amp;iommu-&gt;dma_list);</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +	for (; n; n = rb_next(n)) {</span>
<span class=quote>&gt; +		struct vfio_dma *dma = rb_entry(n, struct vfio_dma, node);</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +		kfree(dma-&gt;bitmap);</span>
<span class=quote>&gt; +	}</span>
<span class=quote>&gt; +}</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt;  /*</span>
<span class=quote>&gt;   * Helper Functions for host iova-pfn list</span>
<span class=quote>&gt;   */</span>
<span class=quote>&gt; @@ -244,6 +298,29 @@ static void vfio_remove_from_pfn_list(struct vfio_dma *dma,</span>
<span class=quote>&gt;  	kfree(vpfn);</span>
<span class=quote>&gt;  }</span>
<span class=quote>&gt;  </span>
<span class=quote>&gt; +static void vfio_remove_unpinned_from_pfn_list(struct vfio_dma *dma)</span>
<span class=quote>&gt; +{</span>
<span class=quote>&gt; +	struct rb_node *n = rb_first(&amp;dma-&gt;pfn_list);</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +	for (; n; n = rb_next(n)) {</span>
<span class=quote>&gt; +		struct vfio_pfn *vpfn = rb_entry(n, struct vfio_pfn, node);</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +		if (!vpfn-&gt;ref_count)</span>
<span class=quote>&gt; +			vfio_remove_from_pfn_list(dma, vpfn);</span>
<span class=quote>&gt; +	}</span>
<span class=quote>&gt; +}</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +static void vfio_remove_unpinned_from_dma_list(struct vfio_iommu *iommu)</span>
<span class=quote>&gt; +{</span>
<span class=quote>&gt; +	struct rb_node *n = rb_first(&amp;iommu-&gt;dma_list);</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +	for (; n; n = rb_next(n)) {</span>
<span class=quote>&gt; +		struct vfio_dma *dma = rb_entry(n, struct vfio_dma, node);</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +		vfio_remove_unpinned_from_pfn_list(dma);</span>
<span class=quote>&gt; +	}</span>
<span class=quote>&gt; +}</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt;  static struct vfio_pfn *vfio_iova_get_vfio_pfn(struct vfio_dma *dma,</span>
<span class=quote>&gt;  					       unsigned long iova)</span>
<span class=quote>&gt;  {</span>
<span class=quote>&gt; @@ -261,7 +338,8 @@ static int vfio_iova_put_vfio_pfn(struct vfio_dma *dma, struct vfio_pfn *vpfn)</span>
<span class=quote>&gt;  	vpfn-&gt;ref_count--;</span>
<span class=quote>&gt;  	if (!vpfn-&gt;ref_count) {</span>
<span class=quote>&gt;  		ret = put_pfn(vpfn-&gt;pfn, dma-&gt;prot);</span>
<span class=quote>&gt; -		vfio_remove_from_pfn_list(dma, vpfn);</span>
<span class=quote>&gt; +		if (!dma-&gt;bitmap)</span>
<span class=quote>&gt; +			vfio_remove_from_pfn_list(dma, vpfn);</span>
<span class=quote>&gt;  	}</span>
<span class=quote>&gt;  	return ret;</span>
<span class=quote>&gt;  }</span>
<span class=quote>&gt; @@ -483,13 +561,14 @@ static int vfio_pin_page_external(struct vfio_dma *dma, unsigned long vaddr,</span>
<span class=quote>&gt;  	return ret;</span>
<span class=quote>&gt;  }</span>
<span class=quote>&gt;  </span>
<span class=quote>&gt; -static int vfio_unpin_page_external(struct vfio_dma *dma, dma_addr_t iova,</span>
<span class=quote>&gt; +static int vfio_unpin_page_external(struct vfio_iommu *iommu,</span>
<span class=quote>&gt; +				    struct vfio_dma *dma, dma_addr_t iova,</span>
<span class=quote>&gt;  				    bool do_accounting)</span>
<span class=quote>&gt;  {</span>
<span class=quote>&gt;  	int unlocked;</span>
<span class=quote>&gt;  	struct vfio_pfn *vpfn = vfio_find_vpfn(dma, iova);</span>
<span class=quote>&gt;  </span>
<span class=quote>&gt; -	if (!vpfn)</span>
<span class=quote>&gt; +	if (!vpfn || !vpfn-&gt;ref_count)</span>
<span class=quote>&gt;  		return 0;</span>
<span class=quote>&gt;  </span>
<span class=quote>&gt;  	unlocked = vfio_iova_put_vfio_pfn(dma, vpfn);</span>
<span class=quote>&gt; @@ -510,6 +589,7 @@ static int vfio_iommu_type1_pin_pages(void *iommu_data,</span>
<span class=quote>&gt;  	unsigned long remote_vaddr;</span>
<span class=quote>&gt;  	struct vfio_dma *dma;</span>
<span class=quote>&gt;  	bool do_accounting;</span>
<span class=quote>&gt; +	unsigned long iommu_pgsizes = vfio_pgsize_bitmap(iommu);</span>
<span class=quote>&gt;  </span>
<span class=quote>&gt;  	if (!iommu || !user_pfn || !phys_pfn)</span>
<span class=quote>&gt;  		return -EINVAL;</span>
<span class=quote>&gt; @@ -551,8 +631,10 @@ static int vfio_iommu_type1_pin_pages(void *iommu_data,</span>
<span class=quote>&gt;  </span>
<span class=quote>&gt;  		vpfn = vfio_iova_get_vfio_pfn(dma, iova);</span>
<span class=quote>&gt;  		if (vpfn) {</span>
<span class=quote>&gt; -			phys_pfn[i] = vpfn-&gt;pfn;</span>
<span class=quote>&gt; -			continue;</span>
<span class=quote>&gt; +			if (vpfn-&gt;ref_count &gt; 1) {</span>
<span class=quote>&gt; +				phys_pfn[i] = vpfn-&gt;pfn;</span>
<span class=quote>&gt; +				continue;</span>
<span class=quote>&gt; +			}</span>
<span class=quote>&gt;  		}</span>
<span class=quote>&gt;  </span>
<span class=quote>&gt;  		remote_vaddr = dma-&gt;vaddr + iova - dma-&gt;iova;</span>
<span class=quote>&gt; @@ -560,11 +642,23 @@ static int vfio_iommu_type1_pin_pages(void *iommu_data,</span>
<span class=quote>&gt;  					     do_accounting);</span>
<span class=quote>&gt;  		if (ret)</span>
<span class=quote>&gt;  			goto pin_unwind;</span>
<span class=quote>&gt; -</span>
<span class=quote>&gt; -		ret = vfio_add_to_pfn_list(dma, iova, phys_pfn[i]);</span>
<span class=quote>&gt; -		if (ret) {</span>
<span class=quote>&gt; -			vfio_unpin_page_external(dma, iova, do_accounting);</span>
<span class=quote>&gt; -			goto pin_unwind;</span>
<span class=quote>&gt; +		if (!vpfn) {</span>
<span class=quote>&gt; +			ret = vfio_add_to_pfn_list(dma, iova, phys_pfn[i]);</span>
<span class=quote>&gt; +			if (ret) {</span>
<span class=quote>&gt; +				vfio_unpin_page_external(iommu, dma, iova,</span>
<span class=quote>&gt; +							 do_accounting);</span>
<span class=quote>&gt; +				goto pin_unwind;</span>
<span class=quote>&gt; +			}</span>
<span class=quote>&gt; +		} else</span>
<span class=quote>&gt; +			vpfn-&gt;pfn = phys_pfn[i];</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +		if (iommu-&gt;dirty_page_tracking &amp;&amp; !dma-&gt;bitmap) {</span>
<span class=quote>&gt; +			ret = vfio_dma_bitmap_alloc(iommu, dma, iommu_pgsizes);</span>
<span class=quote>&gt; +			if (ret) {</span>
<span class=quote>&gt; +				vfio_unpin_page_external(iommu, dma, iova,</span>
<span class=quote>&gt; +							 do_accounting);</span>
<span class=quote>&gt; +				goto pin_unwind;</span>
<span class=quote>&gt; +			}</span>
<span class=quote>&gt;  		}</span>
<span class=quote>&gt;  	}</span>
<span class=quote>&gt;  </span>
<span class=quote>&gt; @@ -578,7 +672,7 @@ static int vfio_iommu_type1_pin_pages(void *iommu_data,</span>
<span class=quote>&gt;  </span>
<span class=quote>&gt;  		iova = user_pfn[j] &lt;&lt; PAGE_SHIFT;</span>
<span class=quote>&gt;  		dma = vfio_find_dma(iommu, iova, PAGE_SIZE);</span>
<span class=quote>&gt; -		vfio_unpin_page_external(dma, iova, do_accounting);</span>
<span class=quote>&gt; +		vfio_unpin_page_external(iommu, dma, iova, do_accounting);</span>
<span class=quote>&gt;  		phys_pfn[j] = 0;</span>
<span class=quote>&gt;  	}</span>
<span class=quote>&gt;  pin_done:</span>
<span class=quote>&gt; @@ -612,7 +706,7 @@ static int vfio_iommu_type1_unpin_pages(void *iommu_data,</span>
<span class=quote>&gt;  		dma = vfio_find_dma(iommu, iova, PAGE_SIZE);</span>
<span class=quote>&gt;  		if (!dma)</span>
<span class=quote>&gt;  			goto unpin_exit;</span>
<span class=quote>&gt; -		vfio_unpin_page_external(dma, iova, do_accounting);</span>
<span class=quote>&gt; +		vfio_unpin_page_external(iommu, dma, iova, do_accounting);</span>
<span class=quote>&gt;  	}</span>
<span class=quote>&gt;  </span>
<span class=quote>&gt;  unpin_exit:</span>
<span class=quote>&gt; @@ -830,6 +924,113 @@ static unsigned long vfio_pgsize_bitmap(struct vfio_iommu *iommu)</span>
<span class=quote>&gt;  	return bitmap;</span>
<span class=quote>&gt;  }</span>
<span class=quote>&gt;  </span>
<span class=quote>&gt; +static int vfio_iova_dirty_bitmap(struct vfio_iommu *iommu, dma_addr_t iova,</span>
<span class=quote>&gt; +				  size_t size, uint64_t pgsize,</span>
<span class=quote>&gt; +				  unsigned char __user *bitmap)</span>
<span class=quote>&gt; +{</span>
<span class=quote>&gt; +	struct vfio_dma *dma;</span>
<span class=quote>&gt; +	dma_addr_t i = iova, iova_limit;</span>
<span class=quote>&gt; +	unsigned int bsize, nbits = 0, l = 0;</span>
<span class=quote>&gt; +	unsigned long pgshift = __ffs(pgsize);</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +	while ((dma = vfio_find_dma(iommu, i, pgsize))) {</span>
<span class=quote>&gt; +		int ret, j;</span>
<span class=quote>&gt; +		unsigned int npages = 0, shift = 0;</span>
<span class=quote>&gt; +		unsigned char temp = 0;</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +		/* mark all pages dirty if all pages are pinned and mapped. */</span>
<span class=quote>&gt; +		if (dma-&gt;iommu_mapped) {</span>
<span class=quote>&gt; +			iova_limit = min(dma-&gt;iova + dma-&gt;size, iova + size);</span>
<span class=quote>&gt; +			npages = iova_limit/pgsize;</span>
<span class=quote>&gt; +			bitmap_set(dma-&gt;bitmap, 0, npages);</span>
for pass-through devices, it's not good to always return all pinned pages as
dirty. could it also call vfio_pin_pages to track dirty pages? or any
other interface provided to do that?
<span class=quote>&gt; +		} else if (dma-&gt;bitmap) {</span>
<span class=quote>&gt; +			struct rb_node *n = rb_first(&amp;dma-&gt;pfn_list);</span>
<span class=quote>&gt; +			bool found = false;</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +			for (; n; n = rb_next(n)) {</span>
<span class=quote>&gt; +				struct vfio_pfn *vpfn = rb_entry(n,</span>
<span class=quote>&gt; +						struct vfio_pfn, node);</span>
<span class=quote>&gt; +				if (vpfn-&gt;iova &gt;= i) {</span>
<span class=quote>&gt; +					found = true;</span>
<span class=quote>&gt; +					break;</span>
<span class=quote>&gt; +				}</span>
<span class=quote>&gt; +			}</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +			if (!found) {</span>
<span class=quote>&gt; +				i += dma-&gt;size;</span>
<span class=quote>&gt; +				continue;</span>
<span class=quote>&gt; +			}</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +			for (; n; n = rb_next(n)) {</span>
<span class=quote>&gt; +				unsigned int s;</span>
<span class=quote>&gt; +				struct vfio_pfn *vpfn = rb_entry(n,</span>
<span class=quote>&gt; +						struct vfio_pfn, node);</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +				if (vpfn-&gt;iova &gt;= iova + size)</span>
<span class=quote>&gt; +					break;</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +				s = (vpfn-&gt;iova - dma-&gt;iova) &gt;&gt; pgshift;</span>
<span class=quote>&gt; +				bitmap_set(dma-&gt;bitmap, s, 1);</span>
<span class=quote>&gt; +</span>
should not set the dma-&gt;bitmap when user space asks for dirty bitmap.
should set the bits for all vpfns when dirty page tracking starts, and clear
it after putting them to user space.
dma-&gt;bitmap is set when vfio_pin_pages is called during dirty page
tracking.
<span class=quote>&gt; +				iova_limit = vpfn-&gt;iova + pgsize;</span>
<span class=quote>&gt; +			}</span>
<span class=quote>&gt; +			npages = iova_limit/pgsize;</span>
<span class=quote>&gt; +		}</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +		bsize = dirty_bitmap_bytes(npages);</span>
<span class=quote>&gt; +		shift = nbits % BITS_PER_BYTE;</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +		if (npages &amp;&amp; shift) {</span>
<span class=quote>&gt; +			l--;</span>
<span class=quote>&gt; +			if (!access_ok((void __user *)bitmap + l,</span>
<span class=quote>&gt; +					sizeof(unsigned char)))</span>
<span class=quote>&gt; +				return -EINVAL;</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +			ret = __get_user(temp, bitmap + l);</span>
<span class=quote>&gt; +			if (ret)</span>
<span class=quote>&gt; +				return ret;</span>
<span class=quote>&gt; +		}</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +		for (j = 0; j &lt; bsize; j++, l++) {</span>
<span class=quote>&gt; +			temp = temp |</span>
<span class=quote>&gt; +			       (*((unsigned char *)dma-&gt;bitmap + j) &lt;&lt; shift);</span>
<span class=quote>&gt; +			if (!access_ok((void __user *)bitmap + l,</span>
<span class=quote>&gt; +					sizeof(unsigned char)))</span>
<span class=quote>&gt; +				return -EINVAL;</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +			ret = __put_user(temp, bitmap + l);</span>
<span class=quote>&gt; +			if (ret)</span>
<span class=quote>&gt; +				return ret;</span>
<span class=quote>&gt; +			if (shift) {</span>
<span class=quote>&gt; +				temp = *((unsigned char *)dma-&gt;bitmap + j) &gt;&gt;</span>
<span class=quote>&gt; +					(BITS_PER_BYTE - shift);</span>
<span class=quote>&gt; +			}</span>
<span class=quote>&gt; +		}</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +		nbits += npages;</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +		i = min(dma-&gt;iova + dma-&gt;size, iova + size);</span>
<span class=quote>&gt; +		if (i &gt;= iova + size)</span>
<span class=quote>&gt; +			break;</span>
<span class=quote>&gt; +	}</span>
<span class=quote>&gt; +	return 0;</span>
<span class=quote>&gt; +}</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +static long verify_bitmap_size(unsigned long npages, unsigned long bitmap_size)</span>
<span class=quote>&gt; +{</span>
<span class=quote>&gt; +	long bsize;</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +	if (!bitmap_size || bitmap_size &gt; SIZE_MAX)</span>
<span class=quote>&gt; +		return -EINVAL;</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +	bsize = dirty_bitmap_bytes(npages);</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +	if (bitmap_size &lt; bsize)</span>
<span class=quote>&gt; +		return -EINVAL;</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +	return bsize;</span>
<span class=quote>&gt; +}</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt;  static int vfio_dma_do_unmap(struct vfio_iommu *iommu,</span>
<span class=quote>&gt;  			     struct vfio_iommu_type1_dma_unmap *unmap)</span>
<span class=quote>&gt;  {</span>
<span class=quote>&gt; @@ -2277,6 +2478,80 @@ static long vfio_iommu_type1_ioctl(void *iommu_data,</span>
<span class=quote>&gt;  </span>
<span class=quote>&gt;  		return copy_to_user((void __user *)arg, &amp;unmap, minsz) ?</span>
<span class=quote>&gt;  			-EFAULT : 0;</span>
<span class=quote>&gt; +	} else if (cmd == VFIO_IOMMU_DIRTY_PAGES) {</span>
<span class=quote>&gt; +		struct vfio_iommu_type1_dirty_bitmap range;</span>
<span class=quote>&gt; +		uint32_t mask = VFIO_IOMMU_DIRTY_PAGES_FLAG_START |</span>
<span class=quote>&gt; +				VFIO_IOMMU_DIRTY_PAGES_FLAG_STOP |</span>
<span class=quote>&gt; +				VFIO_IOMMU_DIRTY_PAGES_FLAG_GET_BITMAP;</span>
<span class=quote>&gt; +		int ret;</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +		if (!iommu-&gt;v2)</span>
<span class=quote>&gt; +			return -EACCES;</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +		minsz = offsetofend(struct vfio_iommu_type1_dirty_bitmap,</span>
<span class=quote>&gt; +				    bitmap);</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +		if (copy_from_user(&amp;range, (void __user *)arg, minsz))</span>
<span class=quote>&gt; +			return -EFAULT;</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +		if (range.argsz &lt; minsz || range.flags &amp; ~mask)</span>
<span class=quote>&gt; +			return -EINVAL;</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +		/* only one flag should be set at a time */</span>
<span class=quote>&gt; +		if (__ffs(range.flags) != __fls(range.flags))</span>
<span class=quote>&gt; +			return -EINVAL;</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +		if (range.flags &amp; VFIO_IOMMU_DIRTY_PAGES_FLAG_START) {</span>
<span class=quote>&gt; +			unsigned long iommu_pgsizes = vfio_pgsize_bitmap(iommu);</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +			mutex_lock(&amp;iommu-&gt;lock);</span>
<span class=quote>&gt; +			iommu-&gt;dirty_page_tracking = true;</span>
should only set iommu-&gt;dirty_page_tracking = true after bitmap alloc
succeeds.
<span class=quote>&gt; +			ret = vfio_dma_all_bitmap_alloc(iommu, iommu_pgsizes);</span>
<span class=quote>&gt; +			mutex_unlock(&amp;iommu-&gt;lock);</span>
<span class=quote>&gt; +			return ret;</span>
<span class=quote>&gt; +		} else if (range.flags &amp; VFIO_IOMMU_DIRTY_PAGES_FLAG_STOP) {</span>
<span class=quote>&gt; +			mutex_lock(&amp;iommu-&gt;lock);</span>
<span class=quote>&gt; +			iommu-&gt;dirty_page_tracking = false;</span>
<span class=quote>&gt; +			vfio_dma_all_bitmap_free(iommu);</span>
<span class=quote>&gt; +			vfio_remove_unpinned_from_dma_list(iommu);</span>
<span class=quote>&gt; +			mutex_unlock(&amp;iommu-&gt;lock);</span>
<span class=quote>&gt; +			return 0;</span>
<span class=quote>&gt; +		} else if (range.flags &amp;</span>
<span class=quote>&gt; +				 VFIO_IOMMU_DIRTY_PAGES_FLAG_GET_BITMAP) {</span>
<span class=quote>&gt; +			long bsize;</span>
<span class=quote>&gt; +			unsigned long pgshift = __ffs(range.pgsize);</span>
<span class=quote>&gt; +			uint64_t iommu_pgsizes = vfio_pgsize_bitmap(iommu);</span>
<span class=quote>&gt; +			uint64_t iommu_pgmask =</span>
<span class=quote>&gt; +				 ((uint64_t)1 &lt;&lt; __ffs(iommu_pgsizes)) - 1;</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +			if ((range.pgsize &amp; iommu_pgsizes) != range.pgsize)</span>
<span class=quote>&gt; +				return -EINVAL;</span>
<span class=quote>&gt; +			if (range.iova &amp; iommu_pgmask)</span>
<span class=quote>&gt; +				return -EINVAL;</span>
<span class=quote>&gt; +			if (!range.size || range.size &amp; iommu_pgmask)</span>
<span class=quote>&gt; +				return -EINVAL;</span>
<span class=quote>&gt; +			if (range.iova + range.size &lt; range.iova)</span>
<span class=quote>&gt; +				return -EINVAL;</span>
<span class=quote>&gt; +			if (!access_ok((void __user *)range.bitmap,</span>
<span class=quote>&gt; +				       range.bitmap_size))</span>
<span class=quote>&gt; +				return -EINVAL;</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +			bsize = verify_bitmap_size(range.size &gt;&gt; pgshift,</span>
<span class=quote>&gt; +						   range.bitmap_size);</span>
<span class=quote>&gt; +			if (bsize &lt; 0)</span>
<span class=quote>&gt; +				return bsize;</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +			mutex_lock(&amp;iommu-&gt;lock);</span>
<span class=quote>&gt; +			if (iommu-&gt;dirty_page_tracking)</span>
<span class=quote>&gt; +				ret = vfio_iova_dirty_bitmap(iommu, range.iova,</span>
<span class=quote>&gt; +					 range.size, range.pgsize,</span>
<span class=quote>&gt; +					 (unsigned char __user *)range.bitmap);</span>
<span class=quote>&gt; +			else</span>
<span class=quote>&gt; +				ret = -EINVAL;</span>
<span class=quote>&gt; +			mutex_unlock(&amp;iommu-&gt;lock);</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +			return ret;</span>
<span class=quote>&gt; +		}</span>
<span class=quote>&gt;  	}</span>
<span class=quote>&gt;  </span>
<span class=quote>&gt;  	return -ENOTTY;</span>
<span class=quote>&gt; -- </span>
<span class=quote>&gt; 2.7.0</span>
<span class=quote>&gt;</span>
</pre>
</div>
<a name=23147033></a>
<div class=comment>
<div class=meta>
 <span><a href="https://patchwork.kernel.org/project/qemu-devel/list/?submitter=7781">Alex Williamson</a></span>
 <span class=pull-right>Feb. 10, 2020, 5:25 p.m. UTC | <a href=https://patchwork.kernel.org/comment/23147033/>#2</a></span>
</div>
<pre class=content>On Sat, 8 Feb 2020 01:12:31 +0530
Kirti Wankhede &lt;kwankhede@nvidia.com&gt; wrote:
<span class=quote>
&gt; VFIO_IOMMU_DIRTY_PAGES ioctl performs three operations:</span>
<span class=quote>&gt; - Start pinned and unpinned pages tracking while migration is active</span>
<span class=quote>&gt; - Stop pinned and unpinned dirty pages tracking. This is also used to</span>
<span class=quote>&gt;   stop dirty pages tracking if migration failed or cancelled.</span>
<span class=quote>&gt; - Get dirty pages bitmap. This ioctl returns bitmap of dirty pages, its</span>
<span class=quote>&gt;   user space application responsibility to copy content of dirty pages</span>
<span class=quote>&gt;   from source to destination during migration.</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; To prevent DoS attack, memory for bitmap is allocated per vfio_dma</span>
<span class=quote>&gt; structure. Bitmap size is calculated considering smallest supported page</span>
<span class=quote>&gt; size. Bitmap is allocated when dirty logging is enabled for those</span>
<span class=quote>&gt; vfio_dmas whose vpfn list is not empty or whole range is mapped, in</span>
<span class=quote>&gt; case of pass-through device.</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; There could be multiple option as to when bitmap should be populated:</span>
<span class=quote>&gt; * Polulate bitmap for already pinned pages when bitmap is allocated for</span>
<span class=quote>&gt;   a vfio_dma with the smallest supported page size. Updates bitmap from</span>
<span class=quote>&gt;   page pinning and unpinning functions. When user application queries</span>
<span class=quote>&gt;   bitmap, check if requested page size is same as page size used to</span>
<span class=quote>&gt;   populated bitmap. If it is equal, copy bitmap. But if not equal,</span>
<span class=quote>&gt;   re-populated bitmap according to requested page size and then copy to</span>
<span class=quote>&gt;   user.</span>
<span class=quote>&gt;   Pros: Bitmap gets populated on the fly after dirty tracking has</span>
<span class=quote>&gt;         started.</span>
<span class=quote>&gt;   Cons: If requested page size is different than smallest supported</span>
<span class=quote>&gt;         page size, then bitmap has to be re-populated again, with</span>
<span class=quote>&gt;         additional overhead of allocating bitmap memory again for</span>
<span class=quote>&gt;         re-population of bitmap.</span>

No memory needs to be allocated to re-populate the bitmap.  The bitmap
is clear-on-read and by tracking the bitmap in the smallest supported
page size we can guarantee that we can fit the user requested bitmap
size within the space occupied by that minimal page size range of the
bitmap.  Therefore we'd destructively translate the requested region of
the bitmap to a different page size, write it out to the user, and
clear it.  Also we expect userspace to use the minimum page size almost
exclusively, which is optimized by this approach as dirty bit tracking
is spread out over each page pinning operation.
<span class=quote>
&gt; </span>
<span class=quote>&gt; * Populate bitmap when bitmap is queried by user application.</span>
<span class=quote>&gt;   Pros: Bitmap is populated with requested page size. This eliminates</span>
<span class=quote>&gt;         the need to re-populate bitmap if requested page size is</span>
<span class=quote>&gt;         different than smallest supported pages size.</span>
<span class=quote>&gt;   Cons: There is one time processing time, when bitmap is queried.</span>

Another significant Con is that the vpfn list needs to track and manage
unpinned pages, which makes it more complex and intrusive.  The
previous option seems to have both time and complexity advantages,
especially in the case we expect to be most common of the user
accessing the bitmap with the minimum page size, ie. PAGE_SIZE.  It's
also not clear why we pre-allocate the bitmap at all with this approach.
<span class=quote>
&gt; I prefer later option with simple logic and to eliminate over-head of</span>
<span class=quote>&gt; bitmap repopulation in case of differnt page sizes. Later option is</span>
<span class=quote>&gt; implemented in this patch.</span>

Hmm, we'll see below, but I not convinced based on the above rationale.
<span class=quote>
&gt; Signed-off-by: Kirti Wankhede &lt;kwankhede@nvidia.com&gt;</span>
<span class=quote>&gt; Reviewed-by: Neo Jia &lt;cjia@nvidia.com&gt;</span>
<span class=quote>&gt; ---</span>
<span class=quote>&gt;  drivers/vfio/vfio_iommu_type1.c | 299 ++++++++++++++++++++++++++++++++++++++--</span>
<span class=quote>&gt;  1 file changed, 287 insertions(+), 12 deletions(-)</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; diff --git a/drivers/vfio/vfio_iommu_type1.c b/drivers/vfio/vfio_iommu_type1.c</span>
<span class=quote>&gt; index d386461e5d11..df358dc1c85b 100644</span>
<span class=quote>&gt; --- a/drivers/vfio/vfio_iommu_type1.c</span>
<span class=quote>&gt; +++ b/drivers/vfio/vfio_iommu_type1.c</span>
<span class=quote>&gt; @@ -70,6 +70,7 @@ struct vfio_iommu {</span>
<span class=quote>&gt;  	unsigned int		dma_avail;</span>
<span class=quote>&gt;  	bool			v2;</span>
<span class=quote>&gt;  	bool			nesting;</span>
<span class=quote>&gt; +	bool			dirty_page_tracking;</span>
<span class=quote>&gt;  };</span>
<span class=quote>&gt;  </span>
<span class=quote>&gt;  struct vfio_domain {</span>
<span class=quote>&gt; @@ -90,6 +91,7 @@ struct vfio_dma {</span>
<span class=quote>&gt;  	bool			lock_cap;	/* capable(CAP_IPC_LOCK) */</span>
<span class=quote>&gt;  	struct task_struct	*task;</span>
<span class=quote>&gt;  	struct rb_root		pfn_list;	/* Ex-user pinned pfn list */</span>
<span class=quote>&gt; +	unsigned long		*bitmap;</span>
<span class=quote>&gt;  };</span>
<span class=quote>&gt;  </span>
<span class=quote>&gt;  struct vfio_group {</span>
<span class=quote>&gt; @@ -125,6 +127,7 @@ struct vfio_regions {</span>
<span class=quote>&gt;  					(!list_empty(&amp;iommu-&gt;domain_list))</span>
<span class=quote>&gt;  </span>
<span class=quote>&gt;  static int put_pfn(unsigned long pfn, int prot);</span>
<span class=quote>&gt; +static unsigned long vfio_pgsize_bitmap(struct vfio_iommu *iommu);</span>
<span class=quote>&gt;  </span>
<span class=quote>&gt;  /*</span>
<span class=quote>&gt;   * This code handles mapping and unmapping of user data buffers</span>
<span class=quote>&gt; @@ -174,6 +177,57 @@ static void vfio_unlink_dma(struct vfio_iommu *iommu, struct vfio_dma *old)</span>
<span class=quote>&gt;  	rb_erase(&amp;old-&gt;node, &amp;iommu-&gt;dma_list);</span>
<span class=quote>&gt;  }</span>
<span class=quote>&gt;  </span>
<span class=quote>&gt; +static inline unsigned long dirty_bitmap_bytes(unsigned int npages)</span>
<span class=quote>&gt; +{</span>
<span class=quote>&gt; +	if (!npages)</span>
<span class=quote>&gt; +		return 0;</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +	return ALIGN(npages, BITS_PER_LONG) / sizeof(unsigned long);</span>
<span class=quote>&gt; +}</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +static int vfio_dma_bitmap_alloc(struct vfio_iommu *iommu,</span>
<span class=quote>&gt; +				 struct vfio_dma *dma, unsigned long pgsizes)</span>
<span class=quote>&gt; +{</span>
<span class=quote>&gt; +	unsigned long pgshift = __ffs(pgsizes);</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +	if (!RB_EMPTY_ROOT(&amp;dma-&gt;pfn_list) || dma-&gt;iommu_mapped) {</span>
<span class=quote>&gt; +		unsigned long npages = dma-&gt;size &gt;&gt; pgshift;</span>
<span class=quote>&gt; +		unsigned long bsize = dirty_bitmap_bytes(npages);</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +		dma-&gt;bitmap = kvzalloc(bsize, GFP_KERNEL);</span>

nit, we don't need to store bsize in a local variable.
<span class=quote>
&gt; +		if (!dma-&gt;bitmap)</span>
<span class=quote>&gt; +			return -ENOMEM;</span>
<span class=quote>&gt; +	}</span>
<span class=quote>&gt; +	return 0;</span>
<span class=quote>&gt; +}</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +static int vfio_dma_all_bitmap_alloc(struct vfio_iommu *iommu,</span>
<span class=quote>&gt; +				     unsigned long pgsizes)</span>
<span class=quote>&gt; +{</span>
<span class=quote>&gt; +	struct rb_node *n = rb_first(&amp;iommu-&gt;dma_list);</span>
<span class=quote>&gt; +	int ret;</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +	for (; n; n = rb_next(n)) {</span>
<span class=quote>&gt; +		struct vfio_dma *dma = rb_entry(n, struct vfio_dma, node);</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +		ret = vfio_dma_bitmap_alloc(iommu, dma, pgsizes);</span>
<span class=quote>&gt; +		if (ret)</span>
<span class=quote>&gt; +			return ret;</span>

This doesn't unwind on failure, so we're left with partially allocated
bitmap cruft.
<span class=quote>
&gt; +	}</span>
<span class=quote>&gt; +	return 0;</span>
<span class=quote>&gt; +}</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +static void vfio_dma_all_bitmap_free(struct vfio_iommu *iommu)</span>
<span class=quote>&gt; +{</span>
<span class=quote>&gt; +	struct rb_node *n = rb_first(&amp;iommu-&gt;dma_list);</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +	for (; n; n = rb_next(n)) {</span>
<span class=quote>&gt; +		struct vfio_dma *dma = rb_entry(n, struct vfio_dma, node);</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +		kfree(dma-&gt;bitmap);</span>

We don't set dma-&gt;bitmap = NULL and we don't even prevent the case of a
user making multiple STOP calls, so we have a user triggerable double
free :(
<span class=quote>
&gt; +	}</span>
<span class=quote>&gt; +}</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt;  /*</span>
<span class=quote>&gt;   * Helper Functions for host iova-pfn list</span>
<span class=quote>&gt;   */</span>
<span class=quote>&gt; @@ -244,6 +298,29 @@ static void vfio_remove_from_pfn_list(struct vfio_dma *dma,</span>
<span class=quote>&gt;  	kfree(vpfn);</span>
<span class=quote>&gt;  }</span>
<span class=quote>&gt;  </span>
<span class=quote>&gt; +static void vfio_remove_unpinned_from_pfn_list(struct vfio_dma *dma)</span>
<span class=quote>&gt; +{</span>
<span class=quote>&gt; +	struct rb_node *n = rb_first(&amp;dma-&gt;pfn_list);</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +	for (; n; n = rb_next(n)) {</span>
<span class=quote>&gt; +		struct vfio_pfn *vpfn = rb_entry(n, struct vfio_pfn, node);</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +		if (!vpfn-&gt;ref_count)</span>
<span class=quote>&gt; +			vfio_remove_from_pfn_list(dma, vpfn);</span>
<span class=quote>&gt; +	}</span>
<span class=quote>&gt; +}</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +static void vfio_remove_unpinned_from_dma_list(struct vfio_iommu *iommu)</span>
<span class=quote>&gt; +{</span>
<span class=quote>&gt; +	struct rb_node *n = rb_first(&amp;iommu-&gt;dma_list);</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +	for (; n; n = rb_next(n)) {</span>
<span class=quote>&gt; +		struct vfio_dma *dma = rb_entry(n, struct vfio_dma, node);</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +		vfio_remove_unpinned_from_pfn_list(dma);</span>
<span class=quote>&gt; +	}</span>
<span class=quote>&gt; +}</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt;  static struct vfio_pfn *vfio_iova_get_vfio_pfn(struct vfio_dma *dma,</span>
<span class=quote>&gt;  					       unsigned long iova)</span>
<span class=quote>&gt;  {</span>
<span class=quote>&gt; @@ -261,7 +338,8 @@ static int vfio_iova_put_vfio_pfn(struct vfio_dma *dma, struct vfio_pfn *vpfn)</span>
<span class=quote>&gt;  	vpfn-&gt;ref_count--;</span>
<span class=quote>&gt;  	if (!vpfn-&gt;ref_count) {</span>
<span class=quote>&gt;  		ret = put_pfn(vpfn-&gt;pfn, dma-&gt;prot);</span>
<span class=quote>&gt; -		vfio_remove_from_pfn_list(dma, vpfn);</span>
<span class=quote>&gt; +		if (!dma-&gt;bitmap)</span>
<span class=quote>&gt; +			vfio_remove_from_pfn_list(dma, vpfn);</span>
<span class=quote>&gt;  	}</span>
<span class=quote>&gt;  	return ret;</span>
<span class=quote>&gt;  }</span>
<span class=quote>&gt; @@ -483,13 +561,14 @@ static int vfio_pin_page_external(struct vfio_dma *dma, unsigned long vaddr,</span>
<span class=quote>&gt;  	return ret;</span>
<span class=quote>&gt;  }</span>
<span class=quote>&gt;  </span>
<span class=quote>&gt; -static int vfio_unpin_page_external(struct vfio_dma *dma, dma_addr_t iova,</span>
<span class=quote>&gt; +static int vfio_unpin_page_external(struct vfio_iommu *iommu,</span>

We added a parameter but didn't use it in this patch.
<span class=quote>
&gt; +				    struct vfio_dma *dma, dma_addr_t iova,</span>
<span class=quote>&gt;  				    bool do_accounting)</span>
<span class=quote>&gt;  {</span>
<span class=quote>&gt;  	int unlocked;</span>
<span class=quote>&gt;  	struct vfio_pfn *vpfn = vfio_find_vpfn(dma, iova);</span>
<span class=quote>&gt;  </span>
<span class=quote>&gt; -	if (!vpfn)</span>
<span class=quote>&gt; +	if (!vpfn || !vpfn-&gt;ref_count)</span>
<span class=quote>&gt;  		return 0;</span>
<span class=quote>&gt;  </span>
<span class=quote>&gt;  	unlocked = vfio_iova_put_vfio_pfn(dma, vpfn);</span>
<span class=quote>&gt; @@ -510,6 +589,7 @@ static int vfio_iommu_type1_pin_pages(void *iommu_data,</span>
<span class=quote>&gt;  	unsigned long remote_vaddr;</span>
<span class=quote>&gt;  	struct vfio_dma *dma;</span>
<span class=quote>&gt;  	bool do_accounting;</span>
<span class=quote>&gt; +	unsigned long iommu_pgsizes = vfio_pgsize_bitmap(iommu);</span>
<span class=quote>&gt;  </span>
<span class=quote>&gt;  	if (!iommu || !user_pfn || !phys_pfn)</span>
<span class=quote>&gt;  		return -EINVAL;</span>
<span class=quote>&gt; @@ -551,8 +631,10 @@ static int vfio_iommu_type1_pin_pages(void *iommu_data,</span>
<span class=quote>&gt;  </span>
<span class=quote>&gt;  		vpfn = vfio_iova_get_vfio_pfn(dma, iova);</span>
<span class=quote>&gt;  		if (vpfn) {</span>
<span class=quote>&gt; -			phys_pfn[i] = vpfn-&gt;pfn;</span>
<span class=quote>&gt; -			continue;</span>
<span class=quote>&gt; +			if (vpfn-&gt;ref_count &gt; 1) {</span>
<span class=quote>&gt; +				phys_pfn[i] = vpfn-&gt;pfn;</span>
<span class=quote>&gt; +				continue;</span>
<span class=quote>&gt; +			}</span>
<span class=quote>&gt;  		}</span>
<span class=quote>&gt;  </span>
<span class=quote>&gt;  		remote_vaddr = dma-&gt;vaddr + iova - dma-&gt;iova;</span>
<span class=quote>&gt; @@ -560,11 +642,23 @@ static int vfio_iommu_type1_pin_pages(void *iommu_data,</span>
<span class=quote>&gt;  					     do_accounting);</span>
<span class=quote>&gt;  		if (ret)</span>
<span class=quote>&gt;  			goto pin_unwind;</span>
<span class=quote>&gt; -</span>
<span class=quote>&gt; -		ret = vfio_add_to_pfn_list(dma, iova, phys_pfn[i]);</span>
<span class=quote>&gt; -		if (ret) {</span>
<span class=quote>&gt; -			vfio_unpin_page_external(dma, iova, do_accounting);</span>
<span class=quote>&gt; -			goto pin_unwind;</span>
<span class=quote>&gt; +		if (!vpfn) {</span>
<span class=quote>&gt; +			ret = vfio_add_to_pfn_list(dma, iova, phys_pfn[i]);</span>
<span class=quote>&gt; +			if (ret) {</span>
<span class=quote>&gt; +				vfio_unpin_page_external(iommu, dma, iova,</span>
<span class=quote>&gt; +							 do_accounting);</span>
<span class=quote>&gt; +				goto pin_unwind;</span>
<span class=quote>&gt; +			}</span>
<span class=quote>&gt; +		} else</span>
<span class=quote>&gt; +			vpfn-&gt;pfn = phys_pfn[i];</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +		if (iommu-&gt;dirty_page_tracking &amp;&amp; !dma-&gt;bitmap) {</span>
<span class=quote>&gt; +			ret = vfio_dma_bitmap_alloc(iommu, dma, iommu_pgsizes);</span>
<span class=quote>&gt; +			if (ret) {</span>
<span class=quote>&gt; +				vfio_unpin_page_external(iommu, dma, iova,</span>
<span class=quote>&gt; +							 do_accounting);</span>
<span class=quote>&gt; +				goto pin_unwind;</span>
<span class=quote>&gt; +			}</span>
<span class=quote>&gt;  		}</span>
<span class=quote>&gt;  	}</span>
<span class=quote>&gt;  </span>
<span class=quote>&gt; @@ -578,7 +672,7 @@ static int vfio_iommu_type1_pin_pages(void *iommu_data,</span>
<span class=quote>&gt;  </span>
<span class=quote>&gt;  		iova = user_pfn[j] &lt;&lt; PAGE_SHIFT;</span>
<span class=quote>&gt;  		dma = vfio_find_dma(iommu, iova, PAGE_SIZE);</span>
<span class=quote>&gt; -		vfio_unpin_page_external(dma, iova, do_accounting);</span>
<span class=quote>&gt; +		vfio_unpin_page_external(iommu, dma, iova, do_accounting);</span>
<span class=quote>&gt;  		phys_pfn[j] = 0;</span>
<span class=quote>&gt;  	}</span>
<span class=quote>&gt;  pin_done:</span>
<span class=quote>&gt; @@ -612,7 +706,7 @@ static int vfio_iommu_type1_unpin_pages(void *iommu_data,</span>
<span class=quote>&gt;  		dma = vfio_find_dma(iommu, iova, PAGE_SIZE);</span>
<span class=quote>&gt;  		if (!dma)</span>
<span class=quote>&gt;  			goto unpin_exit;</span>
<span class=quote>&gt; -		vfio_unpin_page_external(dma, iova, do_accounting);</span>
<span class=quote>&gt; +		vfio_unpin_page_external(iommu, dma, iova, do_accounting);</span>
<span class=quote>&gt;  	}</span>
<span class=quote>&gt;  </span>
<span class=quote>&gt;  unpin_exit:</span>
<span class=quote>&gt; @@ -830,6 +924,113 @@ static unsigned long vfio_pgsize_bitmap(struct vfio_iommu *iommu)</span>
<span class=quote>&gt;  	return bitmap;</span>
<span class=quote>&gt;  }</span>
<span class=quote>&gt;  </span>
<span class=quote>&gt; +static int vfio_iova_dirty_bitmap(struct vfio_iommu *iommu, dma_addr_t iova,</span>
<span class=quote>&gt; +				  size_t size, uint64_t pgsize,</span>
<span class=quote>&gt; +				  unsigned char __user *bitmap)</span>
<span class=quote>&gt; +{</span>
<span class=quote>&gt; +	struct vfio_dma *dma;</span>
<span class=quote>&gt; +	dma_addr_t i = iova, iova_limit;</span>
<span class=quote>&gt; +	unsigned int bsize, nbits = 0, l = 0;</span>
<span class=quote>&gt; +	unsigned long pgshift = __ffs(pgsize);</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +	while ((dma = vfio_find_dma(iommu, i, pgsize))) {</span>
<span class=quote>&gt; +		int ret, j;</span>
<span class=quote>&gt; +		unsigned int npages = 0, shift = 0;</span>
<span class=quote>&gt; +		unsigned char temp = 0;</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +		/* mark all pages dirty if all pages are pinned and mapped. */</span>
<span class=quote>&gt; +		if (dma-&gt;iommu_mapped) {</span>
<span class=quote>&gt; +			iova_limit = min(dma-&gt;iova + dma-&gt;size, iova + size);</span>
<span class=quote>&gt; +			npages = iova_limit/pgsize;</span>
<span class=quote>&gt; +			bitmap_set(dma-&gt;bitmap, 0, npages);</span>

npages is derived from iova_limit, which is the number of bits to set
dirty relative to the first requested iova, not iova zero, ie. the set
of dirty bits is offset from those requested unless iova == dma-&gt;iova.

Also I hope dma-&gt;bitmap was actually allocated.  Not only does the
START error path potentially leave dirty tracking enabled without all
the bitmap allocated, when does the bitmap get allocated for a new
vfio_dma when dirty tracking is enabled?  Seems it only occurs if a
vpfn gets marked dirty.
<span class=quote>
&gt; +		} else if (dma-&gt;bitmap) {</span>
<span class=quote>&gt; +			struct rb_node *n = rb_first(&amp;dma-&gt;pfn_list);</span>
<span class=quote>&gt; +			bool found = false;</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +			for (; n; n = rb_next(n)) {</span>
<span class=quote>&gt; +				struct vfio_pfn *vpfn = rb_entry(n,</span>
<span class=quote>&gt; +						struct vfio_pfn, node);</span>
<span class=quote>&gt; +				if (vpfn-&gt;iova &gt;= i) {</span>
<span class=quote>&gt; +					found = true;</span>
<span class=quote>&gt; +					break;</span>
<span class=quote>&gt; +				}</span>
<span class=quote>&gt; +			}</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +			if (!found) {</span>
<span class=quote>&gt; +				i += dma-&gt;size;</span>
<span class=quote>&gt; +				continue;</span>
<span class=quote>&gt; +			}</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +			for (; n; n = rb_next(n)) {</span>
<span class=quote>&gt; +				unsigned int s;</span>
<span class=quote>&gt; +				struct vfio_pfn *vpfn = rb_entry(n,</span>
<span class=quote>&gt; +						struct vfio_pfn, node);</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +				if (vpfn-&gt;iova &gt;= iova + size)</span>
<span class=quote>&gt; +					break;</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +				s = (vpfn-&gt;iova - dma-&gt;iova) &gt;&gt; pgshift;</span>
<span class=quote>&gt; +				bitmap_set(dma-&gt;bitmap, s, 1);</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +				iova_limit = vpfn-&gt;iova + pgsize;</span>
<span class=quote>&gt; +			}</span>
<span class=quote>&gt; +			npages = iova_limit/pgsize;</span>

Isn't iova_limit potentially uninitialized here?  For example, if our
vfio_dma covers {0,8192} and we ask for the bitmap of {0,4096} and
there's a vpfn at {4096,8192}.  I think that means vpfn-&gt;iova &gt;= i
(4096 &gt;= 0), so we break with found = true, then we test 4096 &gt;= 0 +
4096 and break, and npages = ????/pgsize.
<span class=quote>
&gt; +		}</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +		bsize = dirty_bitmap_bytes(npages);</span>
<span class=quote>&gt; +		shift = nbits % BITS_PER_BYTE;</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +		if (npages &amp;&amp; shift) {</span>
<span class=quote>&gt; +			l--;</span>
<span class=quote>&gt; +			if (!access_ok((void __user *)bitmap + l,</span>
<span class=quote>&gt; +					sizeof(unsigned char)))</span>
<span class=quote>&gt; +				return -EINVAL;</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +			ret = __get_user(temp, bitmap + l);</span>

I don't understand why we care to get the user's bitmap, are we trying
to leave whatever garbage they might have set in it and only also set
the dirty bits?  That seems unnecessary.

Also why do we need these access_ok() checks when we already checked
the range at the start of the ioctl?
<span class=quote>
&gt; +			if (ret)</span>
<span class=quote>&gt; +				return ret;</span>
<span class=quote>&gt; +		}</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +		for (j = 0; j &lt; bsize; j++, l++) {</span>
<span class=quote>&gt; +			temp = temp |</span>
<span class=quote>&gt; +			       (*((unsigned char *)dma-&gt;bitmap + j) &lt;&lt; shift);</span>

|=
<span class=quote>
&gt; +			if (!access_ok((void __user *)bitmap + l,</span>
<span class=quote>&gt; +					sizeof(unsigned char)))</span>
<span class=quote>&gt; +				return -EINVAL;</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +			ret = __put_user(temp, bitmap + l);</span>
<span class=quote>&gt; +			if (ret)</span>
<span class=quote>&gt; +				return ret;</span>
<span class=quote>&gt; +			if (shift) {</span>
<span class=quote>&gt; +				temp = *((unsigned char *)dma-&gt;bitmap + j) &gt;&gt;</span>
<span class=quote>&gt; +					(BITS_PER_BYTE - shift);</span>
<span class=quote>&gt; +			}</span>

When shift == 0, temp just seems to accumulate bits that never get
cleared.
<span class=quote>
&gt; +		}</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +		nbits += npages;</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +		i = min(dma-&gt;iova + dma-&gt;size, iova + size);</span>
<span class=quote>&gt; +		if (i &gt;= iova + size)</span>
<span class=quote>&gt; +			break;</span>

So whether we error or succeed, we leave cruft in dma-&gt;bitmap for the
next pass.  It doesn't seem to make any sense why we pre-allocated the
bitmap, we might as well just allocate it on demand here.  Actually, if
we're not going to do a copy_to_user() for some range of the bitmap,
I'm not sure what it's purpose is at all.  I think the big advantages
of the bitmap are that we can't amortize the cost across every pinned
page or DMA mapping, we don't need the overhead of tracking unmapped
vpfns, and we can use copy_to_user() to push the bitmap out.  We're not
getting any of those advantages here.
<span class=quote>
&gt; +	}</span>
<span class=quote>&gt; +	return 0;</span>
<span class=quote>&gt; +}</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +static long verify_bitmap_size(unsigned long npages, unsigned long bitmap_size)</span>
<span class=quote>&gt; +{</span>
<span class=quote>&gt; +	long bsize;</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +	if (!bitmap_size || bitmap_size &gt; SIZE_MAX)</span>
<span class=quote>&gt; +		return -EINVAL;</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +	bsize = dirty_bitmap_bytes(npages);</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +	if (bitmap_size &lt; bsize)</span>
<span class=quote>&gt; +		return -EINVAL;</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +	return bsize;</span>
<span class=quote>&gt; +}</span>

Seems like this could simply return int, -errno or zero for success.
The returned bsize is not used for anything else.
<span class=quote>
&gt; +</span>
<span class=quote>&gt;  static int vfio_dma_do_unmap(struct vfio_iommu *iommu,</span>
<span class=quote>&gt;  			     struct vfio_iommu_type1_dma_unmap *unmap)</span>
<span class=quote>&gt;  {</span>
<span class=quote>&gt; @@ -2277,6 +2478,80 @@ static long vfio_iommu_type1_ioctl(void *iommu_data,</span>
<span class=quote>&gt;  </span>
<span class=quote>&gt;  		return copy_to_user((void __user *)arg, &amp;unmap, minsz) ?</span>
<span class=quote>&gt;  			-EFAULT : 0;</span>
<span class=quote>&gt; +	} else if (cmd == VFIO_IOMMU_DIRTY_PAGES) {</span>
<span class=quote>&gt; +		struct vfio_iommu_type1_dirty_bitmap range;</span>
<span class=quote>&gt; +		uint32_t mask = VFIO_IOMMU_DIRTY_PAGES_FLAG_START |</span>
<span class=quote>&gt; +				VFIO_IOMMU_DIRTY_PAGES_FLAG_STOP |</span>
<span class=quote>&gt; +				VFIO_IOMMU_DIRTY_PAGES_FLAG_GET_BITMAP;</span>
<span class=quote>&gt; +		int ret;</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +		if (!iommu-&gt;v2)</span>
<span class=quote>&gt; +			return -EACCES;</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +		minsz = offsetofend(struct vfio_iommu_type1_dirty_bitmap,</span>
<span class=quote>&gt; +				    bitmap);</span>

We require the user to provide iova, size, pgsize, bitmap_size, and
bitmap fields to START/STOP?  Why?
<span class=quote>
&gt; +</span>
<span class=quote>&gt; +		if (copy_from_user(&amp;range, (void __user *)arg, minsz))</span>
<span class=quote>&gt; +			return -EFAULT;</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +		if (range.argsz &lt; minsz || range.flags &amp; ~mask)</span>
<span class=quote>&gt; +			return -EINVAL;</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +		/* only one flag should be set at a time */</span>
<span class=quote>&gt; +		if (__ffs(range.flags) != __fls(range.flags))</span>
<span class=quote>&gt; +			return -EINVAL;</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +		if (range.flags &amp; VFIO_IOMMU_DIRTY_PAGES_FLAG_START) {</span>
<span class=quote>&gt; +			unsigned long iommu_pgsizes = vfio_pgsize_bitmap(iommu);</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +			mutex_lock(&amp;iommu-&gt;lock);</span>
<span class=quote>&gt; +			iommu-&gt;dirty_page_tracking = true;</span>
<span class=quote>&gt; +			ret = vfio_dma_all_bitmap_alloc(iommu, iommu_pgsizes);</span>

So dirty page tracking is enabled even if we fail to allocate all the
bitmaps?  Shouldn't this return an error if dirty tracking is already
enabled?
<span class=quote>
&gt; +			mutex_unlock(&amp;iommu-&gt;lock);</span>
<span class=quote>&gt; +			return ret;</span>
<span class=quote>&gt; +		} else if (range.flags &amp; VFIO_IOMMU_DIRTY_PAGES_FLAG_STOP) {</span>
<span class=quote>&gt; +			mutex_lock(&amp;iommu-&gt;lock);</span>
<span class=quote>&gt; +			iommu-&gt;dirty_page_tracking = false;</span>

Shouldn't we only allow STOP if tracking is enabled?
<span class=quote>
&gt; +			vfio_dma_all_bitmap_free(iommu);</span>

Here's where that user induced double free enters the picture.
<span class=quote>
&gt; +			vfio_remove_unpinned_from_dma_list(iommu);</span>
<span class=quote>&gt; +			mutex_unlock(&amp;iommu-&gt;lock);</span>
<span class=quote>&gt; +			return 0;</span>
<span class=quote>&gt; +		} else if (range.flags &amp;</span>
<span class=quote>&gt; +				 VFIO_IOMMU_DIRTY_PAGES_FLAG_GET_BITMAP) {</span>
<span class=quote>&gt; +			long bsize;</span>
<span class=quote>&gt; +			unsigned long pgshift = __ffs(range.pgsize);</span>
<span class=quote>&gt; +			uint64_t iommu_pgsizes = vfio_pgsize_bitmap(iommu);</span>
<span class=quote>&gt; +			uint64_t iommu_pgmask =</span>
<span class=quote>&gt; +				 ((uint64_t)1 &lt;&lt; __ffs(iommu_pgsizes)) - 1;</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +			if ((range.pgsize &amp; iommu_pgsizes) != range.pgsize)</span>
<span class=quote>&gt; +				return -EINVAL;</span>
<span class=quote>&gt; +			if (range.iova &amp; iommu_pgmask)</span>
<span class=quote>&gt; +				return -EINVAL;</span>
<span class=quote>&gt; +			if (!range.size || range.size &amp; iommu_pgmask)</span>
<span class=quote>&gt; +				return -EINVAL;</span>
<span class=quote>&gt; +			if (range.iova + range.size &lt; range.iova)</span>
<span class=quote>&gt; +				return -EINVAL;</span>
<span class=quote>&gt; +			if (!access_ok((void __user *)range.bitmap,</span>
<span class=quote>&gt; +				       range.bitmap_size))</span>
<span class=quote>&gt; +				return -EINVAL;</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +			bsize = verify_bitmap_size(range.size &gt;&gt; pgshift,</span>
<span class=quote>&gt; +						   range.bitmap_size);</span>
<span class=quote>&gt; +			if (bsize &lt; 0)</span>
<span class=quote>&gt; +				return bsize;</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +			mutex_lock(&amp;iommu-&gt;lock);</span>
<span class=quote>&gt; +			if (iommu-&gt;dirty_page_tracking)</span>
<span class=quote>&gt; +				ret = vfio_iova_dirty_bitmap(iommu, range.iova,</span>
<span class=quote>&gt; +					 range.size, range.pgsize,</span>
<span class=quote>&gt; +					 (unsigned char __user *)range.bitmap);</span>
<span class=quote>&gt; +			else</span>
<span class=quote>&gt; +				ret = -EINVAL;</span>
<span class=quote>&gt; +			mutex_unlock(&amp;iommu-&gt;lock);</span>
<span class=quote>&gt; +</span>
<span class=quote>&gt; +			return ret;</span>
<span class=quote>&gt; +		}</span>
<span class=quote>&gt;  	}</span>
<span class=quote>&gt;  </span>
<span class=quote>&gt;  	return -ENOTTY;</span>

Thanks,
Alex
</pre>
</div>
<a name=23147431></a>
<div class=comment>
<div class=meta>
 <span><a href="https://patchwork.kernel.org/project/qemu-devel/list/?submitter=7781">Alex Williamson</a></span>
 <span class=pull-right>Feb. 10, 2020, 7:44 p.m. UTC | <a href=https://patchwork.kernel.org/comment/23147431/>#3</a></span>
</div>
<pre class=content>On Mon, 10 Feb 2020 04:49:54 -0500
Yan Zhao &lt;yan.y.zhao@intel.com&gt; wrote:
<span class=quote>
&gt; On Sat, Feb 08, 2020 at 03:42:31AM +0800, Kirti Wankhede wrote:</span>
<span class=quote>&gt; &gt; VFIO_IOMMU_DIRTY_PAGES ioctl performs three operations:</span>
<span class=quote>&gt; &gt; - Start pinned and unpinned pages tracking while migration is active</span>
<span class=quote>&gt; &gt; - Stop pinned and unpinned dirty pages tracking. This is also used to</span>
<span class=quote>&gt; &gt;   stop dirty pages tracking if migration failed or cancelled.</span>
<span class=quote>&gt; &gt; - Get dirty pages bitmap. This ioctl returns bitmap of dirty pages, its</span>
<span class=quote>&gt; &gt;   user space application responsibility to copy content of dirty pages</span>
<span class=quote>&gt; &gt;   from source to destination during migration.</span>
<span class=quote>&gt; &gt; </span>
<span class=quote>&gt; &gt; To prevent DoS attack, memory for bitmap is allocated per vfio_dma</span>
<span class=quote>&gt; &gt; structure. Bitmap size is calculated considering smallest supported page</span>
<span class=quote>&gt; &gt; size. Bitmap is allocated when dirty logging is enabled for those</span>
<span class=quote>&gt; &gt; vfio_dmas whose vpfn list is not empty or whole range is mapped, in</span>
<span class=quote>&gt; &gt; case of pass-through device.</span>
<span class=quote>&gt; &gt; </span>
<span class=quote>&gt; &gt; There could be multiple option as to when bitmap should be populated:</span>
<span class=quote>&gt; &gt; * Polulate bitmap for already pinned pages when bitmap is allocated for</span>
<span class=quote>&gt; &gt;   a vfio_dma with the smallest supported page size. Updates bitmap from</span>
<span class=quote>&gt; &gt;   page pinning and unpinning functions. When user application queries</span>
<span class=quote>&gt; &gt;   bitmap, check if requested page size is same as page size used to</span>
<span class=quote>&gt; &gt;   populated bitmap. If it is equal, copy bitmap. But if not equal,</span>
<span class=quote>&gt; &gt;   re-populated bitmap according to requested page size and then copy to</span>
<span class=quote>&gt; &gt;   user.</span>
<span class=quote>&gt; &gt;   Pros: Bitmap gets populated on the fly after dirty tracking has</span>
<span class=quote>&gt; &gt;         started.</span>
<span class=quote>&gt; &gt;   Cons: If requested page size is different than smallest supported</span>
<span class=quote>&gt; &gt;         page size, then bitmap has to be re-populated again, with</span>
<span class=quote>&gt; &gt;         additional overhead of allocating bitmap memory again for</span>
<span class=quote>&gt; &gt;         re-population of bitmap.</span>
<span class=quote>&gt; &gt; </span>
<span class=quote>&gt; &gt; * Populate bitmap when bitmap is queried by user application.</span>
<span class=quote>&gt; &gt;   Pros: Bitmap is populated with requested page size. This eliminates</span>
<span class=quote>&gt; &gt;         the need to re-populate bitmap if requested page size is</span>
<span class=quote>&gt; &gt;         different than smallest supported pages size.</span>
<span class=quote>&gt; &gt;   Cons: There is one time processing time, when bitmap is queried.</span>
<span class=quote>&gt; &gt; </span>
<span class=quote>&gt; &gt; I prefer later option with simple logic and to eliminate over-head of</span>
<span class=quote>&gt; &gt; bitmap repopulation in case of differnt page sizes. Later option is</span>
<span class=quote>&gt; &gt; implemented in this patch.</span>
<span class=quote>&gt; &gt; </span>
<span class=quote>&gt; &gt; Signed-off-by: Kirti Wankhede &lt;kwankhede@nvidia.com&gt;</span>
<span class=quote>&gt; &gt; Reviewed-by: Neo Jia &lt;cjia@nvidia.com&gt;</span>
<span class=quote>&gt; &gt; ---</span>
<span class=quote>&gt; &gt;  drivers/vfio/vfio_iommu_type1.c | 299 ++++++++++++++++++++++++++++++++++++++--</span>
<span class=quote>&gt; &gt;  1 file changed, 287 insertions(+), 12 deletions(-)</span>
<span class=quote>&gt; &gt; </span>
<span class=quote>&gt; &gt; diff --git a/drivers/vfio/vfio_iommu_type1.c b/drivers/vfio/vfio_iommu_type1.c</span>
<span class=quote>&gt; &gt; index d386461e5d11..df358dc1c85b 100644</span>
<span class=quote>&gt; &gt; --- a/drivers/vfio/vfio_iommu_type1.c</span>
<span class=quote>&gt; &gt; +++ b/drivers/vfio/vfio_iommu_type1.c</span>
[snip]
<span class=quote>&gt; &gt; @@ -830,6 +924,113 @@ static unsigned long vfio_pgsize_bitmap(struct vfio_iommu *iommu)</span>
<span class=quote>&gt; &gt;  	return bitmap;</span>
<span class=quote>&gt; &gt;  }</span>
<span class=quote>&gt; &gt;  </span>
<span class=quote>&gt; &gt; +static int vfio_iova_dirty_bitmap(struct vfio_iommu *iommu, dma_addr_t iova,</span>
<span class=quote>&gt; &gt; +				  size_t size, uint64_t pgsize,</span>
<span class=quote>&gt; &gt; +				  unsigned char __user *bitmap)</span>
<span class=quote>&gt; &gt; +{</span>
<span class=quote>&gt; &gt; +	struct vfio_dma *dma;</span>
<span class=quote>&gt; &gt; +	dma_addr_t i = iova, iova_limit;</span>
<span class=quote>&gt; &gt; +	unsigned int bsize, nbits = 0, l = 0;</span>
<span class=quote>&gt; &gt; +	unsigned long pgshift = __ffs(pgsize);</span>
<span class=quote>&gt; &gt; +</span>
<span class=quote>&gt; &gt; +	while ((dma = vfio_find_dma(iommu, i, pgsize))) {</span>
<span class=quote>&gt; &gt; +		int ret, j;</span>
<span class=quote>&gt; &gt; +		unsigned int npages = 0, shift = 0;</span>
<span class=quote>&gt; &gt; +		unsigned char temp = 0;</span>
<span class=quote>&gt; &gt; +</span>
<span class=quote>&gt; &gt; +		/* mark all pages dirty if all pages are pinned and mapped. */</span>
<span class=quote>&gt; &gt; +		if (dma-&gt;iommu_mapped) {</span>
<span class=quote>&gt; &gt; +			iova_limit = min(dma-&gt;iova + dma-&gt;size, iova + size);</span>
<span class=quote>&gt; &gt; +			npages = iova_limit/pgsize;</span>
<span class=quote>&gt; &gt; +			bitmap_set(dma-&gt;bitmap, 0, npages);  </span>
<span class=quote>&gt; for pass-through devices, it's not good to always return all pinned pages as</span>
<span class=quote>&gt; dirty. could it also call vfio_pin_pages to track dirty pages? or any</span>
<span class=quote>&gt; other interface provided to do that?</span>

See patch 7/7.  Thanks,

Alex
</pre>
</div>
<a name=23147915></a>
<div class=comment>
<div class=meta>
 <span><a href="https://patchwork.kernel.org/project/qemu-devel/list/?submitter=182909">Yan Zhao</a></span>
 <span class=pull-right>Feb. 11, 2020, 2:52 a.m. UTC | <a href=https://patchwork.kernel.org/comment/23147915/>#4</a></span>
</div>
<pre class=content>On Tue, Feb 11, 2020 at 03:44:54AM +0800, Alex Williamson wrote:
<span class=quote>&gt; On Mon, 10 Feb 2020 04:49:54 -0500</span>
<span class=quote>&gt; Yan Zhao &lt;yan.y.zhao@intel.com&gt; wrote:</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; &gt; On Sat, Feb 08, 2020 at 03:42:31AM +0800, Kirti Wankhede wrote:</span>
<span class=quote>&gt; &gt; &gt; VFIO_IOMMU_DIRTY_PAGES ioctl performs three operations:</span>
<span class=quote>&gt; &gt; &gt; - Start pinned and unpinned pages tracking while migration is active</span>
<span class=quote>&gt; &gt; &gt; - Stop pinned and unpinned dirty pages tracking. This is also used to</span>
<span class=quote>&gt; &gt; &gt;   stop dirty pages tracking if migration failed or cancelled.</span>
<span class=quote>&gt; &gt; &gt; - Get dirty pages bitmap. This ioctl returns bitmap of dirty pages, its</span>
<span class=quote>&gt; &gt; &gt;   user space application responsibility to copy content of dirty pages</span>
<span class=quote>&gt; &gt; &gt;   from source to destination during migration.</span>
<span class=quote>&gt; &gt; &gt; </span>
<span class=quote>&gt; &gt; &gt; To prevent DoS attack, memory for bitmap is allocated per vfio_dma</span>
<span class=quote>&gt; &gt; &gt; structure. Bitmap size is calculated considering smallest supported page</span>
<span class=quote>&gt; &gt; &gt; size. Bitmap is allocated when dirty logging is enabled for those</span>
<span class=quote>&gt; &gt; &gt; vfio_dmas whose vpfn list is not empty or whole range is mapped, in</span>
<span class=quote>&gt; &gt; &gt; case of pass-through device.</span>
<span class=quote>&gt; &gt; &gt; </span>
<span class=quote>&gt; &gt; &gt; There could be multiple option as to when bitmap should be populated:</span>
<span class=quote>&gt; &gt; &gt; * Polulate bitmap for already pinned pages when bitmap is allocated for</span>
<span class=quote>&gt; &gt; &gt;   a vfio_dma with the smallest supported page size. Updates bitmap from</span>
<span class=quote>&gt; &gt; &gt;   page pinning and unpinning functions. When user application queries</span>
<span class=quote>&gt; &gt; &gt;   bitmap, check if requested page size is same as page size used to</span>
<span class=quote>&gt; &gt; &gt;   populated bitmap. If it is equal, copy bitmap. But if not equal,</span>
<span class=quote>&gt; &gt; &gt;   re-populated bitmap according to requested page size and then copy to</span>
<span class=quote>&gt; &gt; &gt;   user.</span>
<span class=quote>&gt; &gt; &gt;   Pros: Bitmap gets populated on the fly after dirty tracking has</span>
<span class=quote>&gt; &gt; &gt;         started.</span>
<span class=quote>&gt; &gt; &gt;   Cons: If requested page size is different than smallest supported</span>
<span class=quote>&gt; &gt; &gt;         page size, then bitmap has to be re-populated again, with</span>
<span class=quote>&gt; &gt; &gt;         additional overhead of allocating bitmap memory again for</span>
<span class=quote>&gt; &gt; &gt;         re-population of bitmap.</span>
<span class=quote>&gt; &gt; &gt; </span>
<span class=quote>&gt; &gt; &gt; * Populate bitmap when bitmap is queried by user application.</span>
<span class=quote>&gt; &gt; &gt;   Pros: Bitmap is populated with requested page size. This eliminates</span>
<span class=quote>&gt; &gt; &gt;         the need to re-populate bitmap if requested page size is</span>
<span class=quote>&gt; &gt; &gt;         different than smallest supported pages size.</span>
<span class=quote>&gt; &gt; &gt;   Cons: There is one time processing time, when bitmap is queried.</span>
<span class=quote>&gt; &gt; &gt; </span>
<span class=quote>&gt; &gt; &gt; I prefer later option with simple logic and to eliminate over-head of</span>
<span class=quote>&gt; &gt; &gt; bitmap repopulation in case of differnt page sizes. Later option is</span>
<span class=quote>&gt; &gt; &gt; implemented in this patch.</span>
<span class=quote>&gt; &gt; &gt; </span>
<span class=quote>&gt; &gt; &gt; Signed-off-by: Kirti Wankhede &lt;kwankhede@nvidia.com&gt;</span>
<span class=quote>&gt; &gt; &gt; Reviewed-by: Neo Jia &lt;cjia@nvidia.com&gt;</span>
<span class=quote>&gt; &gt; &gt; ---</span>
<span class=quote>&gt; &gt; &gt;  drivers/vfio/vfio_iommu_type1.c | 299 ++++++++++++++++++++++++++++++++++++++--</span>
<span class=quote>&gt; &gt; &gt;  1 file changed, 287 insertions(+), 12 deletions(-)</span>
<span class=quote>&gt; &gt; &gt; </span>
<span class=quote>&gt; &gt; &gt; diff --git a/drivers/vfio/vfio_iommu_type1.c b/drivers/vfio/vfio_iommu_type1.c</span>
<span class=quote>&gt; &gt; &gt; index d386461e5d11..df358dc1c85b 100644</span>
<span class=quote>&gt; &gt; &gt; --- a/drivers/vfio/vfio_iommu_type1.c</span>
<span class=quote>&gt; &gt; &gt; +++ b/drivers/vfio/vfio_iommu_type1.c</span>
<span class=quote>&gt; [snip]</span>
<span class=quote>&gt; &gt; &gt; @@ -830,6 +924,113 @@ static unsigned long vfio_pgsize_bitmap(struct vfio_iommu *iommu)</span>
<span class=quote>&gt; &gt; &gt;  	return bitmap;</span>
<span class=quote>&gt; &gt; &gt;  }</span>
<span class=quote>&gt; &gt; &gt;  </span>
<span class=quote>&gt; &gt; &gt; +static int vfio_iova_dirty_bitmap(struct vfio_iommu *iommu, dma_addr_t iova,</span>
<span class=quote>&gt; &gt; &gt; +				  size_t size, uint64_t pgsize,</span>
<span class=quote>&gt; &gt; &gt; +				  unsigned char __user *bitmap)</span>
<span class=quote>&gt; &gt; &gt; +{</span>
<span class=quote>&gt; &gt; &gt; +	struct vfio_dma *dma;</span>
<span class=quote>&gt; &gt; &gt; +	dma_addr_t i = iova, iova_limit;</span>
<span class=quote>&gt; &gt; &gt; +	unsigned int bsize, nbits = 0, l = 0;</span>
<span class=quote>&gt; &gt; &gt; +	unsigned long pgshift = __ffs(pgsize);</span>
<span class=quote>&gt; &gt; &gt; +</span>
<span class=quote>&gt; &gt; &gt; +	while ((dma = vfio_find_dma(iommu, i, pgsize))) {</span>
<span class=quote>&gt; &gt; &gt; +		int ret, j;</span>
<span class=quote>&gt; &gt; &gt; +		unsigned int npages = 0, shift = 0;</span>
<span class=quote>&gt; &gt; &gt; +		unsigned char temp = 0;</span>
<span class=quote>&gt; &gt; &gt; +</span>
<span class=quote>&gt; &gt; &gt; +		/* mark all pages dirty if all pages are pinned and mapped. */</span>
<span class=quote>&gt; &gt; &gt; +		if (dma-&gt;iommu_mapped) {</span>
<span class=quote>&gt; &gt; &gt; +			iova_limit = min(dma-&gt;iova + dma-&gt;size, iova + size);</span>
<span class=quote>&gt; &gt; &gt; +			npages = iova_limit/pgsize;</span>
<span class=quote>&gt; &gt; &gt; +			bitmap_set(dma-&gt;bitmap, 0, npages);  </span>
<span class=quote>&gt; &gt; for pass-through devices, it's not good to always return all pinned pages as</span>
<span class=quote>&gt; &gt; dirty. could it also call vfio_pin_pages to track dirty pages? or any</span>
<span class=quote>&gt; &gt; other interface provided to do that?</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; See patch 7/7.  Thanks,</span>
<span class=quote>&gt;</span>
hi Alex and Kirti,
for pass-through devices, though patch 7/7 enables the vendor driver to
set dirty pages by calling vfio_pin_pages, however, its overhead is much
higher than the previous way of generating a bitmap directly to user.
And it also requires pass-through device vendor driver to track guest
operations to know when to call vfio_pin_pages.
There are still use cases like a pass-through device is able to track
dirty pages in its hardware buffer, so is there a way for it pass its
dirty bitmap to user?

Thanks
Yan
</pre>
</div>
<a name=23147955></a>
<div class=comment>
<div class=meta>
 <span><a href="https://patchwork.kernel.org/project/qemu-devel/list/?submitter=7781">Alex Williamson</a></span>
 <span class=pull-right>Feb. 11, 2020, 3:45 a.m. UTC | <a href=https://patchwork.kernel.org/comment/23147955/>#5</a></span>
</div>
<pre class=content>On Mon, 10 Feb 2020 21:52:51 -0500
Yan Zhao &lt;yan.y.zhao@intel.com&gt; wrote:
<span class=quote>
&gt; On Tue, Feb 11, 2020 at 03:44:54AM +0800, Alex Williamson wrote:</span>
<span class=quote>&gt; &gt; On Mon, 10 Feb 2020 04:49:54 -0500</span>
<span class=quote>&gt; &gt; Yan Zhao &lt;yan.y.zhao@intel.com&gt; wrote:</span>
<span class=quote>&gt; &gt;   </span>
<span class=quote>&gt; &gt; &gt; On Sat, Feb 08, 2020 at 03:42:31AM +0800, Kirti Wankhede wrote:  </span>
<span class=quote>&gt; &gt; &gt; &gt; VFIO_IOMMU_DIRTY_PAGES ioctl performs three operations:</span>
<span class=quote>&gt; &gt; &gt; &gt; - Start pinned and unpinned pages tracking while migration is active</span>
<span class=quote>&gt; &gt; &gt; &gt; - Stop pinned and unpinned dirty pages tracking. This is also used to</span>
<span class=quote>&gt; &gt; &gt; &gt;   stop dirty pages tracking if migration failed or cancelled.</span>
<span class=quote>&gt; &gt; &gt; &gt; - Get dirty pages bitmap. This ioctl returns bitmap of dirty pages, its</span>
<span class=quote>&gt; &gt; &gt; &gt;   user space application responsibility to copy content of dirty pages</span>
<span class=quote>&gt; &gt; &gt; &gt;   from source to destination during migration.</span>
<span class=quote>&gt; &gt; &gt; &gt; </span>
<span class=quote>&gt; &gt; &gt; &gt; To prevent DoS attack, memory for bitmap is allocated per vfio_dma</span>
<span class=quote>&gt; &gt; &gt; &gt; structure. Bitmap size is calculated considering smallest supported page</span>
<span class=quote>&gt; &gt; &gt; &gt; size. Bitmap is allocated when dirty logging is enabled for those</span>
<span class=quote>&gt; &gt; &gt; &gt; vfio_dmas whose vpfn list is not empty or whole range is mapped, in</span>
<span class=quote>&gt; &gt; &gt; &gt; case of pass-through device.</span>
<span class=quote>&gt; &gt; &gt; &gt; </span>
<span class=quote>&gt; &gt; &gt; &gt; There could be multiple option as to when bitmap should be populated:</span>
<span class=quote>&gt; &gt; &gt; &gt; * Polulate bitmap for already pinned pages when bitmap is allocated for</span>
<span class=quote>&gt; &gt; &gt; &gt;   a vfio_dma with the smallest supported page size. Updates bitmap from</span>
<span class=quote>&gt; &gt; &gt; &gt;   page pinning and unpinning functions. When user application queries</span>
<span class=quote>&gt; &gt; &gt; &gt;   bitmap, check if requested page size is same as page size used to</span>
<span class=quote>&gt; &gt; &gt; &gt;   populated bitmap. If it is equal, copy bitmap. But if not equal,</span>
<span class=quote>&gt; &gt; &gt; &gt;   re-populated bitmap according to requested page size and then copy to</span>
<span class=quote>&gt; &gt; &gt; &gt;   user.</span>
<span class=quote>&gt; &gt; &gt; &gt;   Pros: Bitmap gets populated on the fly after dirty tracking has</span>
<span class=quote>&gt; &gt; &gt; &gt;         started.</span>
<span class=quote>&gt; &gt; &gt; &gt;   Cons: If requested page size is different than smallest supported</span>
<span class=quote>&gt; &gt; &gt; &gt;         page size, then bitmap has to be re-populated again, with</span>
<span class=quote>&gt; &gt; &gt; &gt;         additional overhead of allocating bitmap memory again for</span>
<span class=quote>&gt; &gt; &gt; &gt;         re-population of bitmap.</span>
<span class=quote>&gt; &gt; &gt; &gt; </span>
<span class=quote>&gt; &gt; &gt; &gt; * Populate bitmap when bitmap is queried by user application.</span>
<span class=quote>&gt; &gt; &gt; &gt;   Pros: Bitmap is populated with requested page size. This eliminates</span>
<span class=quote>&gt; &gt; &gt; &gt;         the need to re-populate bitmap if requested page size is</span>
<span class=quote>&gt; &gt; &gt; &gt;         different than smallest supported pages size.</span>
<span class=quote>&gt; &gt; &gt; &gt;   Cons: There is one time processing time, when bitmap is queried.</span>
<span class=quote>&gt; &gt; &gt; &gt; </span>
<span class=quote>&gt; &gt; &gt; &gt; I prefer later option with simple logic and to eliminate over-head of</span>
<span class=quote>&gt; &gt; &gt; &gt; bitmap repopulation in case of differnt page sizes. Later option is</span>
<span class=quote>&gt; &gt; &gt; &gt; implemented in this patch.</span>
<span class=quote>&gt; &gt; &gt; &gt; </span>
<span class=quote>&gt; &gt; &gt; &gt; Signed-off-by: Kirti Wankhede &lt;kwankhede@nvidia.com&gt;</span>
<span class=quote>&gt; &gt; &gt; &gt; Reviewed-by: Neo Jia &lt;cjia@nvidia.com&gt;</span>
<span class=quote>&gt; &gt; &gt; &gt; ---</span>
<span class=quote>&gt; &gt; &gt; &gt;  drivers/vfio/vfio_iommu_type1.c | 299 ++++++++++++++++++++++++++++++++++++++--</span>
<span class=quote>&gt; &gt; &gt; &gt;  1 file changed, 287 insertions(+), 12 deletions(-)</span>
<span class=quote>&gt; &gt; &gt; &gt; </span>
<span class=quote>&gt; &gt; &gt; &gt; diff --git a/drivers/vfio/vfio_iommu_type1.c b/drivers/vfio/vfio_iommu_type1.c</span>
<span class=quote>&gt; &gt; &gt; &gt; index d386461e5d11..df358dc1c85b 100644</span>
<span class=quote>&gt; &gt; &gt; &gt; --- a/drivers/vfio/vfio_iommu_type1.c</span>
<span class=quote>&gt; &gt; &gt; &gt; +++ b/drivers/vfio/vfio_iommu_type1.c  </span>
<span class=quote>&gt; &gt; [snip]  </span>
<span class=quote>&gt; &gt; &gt; &gt; @@ -830,6 +924,113 @@ static unsigned long vfio_pgsize_bitmap(struct vfio_iommu *iommu)</span>
<span class=quote>&gt; &gt; &gt; &gt;  	return bitmap;</span>
<span class=quote>&gt; &gt; &gt; &gt;  }</span>
<span class=quote>&gt; &gt; &gt; &gt;  </span>
<span class=quote>&gt; &gt; &gt; &gt; +static int vfio_iova_dirty_bitmap(struct vfio_iommu *iommu, dma_addr_t iova,</span>
<span class=quote>&gt; &gt; &gt; &gt; +				  size_t size, uint64_t pgsize,</span>
<span class=quote>&gt; &gt; &gt; &gt; +				  unsigned char __user *bitmap)</span>
<span class=quote>&gt; &gt; &gt; &gt; +{</span>
<span class=quote>&gt; &gt; &gt; &gt; +	struct vfio_dma *dma;</span>
<span class=quote>&gt; &gt; &gt; &gt; +	dma_addr_t i = iova, iova_limit;</span>
<span class=quote>&gt; &gt; &gt; &gt; +	unsigned int bsize, nbits = 0, l = 0;</span>
<span class=quote>&gt; &gt; &gt; &gt; +	unsigned long pgshift = __ffs(pgsize);</span>
<span class=quote>&gt; &gt; &gt; &gt; +</span>
<span class=quote>&gt; &gt; &gt; &gt; +	while ((dma = vfio_find_dma(iommu, i, pgsize))) {</span>
<span class=quote>&gt; &gt; &gt; &gt; +		int ret, j;</span>
<span class=quote>&gt; &gt; &gt; &gt; +		unsigned int npages = 0, shift = 0;</span>
<span class=quote>&gt; &gt; &gt; &gt; +		unsigned char temp = 0;</span>
<span class=quote>&gt; &gt; &gt; &gt; +</span>
<span class=quote>&gt; &gt; &gt; &gt; +		/* mark all pages dirty if all pages are pinned and mapped. */</span>
<span class=quote>&gt; &gt; &gt; &gt; +		if (dma-&gt;iommu_mapped) {</span>
<span class=quote>&gt; &gt; &gt; &gt; +			iova_limit = min(dma-&gt;iova + dma-&gt;size, iova + size);</span>
<span class=quote>&gt; &gt; &gt; &gt; +			npages = iova_limit/pgsize;</span>
<span class=quote>&gt; &gt; &gt; &gt; +			bitmap_set(dma-&gt;bitmap, 0, npages);    </span>
<span class=quote>&gt; &gt; &gt; for pass-through devices, it's not good to always return all pinned pages as</span>
<span class=quote>&gt; &gt; &gt; dirty. could it also call vfio_pin_pages to track dirty pages? or any</span>
<span class=quote>&gt; &gt; &gt; other interface provided to do that?  </span>
<span class=quote>&gt; &gt; </span>
<span class=quote>&gt; &gt; See patch 7/7.  Thanks,</span>
<span class=quote>&gt; &gt;  </span>
<span class=quote>&gt; hi Alex and Kirti,</span>
<span class=quote>&gt; for pass-through devices, though patch 7/7 enables the vendor driver to</span>
<span class=quote>&gt; set dirty pages by calling vfio_pin_pages, however, its overhead is much</span>
<span class=quote>&gt; higher than the previous way of generating a bitmap directly to user.</span>
<span class=quote>&gt; And it also requires pass-through device vendor driver to track guest</span>
<span class=quote>&gt; operations to know when to call vfio_pin_pages.</span>
<span class=quote>&gt; There are still use cases like a pass-through device is able to track</span>
<span class=quote>&gt; dirty pages in its hardware buffer, so is there a way for it pass its</span>
<span class=quote>&gt; dirty bitmap to user?</span>

Not currently and this sounds like another argument in favor of using
the dirty bitmap per vfio_dma to directly track dirty pages.
Passthrough drivers could be provided an interface to set dirty bits
which could be merged with pfn list entries when the user requests the
bitmap, rather than requiring passthrough drivers to unnecessarily
allocate pfn list entries directly.  Thanks,

Alex
</pre>
</div>
<a name=23147987></a>
<div class=comment>
<div class=meta>
 <span><a href="https://patchwork.kernel.org/project/qemu-devel/list/?submitter=182909">Yan Zhao</a></span>
 <span class=pull-right>Feb. 11, 2020, 4:11 a.m. UTC | <a href=https://patchwork.kernel.org/comment/23147987/>#6</a></span>
</div>
<pre class=content>On Tue, Feb 11, 2020 at 11:45:43AM +0800, Alex Williamson wrote:
<span class=quote>&gt; On Mon, 10 Feb 2020 21:52:51 -0500</span>
<span class=quote>&gt; Yan Zhao &lt;yan.y.zhao@intel.com&gt; wrote:</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; &gt; On Tue, Feb 11, 2020 at 03:44:54AM +0800, Alex Williamson wrote:</span>
<span class=quote>&gt; &gt; &gt; On Mon, 10 Feb 2020 04:49:54 -0500</span>
<span class=quote>&gt; &gt; &gt; Yan Zhao &lt;yan.y.zhao@intel.com&gt; wrote:</span>
<span class=quote>&gt; &gt; &gt;   </span>
<span class=quote>&gt; &gt; &gt; &gt; On Sat, Feb 08, 2020 at 03:42:31AM +0800, Kirti Wankhede wrote:  </span>
<span class=quote>&gt; &gt; &gt; &gt; &gt; VFIO_IOMMU_DIRTY_PAGES ioctl performs three operations:</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt; - Start pinned and unpinned pages tracking while migration is active</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt; - Stop pinned and unpinned dirty pages tracking. This is also used to</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt;   stop dirty pages tracking if migration failed or cancelled.</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt; - Get dirty pages bitmap. This ioctl returns bitmap of dirty pages, its</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt;   user space application responsibility to copy content of dirty pages</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt;   from source to destination during migration.</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt; </span>
<span class=quote>&gt; &gt; &gt; &gt; &gt; To prevent DoS attack, memory for bitmap is allocated per vfio_dma</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt; structure. Bitmap size is calculated considering smallest supported page</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt; size. Bitmap is allocated when dirty logging is enabled for those</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt; vfio_dmas whose vpfn list is not empty or whole range is mapped, in</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt; case of pass-through device.</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt; </span>
<span class=quote>&gt; &gt; &gt; &gt; &gt; There could be multiple option as to when bitmap should be populated:</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt; * Polulate bitmap for already pinned pages when bitmap is allocated for</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt;   a vfio_dma with the smallest supported page size. Updates bitmap from</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt;   page pinning and unpinning functions. When user application queries</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt;   bitmap, check if requested page size is same as page size used to</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt;   populated bitmap. If it is equal, copy bitmap. But if not equal,</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt;   re-populated bitmap according to requested page size and then copy to</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt;   user.</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt;   Pros: Bitmap gets populated on the fly after dirty tracking has</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt;         started.</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt;   Cons: If requested page size is different than smallest supported</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt;         page size, then bitmap has to be re-populated again, with</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt;         additional overhead of allocating bitmap memory again for</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt;         re-population of bitmap.</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt; </span>
<span class=quote>&gt; &gt; &gt; &gt; &gt; * Populate bitmap when bitmap is queried by user application.</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt;   Pros: Bitmap is populated with requested page size. This eliminates</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt;         the need to re-populate bitmap if requested page size is</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt;         different than smallest supported pages size.</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt;   Cons: There is one time processing time, when bitmap is queried.</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt; </span>
<span class=quote>&gt; &gt; &gt; &gt; &gt; I prefer later option with simple logic and to eliminate over-head of</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt; bitmap repopulation in case of differnt page sizes. Later option is</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt; implemented in this patch.</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt; </span>
<span class=quote>&gt; &gt; &gt; &gt; &gt; Signed-off-by: Kirti Wankhede &lt;kwankhede@nvidia.com&gt;</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt; Reviewed-by: Neo Jia &lt;cjia@nvidia.com&gt;</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt; ---</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt;  drivers/vfio/vfio_iommu_type1.c | 299 ++++++++++++++++++++++++++++++++++++++--</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt;  1 file changed, 287 insertions(+), 12 deletions(-)</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt; </span>
<span class=quote>&gt; &gt; &gt; &gt; &gt; diff --git a/drivers/vfio/vfio_iommu_type1.c b/drivers/vfio/vfio_iommu_type1.c</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt; index d386461e5d11..df358dc1c85b 100644</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt; --- a/drivers/vfio/vfio_iommu_type1.c</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt; +++ b/drivers/vfio/vfio_iommu_type1.c  </span>
<span class=quote>&gt; &gt; &gt; [snip]  </span>
<span class=quote>&gt; &gt; &gt; &gt; &gt; @@ -830,6 +924,113 @@ static unsigned long vfio_pgsize_bitmap(struct vfio_iommu *iommu)</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt;  	return bitmap;</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt;  }</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt;  </span>
<span class=quote>&gt; &gt; &gt; &gt; &gt; +static int vfio_iova_dirty_bitmap(struct vfio_iommu *iommu, dma_addr_t iova,</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt; +				  size_t size, uint64_t pgsize,</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt; +				  unsigned char __user *bitmap)</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt; +{</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt; +	struct vfio_dma *dma;</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt; +	dma_addr_t i = iova, iova_limit;</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt; +	unsigned int bsize, nbits = 0, l = 0;</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt; +	unsigned long pgshift = __ffs(pgsize);</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt; +</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt; +	while ((dma = vfio_find_dma(iommu, i, pgsize))) {</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt; +		int ret, j;</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt; +		unsigned int npages = 0, shift = 0;</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt; +		unsigned char temp = 0;</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt; +</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt; +		/* mark all pages dirty if all pages are pinned and mapped. */</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt; +		if (dma-&gt;iommu_mapped) {</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt; +			iova_limit = min(dma-&gt;iova + dma-&gt;size, iova + size);</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt; +			npages = iova_limit/pgsize;</span>
<span class=quote>&gt; &gt; &gt; &gt; &gt; +			bitmap_set(dma-&gt;bitmap, 0, npages);    </span>
<span class=quote>&gt; &gt; &gt; &gt; for pass-through devices, it's not good to always return all pinned pages as</span>
<span class=quote>&gt; &gt; &gt; &gt; dirty. could it also call vfio_pin_pages to track dirty pages? or any</span>
<span class=quote>&gt; &gt; &gt; &gt; other interface provided to do that?  </span>
<span class=quote>&gt; &gt; &gt; </span>
<span class=quote>&gt; &gt; &gt; See patch 7/7.  Thanks,</span>
<span class=quote>&gt; &gt; &gt;  </span>
<span class=quote>&gt; &gt; hi Alex and Kirti,</span>
<span class=quote>&gt; &gt; for pass-through devices, though patch 7/7 enables the vendor driver to</span>
<span class=quote>&gt; &gt; set dirty pages by calling vfio_pin_pages, however, its overhead is much</span>
<span class=quote>&gt; &gt; higher than the previous way of generating a bitmap directly to user.</span>
<span class=quote>&gt; &gt; And it also requires pass-through device vendor driver to track guest</span>
<span class=quote>&gt; &gt; operations to know when to call vfio_pin_pages.</span>
<span class=quote>&gt; &gt; There are still use cases like a pass-through device is able to track</span>
<span class=quote>&gt; &gt; dirty pages in its hardware buffer, so is there a way for it pass its</span>
<span class=quote>&gt; &gt; dirty bitmap to user?</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; Not currently and this sounds like another argument in favor of using</span>
<span class=quote>&gt; the dirty bitmap per vfio_dma to directly track dirty pages.</span>
it may need an interface to get max iova in all vfio_dma and then generate a
hardware bitmap for the whole guest system memory.
<span class=quote>
&gt; Passthrough drivers could be provided an interface to set dirty bits</span>
<span class=quote>&gt; which could be merged with pfn list entries when the user requests the</span>
<span class=quote>&gt; bitmap, rather than requiring passthrough drivers to unnecessarily</span>
<span class=quote>&gt; allocate pfn list entries directly.  Thanks,</span>
yes, it's better.
and for devices with ability to track dirty pages in hardware,
maybe an interface to let vfio know where is the hardware bitmap?

Thanks
Yan
</pre>
</div>
<a name=23153369></a>
<div class=comment>
<div class=meta>
 <span><a href="https://patchwork.kernel.org/project/qemu-devel/list/?submitter=153211">Kirti Wankhede</a></span>
 <span class=pull-right>Feb. 12, 2020, 8:56 p.m. UTC | <a href=https://patchwork.kernel.org/comment/23153369/>#7</a></span>
</div>
<pre class=content>On 2/10/2020 10:55 PM, Alex Williamson wrote:
<span class=quote>&gt; On Sat, 8 Feb 2020 01:12:31 +0530</span>
<span class=quote>&gt; Kirti Wankhede &lt;kwankhede@nvidia.com&gt; wrote:</span>
<span class=quote>&gt; </span>
<span class=quote>&gt;&gt; VFIO_IOMMU_DIRTY_PAGES ioctl performs three operations:</span>
<span class=quote>&gt;&gt; - Start pinned and unpinned pages tracking while migration is active</span>
<span class=quote>&gt;&gt; - Stop pinned and unpinned dirty pages tracking. This is also used to</span>
<span class=quote>&gt;&gt;    stop dirty pages tracking if migration failed or cancelled.</span>
<span class=quote>&gt;&gt; - Get dirty pages bitmap. This ioctl returns bitmap of dirty pages, its</span>
<span class=quote>&gt;&gt;    user space application responsibility to copy content of dirty pages</span>
<span class=quote>&gt;&gt;    from source to destination during migration.</span>
<span class=quote>&gt;&gt;</span>
<span class=quote>&gt;&gt; To prevent DoS attack, memory for bitmap is allocated per vfio_dma</span>
<span class=quote>&gt;&gt; structure. Bitmap size is calculated considering smallest supported page</span>
<span class=quote>&gt;&gt; size. Bitmap is allocated when dirty logging is enabled for those</span>
<span class=quote>&gt;&gt; vfio_dmas whose vpfn list is not empty or whole range is mapped, in</span>
<span class=quote>&gt;&gt; case of pass-through device.</span>
<span class=quote>&gt;&gt;</span>
<span class=quote>&gt;&gt; There could be multiple option as to when bitmap should be populated:</span>
<span class=quote>&gt;&gt; * Polulate bitmap for already pinned pages when bitmap is allocated for</span>
<span class=quote>&gt;&gt;    a vfio_dma with the smallest supported page size. Updates bitmap from</span>
<span class=quote>&gt;&gt;    page pinning and unpinning functions. When user application queries</span>
<span class=quote>&gt;&gt;    bitmap, check if requested page size is same as page size used to</span>
<span class=quote>&gt;&gt;    populated bitmap. If it is equal, copy bitmap. But if not equal,</span>
<span class=quote>&gt;&gt;    re-populated bitmap according to requested page size and then copy to</span>
<span class=quote>&gt;&gt;    user.</span>
<span class=quote>&gt;&gt;    Pros: Bitmap gets populated on the fly after dirty tracking has</span>
<span class=quote>&gt;&gt;          started.</span>
<span class=quote>&gt;&gt;    Cons: If requested page size is different than smallest supported</span>
<span class=quote>&gt;&gt;          page size, then bitmap has to be re-populated again, with</span>
<span class=quote>&gt;&gt;          additional overhead of allocating bitmap memory again for</span>
<span class=quote>&gt;&gt;          re-population of bitmap.</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; No memory needs to be allocated to re-populate the bitmap.  The bitmap</span>
<span class=quote>&gt; is clear-on-read and by tracking the bitmap in the smallest supported</span>
<span class=quote>&gt; page size we can guarantee that we can fit the user requested bitmap</span>
<span class=quote>&gt; size within the space occupied by that minimal page size range of the</span>
<span class=quote>&gt; bitmap.  Therefore we'd destructively translate the requested region of</span>
<span class=quote>&gt; the bitmap to a different page size, write it out to the user, and</span>
<span class=quote>&gt; clear it.  Also we expect userspace to use the minimum page size almost</span>
<span class=quote>&gt; exclusively, which is optimized by this approach as dirty bit tracking</span>
<span class=quote>&gt; is spread out over each page pinning operation.</span>
<span class=quote>&gt; </span>
<span class=quote>&gt;&gt;</span>
<span class=quote>&gt;&gt; * Populate bitmap when bitmap is queried by user application.</span>
<span class=quote>&gt;&gt;    Pros: Bitmap is populated with requested page size. This eliminates</span>
<span class=quote>&gt;&gt;          the need to re-populate bitmap if requested page size is</span>
<span class=quote>&gt;&gt;          different than smallest supported pages size.</span>
<span class=quote>&gt;&gt;    Cons: There is one time processing time, when bitmap is queried.</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; Another significant Con is that the vpfn list needs to track and manage</span>
<span class=quote>&gt; unpinned pages, which makes it more complex and intrusive.  The</span>
<span class=quote>&gt; previous option seems to have both time and complexity advantages,</span>
<span class=quote>&gt; especially in the case we expect to be most common of the user</span>
<span class=quote>&gt; accessing the bitmap with the minimum page size, ie. PAGE_SIZE.  It's</span>
<span class=quote>&gt; also not clear why we pre-allocate the bitmap at all with this approach.</span>
<span class=quote>&gt; </span>
<span class=quote>&gt;&gt; I prefer later option with simple logic and to eliminate over-head of</span>
<span class=quote>&gt;&gt; bitmap repopulation in case of differnt page sizes. Later option is</span>
<span class=quote>&gt;&gt; implemented in this patch.</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; Hmm, we'll see below, but I not convinced based on the above rationale.</span>
<span class=quote>&gt; </span>
<span class=quote>&gt;&gt; Signed-off-by: Kirti Wankhede &lt;kwankhede@nvidia.com&gt;</span>
<span class=quote>&gt;&gt; Reviewed-by: Neo Jia &lt;cjia@nvidia.com&gt;</span>
<span class=quote>&gt;&gt; ---</span>
<span class=quote>&gt;&gt;   drivers/vfio/vfio_iommu_type1.c | 299 ++++++++++++++++++++++++++++++++++++++--</span>
<span class=quote>&gt;&gt;   1 file changed, 287 insertions(+), 12 deletions(-)</span>
<span class=quote>&gt;&gt;</span>
<span class=quote>&gt;&gt; diff --git a/drivers/vfio/vfio_iommu_type1.c b/drivers/vfio/vfio_iommu_type1.c</span>
<span class=quote>&gt;&gt; index d386461e5d11..df358dc1c85b 100644</span>
<span class=quote>&gt;&gt; --- a/drivers/vfio/vfio_iommu_type1.c</span>
<span class=quote>&gt;&gt; +++ b/drivers/vfio/vfio_iommu_type1.c</span>
<span class=quote>&gt;&gt; @@ -70,6 +70,7 @@ struct vfio_iommu {</span>
<span class=quote>&gt;&gt;   	unsigned int		dma_avail;</span>
<span class=quote>&gt;&gt;   	bool			v2;</span>
<span class=quote>&gt;&gt;   	bool			nesting;</span>
<span class=quote>&gt;&gt; +	bool			dirty_page_tracking;</span>
<span class=quote>&gt;&gt;   };</span>
<span class=quote>&gt;&gt;   </span>
<span class=quote>&gt;&gt;   struct vfio_domain {</span>
<span class=quote>&gt;&gt; @@ -90,6 +91,7 @@ struct vfio_dma {</span>
<span class=quote>&gt;&gt;   	bool			lock_cap;	/* capable(CAP_IPC_LOCK) */</span>
<span class=quote>&gt;&gt;   	struct task_struct	*task;</span>
<span class=quote>&gt;&gt;   	struct rb_root		pfn_list;	/* Ex-user pinned pfn list */</span>
<span class=quote>&gt;&gt; +	unsigned long		*bitmap;</span>
<span class=quote>&gt;&gt;   };</span>
<span class=quote>&gt;&gt;   </span>
<span class=quote>&gt;&gt;   struct vfio_group {</span>
<span class=quote>&gt;&gt; @@ -125,6 +127,7 @@ struct vfio_regions {</span>
<span class=quote>&gt;&gt;   					(!list_empty(&amp;iommu-&gt;domain_list))</span>
<span class=quote>&gt;&gt;   </span>
<span class=quote>&gt;&gt;   static int put_pfn(unsigned long pfn, int prot);</span>
<span class=quote>&gt;&gt; +static unsigned long vfio_pgsize_bitmap(struct vfio_iommu *iommu);</span>
<span class=quote>&gt;&gt;   </span>
<span class=quote>&gt;&gt;   /*</span>
<span class=quote>&gt;&gt;    * This code handles mapping and unmapping of user data buffers</span>
<span class=quote>&gt;&gt; @@ -174,6 +177,57 @@ static void vfio_unlink_dma(struct vfio_iommu *iommu, struct vfio_dma *old)</span>
<span class=quote>&gt;&gt;   	rb_erase(&amp;old-&gt;node, &amp;iommu-&gt;dma_list);</span>
<span class=quote>&gt;&gt;   }</span>
<span class=quote>&gt;&gt;   </span>
<span class=quote>&gt;&gt; +static inline unsigned long dirty_bitmap_bytes(unsigned int npages)</span>
<span class=quote>&gt;&gt; +{</span>
<span class=quote>&gt;&gt; +	if (!npages)</span>
<span class=quote>&gt;&gt; +		return 0;</span>
<span class=quote>&gt;&gt; +</span>
<span class=quote>&gt;&gt; +	return ALIGN(npages, BITS_PER_LONG) / sizeof(unsigned long);</span>
<span class=quote>&gt;&gt; +}</span>
<span class=quote>&gt;&gt; +</span>
<span class=quote>&gt;&gt; +static int vfio_dma_bitmap_alloc(struct vfio_iommu *iommu,</span>
<span class=quote>&gt;&gt; +				 struct vfio_dma *dma, unsigned long pgsizes)</span>
<span class=quote>&gt;&gt; +{</span>
<span class=quote>&gt;&gt; +	unsigned long pgshift = __ffs(pgsizes);</span>
<span class=quote>&gt;&gt; +</span>
<span class=quote>&gt;&gt; +	if (!RB_EMPTY_ROOT(&amp;dma-&gt;pfn_list) || dma-&gt;iommu_mapped) {</span>
<span class=quote>&gt;&gt; +		unsigned long npages = dma-&gt;size &gt;&gt; pgshift;</span>
<span class=quote>&gt;&gt; +		unsigned long bsize = dirty_bitmap_bytes(npages);</span>
<span class=quote>&gt;&gt; +</span>
<span class=quote>&gt;&gt; +		dma-&gt;bitmap = kvzalloc(bsize, GFP_KERNEL);</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; nit, we don't need to store bsize in a local variable.</span>
<span class=quote>&gt; </span>
<span class=quote>&gt;&gt; +		if (!dma-&gt;bitmap)</span>
<span class=quote>&gt;&gt; +			return -ENOMEM;</span>
<span class=quote>&gt;&gt; +	}</span>
<span class=quote>&gt;&gt; +	return 0;</span>
<span class=quote>&gt;&gt; +}</span>
<span class=quote>&gt;&gt; +</span>
<span class=quote>&gt;&gt; +static int vfio_dma_all_bitmap_alloc(struct vfio_iommu *iommu,</span>
<span class=quote>&gt;&gt; +				     unsigned long pgsizes)</span>
<span class=quote>&gt;&gt; +{</span>
<span class=quote>&gt;&gt; +	struct rb_node *n = rb_first(&amp;iommu-&gt;dma_list);</span>
<span class=quote>&gt;&gt; +	int ret;</span>
<span class=quote>&gt;&gt; +</span>
<span class=quote>&gt;&gt; +	for (; n; n = rb_next(n)) {</span>
<span class=quote>&gt;&gt; +		struct vfio_dma *dma = rb_entry(n, struct vfio_dma, node);</span>
<span class=quote>&gt;&gt; +</span>
<span class=quote>&gt;&gt; +		ret = vfio_dma_bitmap_alloc(iommu, dma, pgsizes);</span>
<span class=quote>&gt;&gt; +		if (ret)</span>
<span class=quote>&gt;&gt; +			return ret;</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; This doesn't unwind on failure, so we're left with partially allocated</span>
<span class=quote>&gt; bitmap cruft.</span>
<span class=quote>&gt;</span>

Good point. Adding unwind on failure.
<span class=quote>
&gt;&gt; +	}</span>
<span class=quote>&gt;&gt; +	return 0;</span>
<span class=quote>&gt;&gt; +}</span>
<span class=quote>&gt;&gt; +</span>
<span class=quote>&gt;&gt; +static void vfio_dma_all_bitmap_free(struct vfio_iommu *iommu)</span>
<span class=quote>&gt;&gt; +{</span>
<span class=quote>&gt;&gt; +	struct rb_node *n = rb_first(&amp;iommu-&gt;dma_list);</span>
<span class=quote>&gt;&gt; +</span>
<span class=quote>&gt;&gt; +	for (; n; n = rb_next(n)) {</span>
<span class=quote>&gt;&gt; +		struct vfio_dma *dma = rb_entry(n, struct vfio_dma, node);</span>
<span class=quote>&gt;&gt; +</span>
<span class=quote>&gt;&gt; +		kfree(dma-&gt;bitmap);</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; We don't set dma-&gt;bitmap = NULL and we don't even prevent the case of a</span>
<span class=quote>&gt; user making multiple STOP calls, so we have a user triggerable double</span>
<span class=quote>&gt; free :(</span>
<span class=quote>&gt; </span>

Ok.
<span class=quote>
&gt;&gt; +	}</span>
<span class=quote>&gt;&gt; +}</span>
<span class=quote>&gt;&gt; +</span>
<span class=quote>&gt;&gt;   /*</span>
<span class=quote>&gt;&gt;    * Helper Functions for host iova-pfn list</span>
<span class=quote>&gt;&gt;    */</span>
<span class=quote>&gt;&gt; @@ -244,6 +298,29 @@ static void vfio_remove_from_pfn_list(struct vfio_dma *dma,</span>
<span class=quote>&gt;&gt;   	kfree(vpfn);</span>
<span class=quote>&gt;&gt;   }</span>
<span class=quote>&gt;&gt;   </span>
<span class=quote>&gt;&gt; +static void vfio_remove_unpinned_from_pfn_list(struct vfio_dma *dma)</span>
<span class=quote>&gt;&gt; +{</span>
<span class=quote>&gt;&gt; +	struct rb_node *n = rb_first(&amp;dma-&gt;pfn_list);</span>
<span class=quote>&gt;&gt; +</span>
<span class=quote>&gt;&gt; +	for (; n; n = rb_next(n)) {</span>
<span class=quote>&gt;&gt; +		struct vfio_pfn *vpfn = rb_entry(n, struct vfio_pfn, node);</span>
<span class=quote>&gt;&gt; +</span>
<span class=quote>&gt;&gt; +		if (!vpfn-&gt;ref_count)</span>
<span class=quote>&gt;&gt; +			vfio_remove_from_pfn_list(dma, vpfn);</span>
<span class=quote>&gt;&gt; +	}</span>
<span class=quote>&gt;&gt; +}</span>
<span class=quote>&gt;&gt; +</span>
<span class=quote>&gt;&gt; +static void vfio_remove_unpinned_from_dma_list(struct vfio_iommu *iommu)</span>
<span class=quote>&gt;&gt; +{</span>
<span class=quote>&gt;&gt; +	struct rb_node *n = rb_first(&amp;iommu-&gt;dma_list);</span>
<span class=quote>&gt;&gt; +</span>
<span class=quote>&gt;&gt; +	for (; n; n = rb_next(n)) {</span>
<span class=quote>&gt;&gt; +		struct vfio_dma *dma = rb_entry(n, struct vfio_dma, node);</span>
<span class=quote>&gt;&gt; +</span>
<span class=quote>&gt;&gt; +		vfio_remove_unpinned_from_pfn_list(dma);</span>
<span class=quote>&gt;&gt; +	}</span>
<span class=quote>&gt;&gt; +}</span>
<span class=quote>&gt;&gt; +</span>
<span class=quote>&gt;&gt;   static struct vfio_pfn *vfio_iova_get_vfio_pfn(struct vfio_dma *dma,</span>
<span class=quote>&gt;&gt;   					       unsigned long iova)</span>
<span class=quote>&gt;&gt;   {</span>
<span class=quote>&gt;&gt; @@ -261,7 +338,8 @@ static int vfio_iova_put_vfio_pfn(struct vfio_dma *dma, struct vfio_pfn *vpfn)</span>
<span class=quote>&gt;&gt;   	vpfn-&gt;ref_count--;</span>
<span class=quote>&gt;&gt;   	if (!vpfn-&gt;ref_count) {</span>
<span class=quote>&gt;&gt;   		ret = put_pfn(vpfn-&gt;pfn, dma-&gt;prot);</span>
<span class=quote>&gt;&gt; -		vfio_remove_from_pfn_list(dma, vpfn);</span>
<span class=quote>&gt;&gt; +		if (!dma-&gt;bitmap)</span>
<span class=quote>&gt;&gt; +			vfio_remove_from_pfn_list(dma, vpfn);</span>
<span class=quote>&gt;&gt;   	}</span>
<span class=quote>&gt;&gt;   	return ret;</span>
<span class=quote>&gt;&gt;   }</span>
<span class=quote>&gt;&gt; @@ -483,13 +561,14 @@ static int vfio_pin_page_external(struct vfio_dma *dma, unsigned long vaddr,</span>
<span class=quote>&gt;&gt;   	return ret;</span>
<span class=quote>&gt;&gt;   }</span>
<span class=quote>&gt;&gt;   </span>
<span class=quote>&gt;&gt; -static int vfio_unpin_page_external(struct vfio_dma *dma, dma_addr_t iova,</span>
<span class=quote>&gt;&gt; +static int vfio_unpin_page_external(struct vfio_iommu *iommu,</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; We added a parameter but didn't use it in this patch.</span>
<span class=quote>&gt; </span>

Ok, Moving it to relevant patch.
<span class=quote>
&gt;&gt; +				    struct vfio_dma *dma, dma_addr_t iova,</span>
<span class=quote>&gt;&gt;   				    bool do_accounting)</span>
<span class=quote>&gt;&gt;   {</span>
<span class=quote>&gt;&gt;   	int unlocked;</span>
<span class=quote>&gt;&gt;   	struct vfio_pfn *vpfn = vfio_find_vpfn(dma, iova);</span>
<span class=quote>&gt;&gt;   </span>
<span class=quote>&gt;&gt; -	if (!vpfn)</span>
<span class=quote>&gt;&gt; +	if (!vpfn || !vpfn-&gt;ref_count)</span>
<span class=quote>&gt;&gt;   		return 0;</span>
<span class=quote>&gt;&gt;   </span>
<span class=quote>&gt;&gt;   	unlocked = vfio_iova_put_vfio_pfn(dma, vpfn);</span>
<span class=quote>&gt;&gt; @@ -510,6 +589,7 @@ static int vfio_iommu_type1_pin_pages(void *iommu_data,</span>
<span class=quote>&gt;&gt;   	unsigned long remote_vaddr;</span>
<span class=quote>&gt;&gt;   	struct vfio_dma *dma;</span>
<span class=quote>&gt;&gt;   	bool do_accounting;</span>
<span class=quote>&gt;&gt; +	unsigned long iommu_pgsizes = vfio_pgsize_bitmap(iommu);</span>
<span class=quote>&gt;&gt;   </span>
<span class=quote>&gt;&gt;   	if (!iommu || !user_pfn || !phys_pfn)</span>
<span class=quote>&gt;&gt;   		return -EINVAL;</span>
<span class=quote>&gt;&gt; @@ -551,8 +631,10 @@ static int vfio_iommu_type1_pin_pages(void *iommu_data,</span>
<span class=quote>&gt;&gt;   </span>
<span class=quote>&gt;&gt;   		vpfn = vfio_iova_get_vfio_pfn(dma, iova);</span>
<span class=quote>&gt;&gt;   		if (vpfn) {</span>
<span class=quote>&gt;&gt; -			phys_pfn[i] = vpfn-&gt;pfn;</span>
<span class=quote>&gt;&gt; -			continue;</span>
<span class=quote>&gt;&gt; +			if (vpfn-&gt;ref_count &gt; 1) {</span>
<span class=quote>&gt;&gt; +				phys_pfn[i] = vpfn-&gt;pfn;</span>
<span class=quote>&gt;&gt; +				continue;</span>
<span class=quote>&gt;&gt; +			}</span>
<span class=quote>&gt;&gt;   		}</span>
<span class=quote>&gt;&gt;   </span>
<span class=quote>&gt;&gt;   		remote_vaddr = dma-&gt;vaddr + iova - dma-&gt;iova;</span>
<span class=quote>&gt;&gt; @@ -560,11 +642,23 @@ static int vfio_iommu_type1_pin_pages(void *iommu_data,</span>
<span class=quote>&gt;&gt;   					     do_accounting);</span>
<span class=quote>&gt;&gt;   		if (ret)</span>
<span class=quote>&gt;&gt;   			goto pin_unwind;</span>
<span class=quote>&gt;&gt; -</span>
<span class=quote>&gt;&gt; -		ret = vfio_add_to_pfn_list(dma, iova, phys_pfn[i]);</span>
<span class=quote>&gt;&gt; -		if (ret) {</span>
<span class=quote>&gt;&gt; -			vfio_unpin_page_external(dma, iova, do_accounting);</span>
<span class=quote>&gt;&gt; -			goto pin_unwind;</span>
<span class=quote>&gt;&gt; +		if (!vpfn) {</span>
<span class=quote>&gt;&gt; +			ret = vfio_add_to_pfn_list(dma, iova, phys_pfn[i]);</span>
<span class=quote>&gt;&gt; +			if (ret) {</span>
<span class=quote>&gt;&gt; +				vfio_unpin_page_external(iommu, dma, iova,</span>
<span class=quote>&gt;&gt; +							 do_accounting);</span>
<span class=quote>&gt;&gt; +				goto pin_unwind;</span>
<span class=quote>&gt;&gt; +			}</span>
<span class=quote>&gt;&gt; +		} else</span>
<span class=quote>&gt;&gt; +			vpfn-&gt;pfn = phys_pfn[i];</span>
<span class=quote>&gt;&gt; +</span>
<span class=quote>&gt;&gt; +		if (iommu-&gt;dirty_page_tracking &amp;&amp; !dma-&gt;bitmap) {</span>
<span class=quote>&gt;&gt; +			ret = vfio_dma_bitmap_alloc(iommu, dma, iommu_pgsizes);</span>
<span class=quote>&gt;&gt; +			if (ret) {</span>
<span class=quote>&gt;&gt; +				vfio_unpin_page_external(iommu, dma, iova,</span>
<span class=quote>&gt;&gt; +							 do_accounting);</span>
<span class=quote>&gt;&gt; +				goto pin_unwind;</span>
<span class=quote>&gt;&gt; +			}</span>
<span class=quote>&gt;&gt;   		}</span>
<span class=quote>&gt;&gt;   	}</span>
<span class=quote>&gt;&gt;   </span>
<span class=quote>&gt;&gt; @@ -578,7 +672,7 @@ static int vfio_iommu_type1_pin_pages(void *iommu_data,</span>
<span class=quote>&gt;&gt;   </span>
<span class=quote>&gt;&gt;   		iova = user_pfn[j] &lt;&lt; PAGE_SHIFT;</span>
<span class=quote>&gt;&gt;   		dma = vfio_find_dma(iommu, iova, PAGE_SIZE);</span>
<span class=quote>&gt;&gt; -		vfio_unpin_page_external(dma, iova, do_accounting);</span>
<span class=quote>&gt;&gt; +		vfio_unpin_page_external(iommu, dma, iova, do_accounting);</span>
<span class=quote>&gt;&gt;   		phys_pfn[j] = 0;</span>
<span class=quote>&gt;&gt;   	}</span>
<span class=quote>&gt;&gt;   pin_done:</span>
<span class=quote>&gt;&gt; @@ -612,7 +706,7 @@ static int vfio_iommu_type1_unpin_pages(void *iommu_data,</span>
<span class=quote>&gt;&gt;   		dma = vfio_find_dma(iommu, iova, PAGE_SIZE);</span>
<span class=quote>&gt;&gt;   		if (!dma)</span>
<span class=quote>&gt;&gt;   			goto unpin_exit;</span>
<span class=quote>&gt;&gt; -		vfio_unpin_page_external(dma, iova, do_accounting);</span>
<span class=quote>&gt;&gt; +		vfio_unpin_page_external(iommu, dma, iova, do_accounting);</span>
<span class=quote>&gt;&gt;   	}</span>
<span class=quote>&gt;&gt;   </span>
<span class=quote>&gt;&gt;   unpin_exit:</span>
<span class=quote>&gt;&gt; @@ -830,6 +924,113 @@ static unsigned long vfio_pgsize_bitmap(struct vfio_iommu *iommu)</span>
<span class=quote>&gt;&gt;   	return bitmap;</span>
<span class=quote>&gt;&gt;   }</span>
<span class=quote>&gt;&gt;   </span>
<span class=quote>&gt;&gt; +static int vfio_iova_dirty_bitmap(struct vfio_iommu *iommu, dma_addr_t iova,</span>
<span class=quote>&gt;&gt; +				  size_t size, uint64_t pgsize,</span>
<span class=quote>&gt;&gt; +				  unsigned char __user *bitmap)</span>
<span class=quote>&gt;&gt; +{</span>
<span class=quote>&gt;&gt; +	struct vfio_dma *dma;</span>
<span class=quote>&gt;&gt; +	dma_addr_t i = iova, iova_limit;</span>
<span class=quote>&gt;&gt; +	unsigned int bsize, nbits = 0, l = 0;</span>
<span class=quote>&gt;&gt; +	unsigned long pgshift = __ffs(pgsize);</span>
<span class=quote>&gt;&gt; +</span>
<span class=quote>&gt;&gt; +	while ((dma = vfio_find_dma(iommu, i, pgsize))) {</span>
<span class=quote>&gt;&gt; +		int ret, j;</span>
<span class=quote>&gt;&gt; +		unsigned int npages = 0, shift = 0;</span>
<span class=quote>&gt;&gt; +		unsigned char temp = 0;</span>
<span class=quote>&gt;&gt; +</span>
<span class=quote>&gt;&gt; +		/* mark all pages dirty if all pages are pinned and mapped. */</span>
<span class=quote>&gt;&gt; +		if (dma-&gt;iommu_mapped) {</span>
<span class=quote>&gt;&gt; +			iova_limit = min(dma-&gt;iova + dma-&gt;size, iova + size);</span>
<span class=quote>&gt;&gt; +			npages = iova_limit/pgsize;</span>
<span class=quote>&gt;&gt; +			bitmap_set(dma-&gt;bitmap, 0, npages);</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; npages is derived from iova_limit, which is the number of bits to set</span>
<span class=quote>&gt; dirty relative to the first requested iova, not iova zero, ie. the set</span>
<span class=quote>&gt; of dirty bits is offset from those requested unless iova == dma-&gt;iova.</span>
<span class=quote>&gt; </span>

Right, fixing.
<span class=quote>
&gt; Also I hope dma-&gt;bitmap was actually allocated.  Not only does the</span>
<span class=quote>&gt; START error path potentially leave dirty tracking enabled without all</span>
<span class=quote>&gt; the bitmap allocated, when does the bitmap get allocated for a new</span>
<span class=quote>&gt; vfio_dma when dirty tracking is enabled?  Seems it only occurs if a</span>
<span class=quote>&gt; vpfn gets marked dirty.</span>
<span class=quote>&gt; </span>

Right.

Fixing error paths.
<span class=quote>

&gt;&gt; +		} else if (dma-&gt;bitmap) {</span>
<span class=quote>&gt;&gt; +			struct rb_node *n = rb_first(&amp;dma-&gt;pfn_list);</span>
<span class=quote>&gt;&gt; +			bool found = false;</span>
<span class=quote>&gt;&gt; +</span>
<span class=quote>&gt;&gt; +			for (; n; n = rb_next(n)) {</span>
<span class=quote>&gt;&gt; +				struct vfio_pfn *vpfn = rb_entry(n,</span>
<span class=quote>&gt;&gt; +						struct vfio_pfn, node);</span>
<span class=quote>&gt;&gt; +				if (vpfn-&gt;iova &gt;= i) {</span>
<span class=quote>&gt;&gt; +					found = true;</span>
<span class=quote>&gt;&gt; +					break;</span>
<span class=quote>&gt;&gt; +				}</span>
<span class=quote>&gt;&gt; +			}</span>
<span class=quote>&gt;&gt; +</span>
<span class=quote>&gt;&gt; +			if (!found) {</span>
<span class=quote>&gt;&gt; +				i += dma-&gt;size;</span>
<span class=quote>&gt;&gt; +				continue;</span>
<span class=quote>&gt;&gt; +			}</span>
<span class=quote>&gt;&gt; +</span>
<span class=quote>&gt;&gt; +			for (; n; n = rb_next(n)) {</span>
<span class=quote>&gt;&gt; +				unsigned int s;</span>
<span class=quote>&gt;&gt; +				struct vfio_pfn *vpfn = rb_entry(n,</span>
<span class=quote>&gt;&gt; +						struct vfio_pfn, node);</span>
<span class=quote>&gt;&gt; +</span>
<span class=quote>&gt;&gt; +				if (vpfn-&gt;iova &gt;= iova + size)</span>
<span class=quote>&gt;&gt; +					break;</span>
<span class=quote>&gt;&gt; +</span>
<span class=quote>&gt;&gt; +				s = (vpfn-&gt;iova - dma-&gt;iova) &gt;&gt; pgshift;</span>
<span class=quote>&gt;&gt; +				bitmap_set(dma-&gt;bitmap, s, 1);</span>
<span class=quote>&gt;&gt; +</span>
<span class=quote>&gt;&gt; +				iova_limit = vpfn-&gt;iova + pgsize;</span>
<span class=quote>&gt;&gt; +			}</span>
<span class=quote>&gt;&gt; +			npages = iova_limit/pgsize;</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; Isn't iova_limit potentially uninitialized here?  For example, if our</span>
<span class=quote>&gt; vfio_dma covers {0,8192} and we ask for the bitmap of {0,4096} and</span>
<span class=quote>&gt; there's a vpfn at {4096,8192}.  I think that means vpfn-&gt;iova &gt;= i</span>
<span class=quote>&gt; (4096 &gt;= 0), so we break with found = true, then we test 4096 &gt;= 0 +</span>
<span class=quote>&gt; 4096 and break, and npages = ????/pgsize.</span>
<span class=quote>&gt; </span>

Right, Fixing it.
<span class=quote>
&gt;&gt; +		}</span>
<span class=quote>&gt;&gt; +</span>
<span class=quote>&gt;&gt; +		bsize = dirty_bitmap_bytes(npages);</span>
<span class=quote>&gt;&gt; +		shift = nbits % BITS_PER_BYTE;</span>
<span class=quote>&gt;&gt; +</span>
<span class=quote>&gt;&gt; +		if (npages &amp;&amp; shift) {</span>
<span class=quote>&gt;&gt; +			l--;</span>
<span class=quote>&gt;&gt; +			if (!access_ok((void __user *)bitmap + l,</span>
<span class=quote>&gt;&gt; +					sizeof(unsigned char)))</span>
<span class=quote>&gt;&gt; +				return -EINVAL;</span>
<span class=quote>&gt;&gt; +</span>
<span class=quote>&gt;&gt; +			ret = __get_user(temp, bitmap + l);</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; I don't understand why we care to get the user's bitmap, are we trying</span>
<span class=quote>&gt; to leave whatever garbage they might have set in it and only also set</span>
<span class=quote>&gt; the dirty bits?  That seems unnecessary.</span>
<span class=quote>&gt; </span>

Suppose dma mapped ranges are {start, size}:
{0, 0xa000}, {0xa000, 0x10000}

Bitmap asked from 0 - 0x10000. Say suppose all pages are dirty.
Then in first iteration for dma {0,0xa000} there are 10 pages, so 10 
bits are set, put_user() happens for 2 bytes, (00000011 11111111b).
In second iteration for dma {0xa000, 0x10000} there are 6 pages and 
these bits should be appended to previous byte. So get_user() that byte, 
then shift-OR rest of the bitmap, result should be: (11111111 11111111b)

Without get_user() and shift-OR, resulting bitmap would be
111111 00000011 11111111b which would be wrong.
<span class=quote>
&gt; Also why do we need these access_ok() checks when we already checked</span>
<span class=quote>&gt; the range at the start of the ioctl?</span>

Since pointer is updated runtime here, better to check that pointer 
before using that pointer.
<span class=quote>
&gt; </span>
<span class=quote>&gt;&gt; +			if (ret)</span>
<span class=quote>&gt;&gt; +				return ret;</span>
<span class=quote>&gt;&gt; +		}</span>
<span class=quote>&gt;&gt; +</span>
<span class=quote>&gt;&gt; +		for (j = 0; j &lt; bsize; j++, l++) {</span>
<span class=quote>&gt;&gt; +			temp = temp |</span>
<span class=quote>&gt;&gt; +			       (*((unsigned char *)dma-&gt;bitmap + j) &lt;&lt; shift);</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; |=</span>
<span class=quote>&gt; </span>
<span class=quote>&gt;&gt; +			if (!access_ok((void __user *)bitmap + l,</span>
<span class=quote>&gt;&gt; +					sizeof(unsigned char)))</span>
<span class=quote>&gt;&gt; +				return -EINVAL;</span>
<span class=quote>&gt;&gt; +</span>
<span class=quote>&gt;&gt; +			ret = __put_user(temp, bitmap + l);</span>
<span class=quote>&gt;&gt; +			if (ret)</span>
<span class=quote>&gt;&gt; +				return ret;</span>
<span class=quote>&gt;&gt; +			if (shift) {</span>
<span class=quote>&gt;&gt; +				temp = *((unsigned char *)dma-&gt;bitmap + j) &gt;&gt;</span>
<span class=quote>&gt;&gt; +					(BITS_PER_BYTE - shift);</span>
<span class=quote>&gt;&gt; +			}</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; When shift == 0, temp just seems to accumulate bits that never get</span>
<span class=quote>&gt; cleared.</span>
<span class=quote>&gt; </span>

Hope example above explains the shift logic.
<span class=quote>
&gt;&gt; +		}</span>
<span class=quote>&gt;&gt; +</span>
<span class=quote>&gt;&gt; +		nbits += npages;</span>
<span class=quote>&gt;&gt; +</span>
<span class=quote>&gt;&gt; +		i = min(dma-&gt;iova + dma-&gt;size, iova + size);</span>
<span class=quote>&gt;&gt; +		if (i &gt;= iova + size)</span>
<span class=quote>&gt;&gt; +			break;</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; So whether we error or succeed, we leave cruft in dma-&gt;bitmap for the</span>
<span class=quote>&gt; next pass.  It doesn't seem to make any sense why we pre-allocated the</span>
<span class=quote>&gt; bitmap, we might as well just allocate it on demand here.  Actually, if</span>
<span class=quote>&gt; we're not going to do a copy_to_user() for some range of the bitmap,</span>
<span class=quote>&gt; I'm not sure what it's purpose is at all.  I think the big advantages</span>
<span class=quote>&gt; of the bitmap are that we can't amortize the cost across every pinned</span>
<span class=quote>&gt; page or DMA mapping, we don't need the overhead of tracking unmapped</span>
<span class=quote>&gt; vpfns, and we can use copy_to_user() to push the bitmap out.  We're not</span>
<span class=quote>&gt; getting any of those advantages here.</span>
<span class=quote>&gt; </span>

That would still not work if dma range size is not multiples of 8 pages. 
See example above.
<span class=quote>

&gt;&gt; +	}</span>
<span class=quote>&gt;&gt; +	return 0;</span>
<span class=quote>&gt;&gt; +}</span>
<span class=quote>&gt;&gt; +</span>
<span class=quote>&gt;&gt; +static long verify_bitmap_size(unsigned long npages, unsigned long bitmap_size)</span>
<span class=quote>&gt;&gt; +{</span>
<span class=quote>&gt;&gt; +	long bsize;</span>
<span class=quote>&gt;&gt; +</span>
<span class=quote>&gt;&gt; +	if (!bitmap_size || bitmap_size &gt; SIZE_MAX)</span>
<span class=quote>&gt;&gt; +		return -EINVAL;</span>
<span class=quote>&gt;&gt; +</span>
<span class=quote>&gt;&gt; +	bsize = dirty_bitmap_bytes(npages);</span>
<span class=quote>&gt;&gt; +</span>
<span class=quote>&gt;&gt; +	if (bitmap_size &lt; bsize)</span>
<span class=quote>&gt;&gt; +		return -EINVAL;</span>
<span class=quote>&gt;&gt; +</span>
<span class=quote>&gt;&gt; +	return bsize;</span>
<span class=quote>&gt;&gt; +}</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; Seems like this could simply return int, -errno or zero for success.</span>
<span class=quote>&gt; The returned bsize is not used for anything else.</span>
<span class=quote>&gt; </span>

ok.
<span class=quote>
&gt;&gt; +</span>
<span class=quote>&gt;&gt;   static int vfio_dma_do_unmap(struct vfio_iommu *iommu,</span>
<span class=quote>&gt;&gt;   			     struct vfio_iommu_type1_dma_unmap *unmap)</span>
<span class=quote>&gt;&gt;   {</span>
<span class=quote>&gt;&gt; @@ -2277,6 +2478,80 @@ static long vfio_iommu_type1_ioctl(void *iommu_data,</span>
<span class=quote>&gt;&gt;   </span>
<span class=quote>&gt;&gt;   		return copy_to_user((void __user *)arg, &amp;unmap, minsz) ?</span>
<span class=quote>&gt;&gt;   			-EFAULT : 0;</span>
<span class=quote>&gt;&gt; +	} else if (cmd == VFIO_IOMMU_DIRTY_PAGES) {</span>
<span class=quote>&gt;&gt; +		struct vfio_iommu_type1_dirty_bitmap range;</span>
<span class=quote>&gt;&gt; +		uint32_t mask = VFIO_IOMMU_DIRTY_PAGES_FLAG_START |</span>
<span class=quote>&gt;&gt; +				VFIO_IOMMU_DIRTY_PAGES_FLAG_STOP |</span>
<span class=quote>&gt;&gt; +				VFIO_IOMMU_DIRTY_PAGES_FLAG_GET_BITMAP;</span>
<span class=quote>&gt;&gt; +		int ret;</span>
<span class=quote>&gt;&gt; +</span>
<span class=quote>&gt;&gt; +		if (!iommu-&gt;v2)</span>
<span class=quote>&gt;&gt; +			return -EACCES;</span>
<span class=quote>&gt;&gt; +</span>
<span class=quote>&gt;&gt; +		minsz = offsetofend(struct vfio_iommu_type1_dirty_bitmap,</span>
<span class=quote>&gt;&gt; +				    bitmap);</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; We require the user to provide iova, size, pgsize, bitmap_size, and</span>
<span class=quote>&gt; bitmap fields to START/STOP?  Why?</span>
<span class=quote>&gt;</span>

No. But those are part of structure.
<span class=quote>
&gt;&gt; +</span>
<span class=quote>&gt;&gt; +		if (copy_from_user(&amp;range, (void __user *)arg, minsz))</span>
<span class=quote>&gt;&gt; +			return -EFAULT;</span>
<span class=quote>&gt;&gt; +</span>
<span class=quote>&gt;&gt; +		if (range.argsz &lt; minsz || range.flags &amp; ~mask)</span>
<span class=quote>&gt;&gt; +			return -EINVAL;</span>
<span class=quote>&gt;&gt; +</span>
<span class=quote>&gt;&gt; +		/* only one flag should be set at a time */</span>
<span class=quote>&gt;&gt; +		if (__ffs(range.flags) != __fls(range.flags))</span>
<span class=quote>&gt;&gt; +			return -EINVAL;</span>
<span class=quote>&gt;&gt; +</span>
<span class=quote>&gt;&gt; +		if (range.flags &amp; VFIO_IOMMU_DIRTY_PAGES_FLAG_START) {</span>
<span class=quote>&gt;&gt; +			unsigned long iommu_pgsizes = vfio_pgsize_bitmap(iommu);</span>
<span class=quote>&gt;&gt; +</span>
<span class=quote>&gt;&gt; +			mutex_lock(&amp;iommu-&gt;lock);</span>
<span class=quote>&gt;&gt; +			iommu-&gt;dirty_page_tracking = true;</span>
<span class=quote>&gt;&gt; +			ret = vfio_dma_all_bitmap_alloc(iommu, iommu_pgsizes);</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; So dirty page tracking is enabled even if we fail to allocate all the</span>
<span class=quote>&gt; bitmaps?  Shouldn't this return an error if dirty tracking is already</span>
<span class=quote>&gt; enabled?</span>
<span class=quote>&gt; </span>

Adding error handling here in next patch.
<span class=quote>
&gt;&gt; +			mutex_unlock(&amp;iommu-&gt;lock);</span>
<span class=quote>&gt;&gt; +			return ret;</span>
<span class=quote>&gt;&gt; +		} else if (range.flags &amp; VFIO_IOMMU_DIRTY_PAGES_FLAG_STOP) {</span>
<span class=quote>&gt;&gt; +			mutex_lock(&amp;iommu-&gt;lock);</span>
<span class=quote>&gt;&gt; +			iommu-&gt;dirty_page_tracking = false;</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; Shouldn't we only allow STOP if tracking is enabled?</span>
<span class=quote>&gt; </span>

Right,adding.
<span class=quote>
&gt;&gt; +			vfio_dma_all_bitmap_free(iommu);</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; Here's where that user induced double free enters the picture.</span>
<span class=quote>&gt; </span>

Error handling as mentioned above will prevent double free.

Thanks,
Kirti
<span class=quote>
&gt;&gt; +			vfio_remove_unpinned_from_dma_list(iommu);</span>
<span class=quote>&gt;&gt; +			mutex_unlock(&amp;iommu-&gt;lock);</span>
<span class=quote>&gt;&gt; +			return 0;</span>
<span class=quote>&gt;&gt; +		} else if (range.flags &amp;</span>
<span class=quote>&gt;&gt; +				 VFIO_IOMMU_DIRTY_PAGES_FLAG_GET_BITMAP) {</span>
<span class=quote>&gt;&gt; +			long bsize;</span>
<span class=quote>&gt;&gt; +			unsigned long pgshift = __ffs(range.pgsize);</span>
<span class=quote>&gt;&gt; +			uint64_t iommu_pgsizes = vfio_pgsize_bitmap(iommu);</span>
<span class=quote>&gt;&gt; +			uint64_t iommu_pgmask =</span>
<span class=quote>&gt;&gt; +				 ((uint64_t)1 &lt;&lt; __ffs(iommu_pgsizes)) - 1;</span>
<span class=quote>&gt;&gt; +</span>
<span class=quote>&gt;&gt; +			if ((range.pgsize &amp; iommu_pgsizes) != range.pgsize)</span>
<span class=quote>&gt;&gt; +				return -EINVAL;</span>
<span class=quote>&gt;&gt; +			if (range.iova &amp; iommu_pgmask)</span>
<span class=quote>&gt;&gt; +				return -EINVAL;</span>
<span class=quote>&gt;&gt; +			if (!range.size || range.size &amp; iommu_pgmask)</span>
<span class=quote>&gt;&gt; +				return -EINVAL;</span>
<span class=quote>&gt;&gt; +			if (range.iova + range.size &lt; range.iova)</span>
<span class=quote>&gt;&gt; +				return -EINVAL;</span>
<span class=quote>&gt;&gt; +			if (!access_ok((void __user *)range.bitmap,</span>
<span class=quote>&gt;&gt; +				       range.bitmap_size))</span>
<span class=quote>&gt;&gt; +				return -EINVAL;</span>
<span class=quote>&gt;&gt; +</span>
<span class=quote>&gt;&gt; +			bsize = verify_bitmap_size(range.size &gt;&gt; pgshift,</span>
<span class=quote>&gt;&gt; +						   range.bitmap_size);</span>
<span class=quote>&gt;&gt; +			if (bsize &lt; 0)</span>
<span class=quote>&gt;&gt; +				return bsize;</span>
<span class=quote>&gt;&gt; +</span>
<span class=quote>&gt;&gt; +			mutex_lock(&amp;iommu-&gt;lock);</span>
<span class=quote>&gt;&gt; +			if (iommu-&gt;dirty_page_tracking)</span>
<span class=quote>&gt;&gt; +				ret = vfio_iova_dirty_bitmap(iommu, range.iova,</span>
<span class=quote>&gt;&gt; +					 range.size, range.pgsize,</span>
<span class=quote>&gt;&gt; +					 (unsigned char __user *)range.bitmap);</span>
<span class=quote>&gt;&gt; +			else</span>
<span class=quote>&gt;&gt; +				ret = -EINVAL;</span>
<span class=quote>&gt;&gt; +			mutex_unlock(&amp;iommu-&gt;lock);</span>
<span class=quote>&gt;&gt; +</span>
<span class=quote>&gt;&gt; +			return ret;</span>
<span class=quote>&gt;&gt; +		}</span>
<span class=quote>&gt;&gt;   	}</span>
<span class=quote>&gt;&gt;   </span>
<span class=quote>&gt;&gt;   	return -ENOTTY;</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; Thanks,</span>
<span class=quote>&gt; Alex</span>
<span class=quote>&gt;</span>
</pre>
</div>
<a name=23153631></a>
<div class=comment>
<div class=meta>
 <span><a href="https://patchwork.kernel.org/project/qemu-devel/list/?submitter=7781">Alex Williamson</a></span>
 <span class=pull-right>Feb. 12, 2020, 11:13 p.m. UTC | <a href=https://patchwork.kernel.org/comment/23153631/>#8</a></span>
</div>
<pre class=content>On Thu, 13 Feb 2020 02:26:23 +0530
Kirti Wankhede &lt;kwankhede@nvidia.com&gt; wrote:
<span class=quote>
&gt; On 2/10/2020 10:55 PM, Alex Williamson wrote:</span>
<span class=quote>&gt; &gt; On Sat, 8 Feb 2020 01:12:31 +0530</span>
<span class=quote>&gt; &gt; Kirti Wankhede &lt;kwankhede@nvidia.com&gt; wrote:</span>
<span class=quote>&gt; &gt;   </span>
<span class=quote>&gt; &gt;&gt; VFIO_IOMMU_DIRTY_PAGES ioctl performs three operations:</span>
<span class=quote>&gt; &gt;&gt; - Start pinned and unpinned pages tracking while migration is active</span>
<span class=quote>&gt; &gt;&gt; - Stop pinned and unpinned dirty pages tracking. This is also used to</span>
<span class=quote>&gt; &gt;&gt;    stop dirty pages tracking if migration failed or cancelled.</span>
<span class=quote>&gt; &gt;&gt; - Get dirty pages bitmap. This ioctl returns bitmap of dirty pages, its</span>
<span class=quote>&gt; &gt;&gt;    user space application responsibility to copy content of dirty pages</span>
<span class=quote>&gt; &gt;&gt;    from source to destination during migration.</span>
<span class=quote>&gt; &gt;&gt;</span>
<span class=quote>&gt; &gt;&gt; To prevent DoS attack, memory for bitmap is allocated per vfio_dma</span>
<span class=quote>&gt; &gt;&gt; structure. Bitmap size is calculated considering smallest supported page</span>
<span class=quote>&gt; &gt;&gt; size. Bitmap is allocated when dirty logging is enabled for those</span>
<span class=quote>&gt; &gt;&gt; vfio_dmas whose vpfn list is not empty or whole range is mapped, in</span>
<span class=quote>&gt; &gt;&gt; case of pass-through device.</span>
<span class=quote>&gt; &gt;&gt;</span>
<span class=quote>&gt; &gt;&gt; There could be multiple option as to when bitmap should be populated:</span>
<span class=quote>&gt; &gt;&gt; * Polulate bitmap for already pinned pages when bitmap is allocated for</span>
<span class=quote>&gt; &gt;&gt;    a vfio_dma with the smallest supported page size. Updates bitmap from</span>
<span class=quote>&gt; &gt;&gt;    page pinning and unpinning functions. When user application queries</span>
<span class=quote>&gt; &gt;&gt;    bitmap, check if requested page size is same as page size used to</span>
<span class=quote>&gt; &gt;&gt;    populated bitmap. If it is equal, copy bitmap. But if not equal,</span>
<span class=quote>&gt; &gt;&gt;    re-populated bitmap according to requested page size and then copy to</span>
<span class=quote>&gt; &gt;&gt;    user.</span>
<span class=quote>&gt; &gt;&gt;    Pros: Bitmap gets populated on the fly after dirty tracking has</span>
<span class=quote>&gt; &gt;&gt;          started.</span>
<span class=quote>&gt; &gt;&gt;    Cons: If requested page size is different than smallest supported</span>
<span class=quote>&gt; &gt;&gt;          page size, then bitmap has to be re-populated again, with</span>
<span class=quote>&gt; &gt;&gt;          additional overhead of allocating bitmap memory again for</span>
<span class=quote>&gt; &gt;&gt;          re-population of bitmap.  </span>
<span class=quote>&gt; &gt; </span>
<span class=quote>&gt; &gt; No memory needs to be allocated to re-populate the bitmap.  The bitmap</span>
<span class=quote>&gt; &gt; is clear-on-read and by tracking the bitmap in the smallest supported</span>
<span class=quote>&gt; &gt; page size we can guarantee that we can fit the user requested bitmap</span>
<span class=quote>&gt; &gt; size within the space occupied by that minimal page size range of the</span>
<span class=quote>&gt; &gt; bitmap.  Therefore we'd destructively translate the requested region of</span>
<span class=quote>&gt; &gt; the bitmap to a different page size, write it out to the user, and</span>
<span class=quote>&gt; &gt; clear it.  Also we expect userspace to use the minimum page size almost</span>
<span class=quote>&gt; &gt; exclusively, which is optimized by this approach as dirty bit tracking</span>
<span class=quote>&gt; &gt; is spread out over each page pinning operation.</span>
<span class=quote>&gt; &gt;   </span>
<span class=quote>&gt; &gt;&gt;</span>
<span class=quote>&gt; &gt;&gt; * Populate bitmap when bitmap is queried by user application.</span>
<span class=quote>&gt; &gt;&gt;    Pros: Bitmap is populated with requested page size. This eliminates</span>
<span class=quote>&gt; &gt;&gt;          the need to re-populate bitmap if requested page size is</span>
<span class=quote>&gt; &gt;&gt;          different than smallest supported pages size.</span>
<span class=quote>&gt; &gt;&gt;    Cons: There is one time processing time, when bitmap is queried.  </span>
<span class=quote>&gt; &gt; </span>
<span class=quote>&gt; &gt; Another significant Con is that the vpfn list needs to track and manage</span>
<span class=quote>&gt; &gt; unpinned pages, which makes it more complex and intrusive.  The</span>
<span class=quote>&gt; &gt; previous option seems to have both time and complexity advantages,</span>
<span class=quote>&gt; &gt; especially in the case we expect to be most common of the user</span>
<span class=quote>&gt; &gt; accessing the bitmap with the minimum page size, ie. PAGE_SIZE.  It's</span>
<span class=quote>&gt; &gt; also not clear why we pre-allocate the bitmap at all with this approach.</span>
<span class=quote>&gt; &gt;   </span>
<span class=quote>&gt; &gt;&gt; I prefer later option with simple logic and to eliminate over-head of</span>
<span class=quote>&gt; &gt;&gt; bitmap repopulation in case of differnt page sizes. Later option is</span>
<span class=quote>&gt; &gt;&gt; implemented in this patch.  </span>
<span class=quote>&gt; &gt; </span>
<span class=quote>&gt; &gt; Hmm, we'll see below, but I not convinced based on the above rationale.</span>
<span class=quote>&gt; &gt;   </span>
<span class=quote>&gt; &gt;&gt; Signed-off-by: Kirti Wankhede &lt;kwankhede@nvidia.com&gt;</span>
<span class=quote>&gt; &gt;&gt; Reviewed-by: Neo Jia &lt;cjia@nvidia.com&gt;</span>
<span class=quote>&gt; &gt;&gt; ---</span>
<span class=quote>&gt; &gt;&gt;   drivers/vfio/vfio_iommu_type1.c | 299 ++++++++++++++++++++++++++++++++++++++--</span>
<span class=quote>&gt; &gt;&gt;   1 file changed, 287 insertions(+), 12 deletions(-)</span>
<span class=quote>&gt; &gt;&gt;</span>
<span class=quote>&gt; &gt;&gt; diff --git a/drivers/vfio/vfio_iommu_type1.c b/drivers/vfio/vfio_iommu_type1.c</span>
<span class=quote>&gt; &gt;&gt; index d386461e5d11..df358dc1c85b 100644</span>
<span class=quote>&gt; &gt;&gt; --- a/drivers/vfio/vfio_iommu_type1.c</span>
<span class=quote>&gt; &gt;&gt; +++ b/drivers/vfio/vfio_iommu_type1.c</span>
<span class=quote>&gt; &gt;&gt; @@ -70,6 +70,7 @@ struct vfio_iommu {</span>
<span class=quote>&gt; &gt;&gt;   	unsigned int		dma_avail;</span>
<span class=quote>&gt; &gt;&gt;   	bool			v2;</span>
<span class=quote>&gt; &gt;&gt;   	bool			nesting;</span>
<span class=quote>&gt; &gt;&gt; +	bool			dirty_page_tracking;</span>
<span class=quote>&gt; &gt;&gt;   };</span>
<span class=quote>&gt; &gt;&gt;   </span>
<span class=quote>&gt; &gt;&gt;   struct vfio_domain {</span>
<span class=quote>&gt; &gt;&gt; @@ -90,6 +91,7 @@ struct vfio_dma {</span>
<span class=quote>&gt; &gt;&gt;   	bool			lock_cap;	/* capable(CAP_IPC_LOCK) */</span>
<span class=quote>&gt; &gt;&gt;   	struct task_struct	*task;</span>
<span class=quote>&gt; &gt;&gt;   	struct rb_root		pfn_list;	/* Ex-user pinned pfn list */</span>
<span class=quote>&gt; &gt;&gt; +	unsigned long		*bitmap;</span>
<span class=quote>&gt; &gt;&gt;   };</span>
<span class=quote>&gt; &gt;&gt;   </span>
<span class=quote>&gt; &gt;&gt;   struct vfio_group {</span>
<span class=quote>&gt; &gt;&gt; @@ -125,6 +127,7 @@ struct vfio_regions {</span>
<span class=quote>&gt; &gt;&gt;   					(!list_empty(&amp;iommu-&gt;domain_list))</span>
<span class=quote>&gt; &gt;&gt;   </span>
<span class=quote>&gt; &gt;&gt;   static int put_pfn(unsigned long pfn, int prot);</span>
<span class=quote>&gt; &gt;&gt; +static unsigned long vfio_pgsize_bitmap(struct vfio_iommu *iommu);</span>
<span class=quote>&gt; &gt;&gt;   </span>
<span class=quote>&gt; &gt;&gt;   /*</span>
<span class=quote>&gt; &gt;&gt;    * This code handles mapping and unmapping of user data buffers</span>
<span class=quote>&gt; &gt;&gt; @@ -174,6 +177,57 @@ static void vfio_unlink_dma(struct vfio_iommu *iommu, struct vfio_dma *old)</span>
<span class=quote>&gt; &gt;&gt;   	rb_erase(&amp;old-&gt;node, &amp;iommu-&gt;dma_list);</span>
<span class=quote>&gt; &gt;&gt;   }</span>
<span class=quote>&gt; &gt;&gt;   </span>
<span class=quote>&gt; &gt;&gt; +static inline unsigned long dirty_bitmap_bytes(unsigned int npages)</span>
<span class=quote>&gt; &gt;&gt; +{</span>
<span class=quote>&gt; &gt;&gt; +	if (!npages)</span>
<span class=quote>&gt; &gt;&gt; +		return 0;</span>
<span class=quote>&gt; &gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt; +	return ALIGN(npages, BITS_PER_LONG) / sizeof(unsigned long);</span>
<span class=quote>&gt; &gt;&gt; +}</span>
<span class=quote>&gt; &gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt; +static int vfio_dma_bitmap_alloc(struct vfio_iommu *iommu,</span>
<span class=quote>&gt; &gt;&gt; +				 struct vfio_dma *dma, unsigned long pgsizes)</span>
<span class=quote>&gt; &gt;&gt; +{</span>
<span class=quote>&gt; &gt;&gt; +	unsigned long pgshift = __ffs(pgsizes);</span>
<span class=quote>&gt; &gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt; +	if (!RB_EMPTY_ROOT(&amp;dma-&gt;pfn_list) || dma-&gt;iommu_mapped) {</span>
<span class=quote>&gt; &gt;&gt; +		unsigned long npages = dma-&gt;size &gt;&gt; pgshift;</span>
<span class=quote>&gt; &gt;&gt; +		unsigned long bsize = dirty_bitmap_bytes(npages);</span>
<span class=quote>&gt; &gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt; +		dma-&gt;bitmap = kvzalloc(bsize, GFP_KERNEL);  </span>
<span class=quote>&gt; &gt; </span>
<span class=quote>&gt; &gt; nit, we don't need to store bsize in a local variable.</span>
<span class=quote>&gt; &gt;   </span>
<span class=quote>&gt; &gt;&gt; +		if (!dma-&gt;bitmap)</span>
<span class=quote>&gt; &gt;&gt; +			return -ENOMEM;</span>
<span class=quote>&gt; &gt;&gt; +	}</span>
<span class=quote>&gt; &gt;&gt; +	return 0;</span>
<span class=quote>&gt; &gt;&gt; +}</span>
<span class=quote>&gt; &gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt; +static int vfio_dma_all_bitmap_alloc(struct vfio_iommu *iommu,</span>
<span class=quote>&gt; &gt;&gt; +				     unsigned long pgsizes)</span>
<span class=quote>&gt; &gt;&gt; +{</span>
<span class=quote>&gt; &gt;&gt; +	struct rb_node *n = rb_first(&amp;iommu-&gt;dma_list);</span>
<span class=quote>&gt; &gt;&gt; +	int ret;</span>
<span class=quote>&gt; &gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt; +	for (; n; n = rb_next(n)) {</span>
<span class=quote>&gt; &gt;&gt; +		struct vfio_dma *dma = rb_entry(n, struct vfio_dma, node);</span>
<span class=quote>&gt; &gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt; +		ret = vfio_dma_bitmap_alloc(iommu, dma, pgsizes);</span>
<span class=quote>&gt; &gt;&gt; +		if (ret)</span>
<span class=quote>&gt; &gt;&gt; +			return ret;  </span>
<span class=quote>&gt; &gt; </span>
<span class=quote>&gt; &gt; This doesn't unwind on failure, so we're left with partially allocated</span>
<span class=quote>&gt; &gt; bitmap cruft.</span>
<span class=quote>&gt; &gt;  </span>
<span class=quote>&gt; </span>
<span class=quote>&gt; Good point. Adding unwind on failure.</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; &gt;&gt; +	}</span>
<span class=quote>&gt; &gt;&gt; +	return 0;</span>
<span class=quote>&gt; &gt;&gt; +}</span>
<span class=quote>&gt; &gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt; +static void vfio_dma_all_bitmap_free(struct vfio_iommu *iommu)</span>
<span class=quote>&gt; &gt;&gt; +{</span>
<span class=quote>&gt; &gt;&gt; +	struct rb_node *n = rb_first(&amp;iommu-&gt;dma_list);</span>
<span class=quote>&gt; &gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt; +	for (; n; n = rb_next(n)) {</span>
<span class=quote>&gt; &gt;&gt; +		struct vfio_dma *dma = rb_entry(n, struct vfio_dma, node);</span>
<span class=quote>&gt; &gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt; +		kfree(dma-&gt;bitmap);  </span>
<span class=quote>&gt; &gt; </span>
<span class=quote>&gt; &gt; We don't set dma-&gt;bitmap = NULL and we don't even prevent the case of a</span>
<span class=quote>&gt; &gt; user making multiple STOP calls, so we have a user triggerable double</span>
<span class=quote>&gt; &gt; free :(</span>
<span class=quote>&gt; &gt;   </span>
<span class=quote>&gt; </span>
<span class=quote>&gt; Ok.</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; &gt;&gt; +	}</span>
<span class=quote>&gt; &gt;&gt; +}</span>
<span class=quote>&gt; &gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt;   /*</span>
<span class=quote>&gt; &gt;&gt;    * Helper Functions for host iova-pfn list</span>
<span class=quote>&gt; &gt;&gt;    */</span>
<span class=quote>&gt; &gt;&gt; @@ -244,6 +298,29 @@ static void vfio_remove_from_pfn_list(struct vfio_dma *dma,</span>
<span class=quote>&gt; &gt;&gt;   	kfree(vpfn);</span>
<span class=quote>&gt; &gt;&gt;   }</span>
<span class=quote>&gt; &gt;&gt;   </span>
<span class=quote>&gt; &gt;&gt; +static void vfio_remove_unpinned_from_pfn_list(struct vfio_dma *dma)</span>
<span class=quote>&gt; &gt;&gt; +{</span>
<span class=quote>&gt; &gt;&gt; +	struct rb_node *n = rb_first(&amp;dma-&gt;pfn_list);</span>
<span class=quote>&gt; &gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt; +	for (; n; n = rb_next(n)) {</span>
<span class=quote>&gt; &gt;&gt; +		struct vfio_pfn *vpfn = rb_entry(n, struct vfio_pfn, node);</span>
<span class=quote>&gt; &gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt; +		if (!vpfn-&gt;ref_count)</span>
<span class=quote>&gt; &gt;&gt; +			vfio_remove_from_pfn_list(dma, vpfn);</span>
<span class=quote>&gt; &gt;&gt; +	}</span>
<span class=quote>&gt; &gt;&gt; +}</span>
<span class=quote>&gt; &gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt; +static void vfio_remove_unpinned_from_dma_list(struct vfio_iommu *iommu)</span>
<span class=quote>&gt; &gt;&gt; +{</span>
<span class=quote>&gt; &gt;&gt; +	struct rb_node *n = rb_first(&amp;iommu-&gt;dma_list);</span>
<span class=quote>&gt; &gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt; +	for (; n; n = rb_next(n)) {</span>
<span class=quote>&gt; &gt;&gt; +		struct vfio_dma *dma = rb_entry(n, struct vfio_dma, node);</span>
<span class=quote>&gt; &gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt; +		vfio_remove_unpinned_from_pfn_list(dma);</span>
<span class=quote>&gt; &gt;&gt; +	}</span>
<span class=quote>&gt; &gt;&gt; +}</span>
<span class=quote>&gt; &gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt;   static struct vfio_pfn *vfio_iova_get_vfio_pfn(struct vfio_dma *dma,</span>
<span class=quote>&gt; &gt;&gt;   					       unsigned long iova)</span>
<span class=quote>&gt; &gt;&gt;   {</span>
<span class=quote>&gt; &gt;&gt; @@ -261,7 +338,8 @@ static int vfio_iova_put_vfio_pfn(struct vfio_dma *dma, struct vfio_pfn *vpfn)</span>
<span class=quote>&gt; &gt;&gt;   	vpfn-&gt;ref_count--;</span>
<span class=quote>&gt; &gt;&gt;   	if (!vpfn-&gt;ref_count) {</span>
<span class=quote>&gt; &gt;&gt;   		ret = put_pfn(vpfn-&gt;pfn, dma-&gt;prot);</span>
<span class=quote>&gt; &gt;&gt; -		vfio_remove_from_pfn_list(dma, vpfn);</span>
<span class=quote>&gt; &gt;&gt; +		if (!dma-&gt;bitmap)</span>
<span class=quote>&gt; &gt;&gt; +			vfio_remove_from_pfn_list(dma, vpfn);</span>
<span class=quote>&gt; &gt;&gt;   	}</span>
<span class=quote>&gt; &gt;&gt;   	return ret;</span>
<span class=quote>&gt; &gt;&gt;   }</span>
<span class=quote>&gt; &gt;&gt; @@ -483,13 +561,14 @@ static int vfio_pin_page_external(struct vfio_dma *dma, unsigned long vaddr,</span>
<span class=quote>&gt; &gt;&gt;   	return ret;</span>
<span class=quote>&gt; &gt;&gt;   }</span>
<span class=quote>&gt; &gt;&gt;   </span>
<span class=quote>&gt; &gt;&gt; -static int vfio_unpin_page_external(struct vfio_dma *dma, dma_addr_t iova,</span>
<span class=quote>&gt; &gt;&gt; +static int vfio_unpin_page_external(struct vfio_iommu *iommu,  </span>
<span class=quote>&gt; &gt; </span>
<span class=quote>&gt; &gt; We added a parameter but didn't use it in this patch.</span>
<span class=quote>&gt; &gt;   </span>
<span class=quote>&gt; </span>
<span class=quote>&gt; Ok, Moving it to relevant patch.</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; &gt;&gt; +				    struct vfio_dma *dma, dma_addr_t iova,</span>
<span class=quote>&gt; &gt;&gt;   				    bool do_accounting)</span>
<span class=quote>&gt; &gt;&gt;   {</span>
<span class=quote>&gt; &gt;&gt;   	int unlocked;</span>
<span class=quote>&gt; &gt;&gt;   	struct vfio_pfn *vpfn = vfio_find_vpfn(dma, iova);</span>
<span class=quote>&gt; &gt;&gt;   </span>
<span class=quote>&gt; &gt;&gt; -	if (!vpfn)</span>
<span class=quote>&gt; &gt;&gt; +	if (!vpfn || !vpfn-&gt;ref_count)</span>
<span class=quote>&gt; &gt;&gt;   		return 0;</span>
<span class=quote>&gt; &gt;&gt;   </span>
<span class=quote>&gt; &gt;&gt;   	unlocked = vfio_iova_put_vfio_pfn(dma, vpfn);</span>
<span class=quote>&gt; &gt;&gt; @@ -510,6 +589,7 @@ static int vfio_iommu_type1_pin_pages(void *iommu_data,</span>
<span class=quote>&gt; &gt;&gt;   	unsigned long remote_vaddr;</span>
<span class=quote>&gt; &gt;&gt;   	struct vfio_dma *dma;</span>
<span class=quote>&gt; &gt;&gt;   	bool do_accounting;</span>
<span class=quote>&gt; &gt;&gt; +	unsigned long iommu_pgsizes = vfio_pgsize_bitmap(iommu);</span>
<span class=quote>&gt; &gt;&gt;   </span>
<span class=quote>&gt; &gt;&gt;   	if (!iommu || !user_pfn || !phys_pfn)</span>
<span class=quote>&gt; &gt;&gt;   		return -EINVAL;</span>
<span class=quote>&gt; &gt;&gt; @@ -551,8 +631,10 @@ static int vfio_iommu_type1_pin_pages(void *iommu_data,</span>
<span class=quote>&gt; &gt;&gt;   </span>
<span class=quote>&gt; &gt;&gt;   		vpfn = vfio_iova_get_vfio_pfn(dma, iova);</span>
<span class=quote>&gt; &gt;&gt;   		if (vpfn) {</span>
<span class=quote>&gt; &gt;&gt; -			phys_pfn[i] = vpfn-&gt;pfn;</span>
<span class=quote>&gt; &gt;&gt; -			continue;</span>
<span class=quote>&gt; &gt;&gt; +			if (vpfn-&gt;ref_count &gt; 1) {</span>
<span class=quote>&gt; &gt;&gt; +				phys_pfn[i] = vpfn-&gt;pfn;</span>
<span class=quote>&gt; &gt;&gt; +				continue;</span>
<span class=quote>&gt; &gt;&gt; +			}</span>
<span class=quote>&gt; &gt;&gt;   		}</span>
<span class=quote>&gt; &gt;&gt;   </span>
<span class=quote>&gt; &gt;&gt;   		remote_vaddr = dma-&gt;vaddr + iova - dma-&gt;iova;</span>
<span class=quote>&gt; &gt;&gt; @@ -560,11 +642,23 @@ static int vfio_iommu_type1_pin_pages(void *iommu_data,</span>
<span class=quote>&gt; &gt;&gt;   					     do_accounting);</span>
<span class=quote>&gt; &gt;&gt;   		if (ret)</span>
<span class=quote>&gt; &gt;&gt;   			goto pin_unwind;</span>
<span class=quote>&gt; &gt;&gt; -</span>
<span class=quote>&gt; &gt;&gt; -		ret = vfio_add_to_pfn_list(dma, iova, phys_pfn[i]);</span>
<span class=quote>&gt; &gt;&gt; -		if (ret) {</span>
<span class=quote>&gt; &gt;&gt; -			vfio_unpin_page_external(dma, iova, do_accounting);</span>
<span class=quote>&gt; &gt;&gt; -			goto pin_unwind;</span>
<span class=quote>&gt; &gt;&gt; +		if (!vpfn) {</span>
<span class=quote>&gt; &gt;&gt; +			ret = vfio_add_to_pfn_list(dma, iova, phys_pfn[i]);</span>
<span class=quote>&gt; &gt;&gt; +			if (ret) {</span>
<span class=quote>&gt; &gt;&gt; +				vfio_unpin_page_external(iommu, dma, iova,</span>
<span class=quote>&gt; &gt;&gt; +							 do_accounting);</span>
<span class=quote>&gt; &gt;&gt; +				goto pin_unwind;</span>
<span class=quote>&gt; &gt;&gt; +			}</span>
<span class=quote>&gt; &gt;&gt; +		} else</span>
<span class=quote>&gt; &gt;&gt; +			vpfn-&gt;pfn = phys_pfn[i];</span>
<span class=quote>&gt; &gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt; +		if (iommu-&gt;dirty_page_tracking &amp;&amp; !dma-&gt;bitmap) {</span>
<span class=quote>&gt; &gt;&gt; +			ret = vfio_dma_bitmap_alloc(iommu, dma, iommu_pgsizes);</span>
<span class=quote>&gt; &gt;&gt; +			if (ret) {</span>
<span class=quote>&gt; &gt;&gt; +				vfio_unpin_page_external(iommu, dma, iova,</span>
<span class=quote>&gt; &gt;&gt; +							 do_accounting);</span>
<span class=quote>&gt; &gt;&gt; +				goto pin_unwind;</span>
<span class=quote>&gt; &gt;&gt; +			}</span>
<span class=quote>&gt; &gt;&gt;   		}</span>
<span class=quote>&gt; &gt;&gt;   	}</span>
<span class=quote>&gt; &gt;&gt;   </span>
<span class=quote>&gt; &gt;&gt; @@ -578,7 +672,7 @@ static int vfio_iommu_type1_pin_pages(void *iommu_data,</span>
<span class=quote>&gt; &gt;&gt;   </span>
<span class=quote>&gt; &gt;&gt;   		iova = user_pfn[j] &lt;&lt; PAGE_SHIFT;</span>
<span class=quote>&gt; &gt;&gt;   		dma = vfio_find_dma(iommu, iova, PAGE_SIZE);</span>
<span class=quote>&gt; &gt;&gt; -		vfio_unpin_page_external(dma, iova, do_accounting);</span>
<span class=quote>&gt; &gt;&gt; +		vfio_unpin_page_external(iommu, dma, iova, do_accounting);</span>
<span class=quote>&gt; &gt;&gt;   		phys_pfn[j] = 0;</span>
<span class=quote>&gt; &gt;&gt;   	}</span>
<span class=quote>&gt; &gt;&gt;   pin_done:</span>
<span class=quote>&gt; &gt;&gt; @@ -612,7 +706,7 @@ static int vfio_iommu_type1_unpin_pages(void *iommu_data,</span>
<span class=quote>&gt; &gt;&gt;   		dma = vfio_find_dma(iommu, iova, PAGE_SIZE);</span>
<span class=quote>&gt; &gt;&gt;   		if (!dma)</span>
<span class=quote>&gt; &gt;&gt;   			goto unpin_exit;</span>
<span class=quote>&gt; &gt;&gt; -		vfio_unpin_page_external(dma, iova, do_accounting);</span>
<span class=quote>&gt; &gt;&gt; +		vfio_unpin_page_external(iommu, dma, iova, do_accounting);</span>
<span class=quote>&gt; &gt;&gt;   	}</span>
<span class=quote>&gt; &gt;&gt;   </span>
<span class=quote>&gt; &gt;&gt;   unpin_exit:</span>
<span class=quote>&gt; &gt;&gt; @@ -830,6 +924,113 @@ static unsigned long vfio_pgsize_bitmap(struct vfio_iommu *iommu)</span>
<span class=quote>&gt; &gt;&gt;   	return bitmap;</span>
<span class=quote>&gt; &gt;&gt;   }</span>
<span class=quote>&gt; &gt;&gt;   </span>
<span class=quote>&gt; &gt;&gt; +static int vfio_iova_dirty_bitmap(struct vfio_iommu *iommu, dma_addr_t iova,</span>
<span class=quote>&gt; &gt;&gt; +				  size_t size, uint64_t pgsize,</span>
<span class=quote>&gt; &gt;&gt; +				  unsigned char __user *bitmap)</span>
<span class=quote>&gt; &gt;&gt; +{</span>
<span class=quote>&gt; &gt;&gt; +	struct vfio_dma *dma;</span>
<span class=quote>&gt; &gt;&gt; +	dma_addr_t i = iova, iova_limit;</span>
<span class=quote>&gt; &gt;&gt; +	unsigned int bsize, nbits = 0, l = 0;</span>
<span class=quote>&gt; &gt;&gt; +	unsigned long pgshift = __ffs(pgsize);</span>
<span class=quote>&gt; &gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt; +	while ((dma = vfio_find_dma(iommu, i, pgsize))) {</span>
<span class=quote>&gt; &gt;&gt; +		int ret, j;</span>
<span class=quote>&gt; &gt;&gt; +		unsigned int npages = 0, shift = 0;</span>
<span class=quote>&gt; &gt;&gt; +		unsigned char temp = 0;</span>
<span class=quote>&gt; &gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt; +		/* mark all pages dirty if all pages are pinned and mapped. */</span>
<span class=quote>&gt; &gt;&gt; +		if (dma-&gt;iommu_mapped) {</span>
<span class=quote>&gt; &gt;&gt; +			iova_limit = min(dma-&gt;iova + dma-&gt;size, iova + size);</span>
<span class=quote>&gt; &gt;&gt; +			npages = iova_limit/pgsize;</span>
<span class=quote>&gt; &gt;&gt; +			bitmap_set(dma-&gt;bitmap, 0, npages);  </span>
<span class=quote>&gt; &gt; </span>
<span class=quote>&gt; &gt; npages is derived from iova_limit, which is the number of bits to set</span>
<span class=quote>&gt; &gt; dirty relative to the first requested iova, not iova zero, ie. the set</span>
<span class=quote>&gt; &gt; of dirty bits is offset from those requested unless iova == dma-&gt;iova.</span>
<span class=quote>&gt; &gt;   </span>
<span class=quote>&gt; </span>
<span class=quote>&gt; Right, fixing.</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; &gt; Also I hope dma-&gt;bitmap was actually allocated.  Not only does the</span>
<span class=quote>&gt; &gt; START error path potentially leave dirty tracking enabled without all</span>
<span class=quote>&gt; &gt; the bitmap allocated, when does the bitmap get allocated for a new</span>
<span class=quote>&gt; &gt; vfio_dma when dirty tracking is enabled?  Seems it only occurs if a</span>
<span class=quote>&gt; &gt; vpfn gets marked dirty.</span>
<span class=quote>&gt; &gt;   </span>
<span class=quote>&gt; </span>
<span class=quote>&gt; Right.</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; Fixing error paths.</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; </span>
<span class=quote>&gt; &gt;&gt; +		} else if (dma-&gt;bitmap) {</span>
<span class=quote>&gt; &gt;&gt; +			struct rb_node *n = rb_first(&amp;dma-&gt;pfn_list);</span>
<span class=quote>&gt; &gt;&gt; +			bool found = false;</span>
<span class=quote>&gt; &gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt; +			for (; n; n = rb_next(n)) {</span>
<span class=quote>&gt; &gt;&gt; +				struct vfio_pfn *vpfn = rb_entry(n,</span>
<span class=quote>&gt; &gt;&gt; +						struct vfio_pfn, node);</span>
<span class=quote>&gt; &gt;&gt; +				if (vpfn-&gt;iova &gt;= i) {</span>
<span class=quote>&gt; &gt;&gt; +					found = true;</span>
<span class=quote>&gt; &gt;&gt; +					break;</span>
<span class=quote>&gt; &gt;&gt; +				}</span>
<span class=quote>&gt; &gt;&gt; +			}</span>
<span class=quote>&gt; &gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt; +			if (!found) {</span>
<span class=quote>&gt; &gt;&gt; +				i += dma-&gt;size;</span>
<span class=quote>&gt; &gt;&gt; +				continue;</span>
<span class=quote>&gt; &gt;&gt; +			}</span>
<span class=quote>&gt; &gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt; +			for (; n; n = rb_next(n)) {</span>
<span class=quote>&gt; &gt;&gt; +				unsigned int s;</span>
<span class=quote>&gt; &gt;&gt; +				struct vfio_pfn *vpfn = rb_entry(n,</span>
<span class=quote>&gt; &gt;&gt; +						struct vfio_pfn, node);</span>
<span class=quote>&gt; &gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt; +				if (vpfn-&gt;iova &gt;= iova + size)</span>
<span class=quote>&gt; &gt;&gt; +					break;</span>
<span class=quote>&gt; &gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt; +				s = (vpfn-&gt;iova - dma-&gt;iova) &gt;&gt; pgshift;</span>
<span class=quote>&gt; &gt;&gt; +				bitmap_set(dma-&gt;bitmap, s, 1);</span>
<span class=quote>&gt; &gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt; +				iova_limit = vpfn-&gt;iova + pgsize;</span>
<span class=quote>&gt; &gt;&gt; +			}</span>
<span class=quote>&gt; &gt;&gt; +			npages = iova_limit/pgsize;  </span>
<span class=quote>&gt; &gt; </span>
<span class=quote>&gt; &gt; Isn't iova_limit potentially uninitialized here?  For example, if our</span>
<span class=quote>&gt; &gt; vfio_dma covers {0,8192} and we ask for the bitmap of {0,4096} and</span>
<span class=quote>&gt; &gt; there's a vpfn at {4096,8192}.  I think that means vpfn-&gt;iova &gt;= i</span>
<span class=quote>&gt; &gt; (4096 &gt;= 0), so we break with found = true, then we test 4096 &gt;= 0 +</span>
<span class=quote>&gt; &gt; 4096 and break, and npages = ????/pgsize.</span>
<span class=quote>&gt; &gt;   </span>
<span class=quote>&gt; </span>
<span class=quote>&gt; Right, Fixing it.</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; &gt;&gt; +		}</span>
<span class=quote>&gt; &gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt; +		bsize = dirty_bitmap_bytes(npages);</span>
<span class=quote>&gt; &gt;&gt; +		shift = nbits % BITS_PER_BYTE;</span>
<span class=quote>&gt; &gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt; +		if (npages &amp;&amp; shift) {</span>
<span class=quote>&gt; &gt;&gt; +			l--;</span>
<span class=quote>&gt; &gt;&gt; +			if (!access_ok((void __user *)bitmap + l,</span>
<span class=quote>&gt; &gt;&gt; +					sizeof(unsigned char)))</span>
<span class=quote>&gt; &gt;&gt; +				return -EINVAL;</span>
<span class=quote>&gt; &gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt; +			ret = __get_user(temp, bitmap + l);  </span>
<span class=quote>&gt; &gt; </span>
<span class=quote>&gt; &gt; I don't understand why we care to get the user's bitmap, are we trying</span>
<span class=quote>&gt; &gt; to leave whatever garbage they might have set in it and only also set</span>
<span class=quote>&gt; &gt; the dirty bits?  That seems unnecessary.</span>
<span class=quote>&gt; &gt;   </span>
<span class=quote>&gt; </span>
<span class=quote>&gt; Suppose dma mapped ranges are {start, size}:</span>
<span class=quote>&gt; {0, 0xa000}, {0xa000, 0x10000}</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; Bitmap asked from 0 - 0x10000. Say suppose all pages are dirty.</span>
<span class=quote>&gt; Then in first iteration for dma {0,0xa000} there are 10 pages, so 10 </span>
<span class=quote>&gt; bits are set, put_user() happens for 2 bytes, (00000011 11111111b).</span>
<span class=quote>&gt; In second iteration for dma {0xa000, 0x10000} there are 6 pages and </span>
<span class=quote>&gt; these bits should be appended to previous byte. So get_user() that byte, </span>
<span class=quote>&gt; then shift-OR rest of the bitmap, result should be: (11111111 11111111b)</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; Without get_user() and shift-OR, resulting bitmap would be</span>
<span class=quote>&gt; 111111 00000011 11111111b which would be wrong.</span>

Seems like if we use a put_user() approach then we should look for
adjacent vfio_dmas within the same byte/word/dword before we push it to
the user to avoid this sort of inefficiency.
<span class=quote>
&gt; &gt; Also why do we need these access_ok() checks when we already checked</span>
<span class=quote>&gt; &gt; the range at the start of the ioctl?  </span>
<span class=quote>&gt; </span>
<span class=quote>&gt; Since pointer is updated runtime here, better to check that pointer </span>
<span class=quote>&gt; before using that pointer.</span>

Sorry, I still don't understand this, we check access_ok() with a
pointer and a length, therefore as long as we're incrementing the
pointer within that length, why do we need to retest?
<span class=quote>
&gt; &gt;   </span>
<span class=quote>&gt; &gt;&gt; +			if (ret)</span>
<span class=quote>&gt; &gt;&gt; +				return ret;</span>
<span class=quote>&gt; &gt;&gt; +		}</span>
<span class=quote>&gt; &gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt; +		for (j = 0; j &lt; bsize; j++, l++) {</span>
<span class=quote>&gt; &gt;&gt; +			temp = temp |</span>
<span class=quote>&gt; &gt;&gt; +			       (*((unsigned char *)dma-&gt;bitmap + j) &lt;&lt; shift);  </span>
<span class=quote>&gt; &gt; </span>
<span class=quote>&gt; &gt; |=</span>
<span class=quote>&gt; &gt;   </span>
<span class=quote>&gt; &gt;&gt; +			if (!access_ok((void __user *)bitmap + l,</span>
<span class=quote>&gt; &gt;&gt; +					sizeof(unsigned char)))</span>
<span class=quote>&gt; &gt;&gt; +				return -EINVAL;</span>
<span class=quote>&gt; &gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt; +			ret = __put_user(temp, bitmap + l);</span>
<span class=quote>&gt; &gt;&gt; +			if (ret)</span>
<span class=quote>&gt; &gt;&gt; +				return ret;</span>
<span class=quote>&gt; &gt;&gt; +			if (shift) {</span>
<span class=quote>&gt; &gt;&gt; +				temp = *((unsigned char *)dma-&gt;bitmap + j) &gt;&gt;</span>
<span class=quote>&gt; &gt;&gt; +					(BITS_PER_BYTE - shift);</span>
<span class=quote>&gt; &gt;&gt; +			}  </span>
<span class=quote>&gt; &gt; </span>
<span class=quote>&gt; &gt; When shift == 0, temp just seems to accumulate bits that never get</span>
<span class=quote>&gt; &gt; cleared.</span>
<span class=quote>&gt; &gt;   </span>
<span class=quote>&gt; </span>
<span class=quote>&gt; Hope example above explains the shift logic.</span>

But that example is when shift is non-zero.  When shift is zero, each
iteration of the loop just ORs in new bits to temp without ever
clearing the bits for the previous iteration.
<span class=quote>

&gt; &gt;&gt; +		}</span>
<span class=quote>&gt; &gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt; +		nbits += npages;</span>
<span class=quote>&gt; &gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt; +		i = min(dma-&gt;iova + dma-&gt;size, iova + size);</span>
<span class=quote>&gt; &gt;&gt; +		if (i &gt;= iova + size)</span>
<span class=quote>&gt; &gt;&gt; +			break;  </span>
<span class=quote>&gt; &gt; </span>
<span class=quote>&gt; &gt; So whether we error or succeed, we leave cruft in dma-&gt;bitmap for the</span>
<span class=quote>&gt; &gt; next pass.  It doesn't seem to make any sense why we pre-allocated the</span>
<span class=quote>&gt; &gt; bitmap, we might as well just allocate it on demand here.  Actually, if</span>
<span class=quote>&gt; &gt; we're not going to do a copy_to_user() for some range of the bitmap,</span>
<span class=quote>&gt; &gt; I'm not sure what it's purpose is at all.  I think the big advantages</span>
<span class=quote>&gt; &gt; of the bitmap are that we can't amortize the cost across every pinned</span>
<span class=quote>&gt; &gt; page or DMA mapping, we don't need the overhead of tracking unmapped</span>
<span class=quote>&gt; &gt; vpfns, and we can use copy_to_user() to push the bitmap out.  We're not</span>
<span class=quote>&gt; &gt; getting any of those advantages here.</span>
<span class=quote>&gt; &gt;   </span>
<span class=quote>&gt; </span>
<span class=quote>&gt; That would still not work if dma range size is not multiples of 8 pages. </span>
<span class=quote>&gt; See example above.</span>

I don't understand this comment, what about the example above justifies
the bitmap?  As I understand the above algorithm, we find a vfio_dma
overlapping the request and populate the bitmap for that range.  Then
we go back and put_user() for each byte that we touched.  We could
instead simply work on a one byte buffer as we enumerate the requested
range and do a put_user() ever time we reach the end of it and have bits
set.  That would greatly simplify the above example.  But I would expect
that we're a) more likely to get asked for ranges covering a single
vfio_dma and b) we're going to spend far more time operating in the
middle of the range and limiting ourselves to one-byte operations there
seems absurd.  If we want to specify that the user provides 4-byte
aligned buffers and naturally aligned iova ranges to make our lives
easier in the kernel, now would be the time to do that.
<span class=quote>
&gt; &gt;&gt; +	}</span>
<span class=quote>&gt; &gt;&gt; +	return 0;</span>
<span class=quote>&gt; &gt;&gt; +}</span>
<span class=quote>&gt; &gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt; +static long verify_bitmap_size(unsigned long npages, unsigned long bitmap_size)</span>
<span class=quote>&gt; &gt;&gt; +{</span>
<span class=quote>&gt; &gt;&gt; +	long bsize;</span>
<span class=quote>&gt; &gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt; +	if (!bitmap_size || bitmap_size &gt; SIZE_MAX)</span>
<span class=quote>&gt; &gt;&gt; +		return -EINVAL;</span>
<span class=quote>&gt; &gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt; +	bsize = dirty_bitmap_bytes(npages);</span>
<span class=quote>&gt; &gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt; +	if (bitmap_size &lt; bsize)</span>
<span class=quote>&gt; &gt;&gt; +		return -EINVAL;</span>
<span class=quote>&gt; &gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt; +	return bsize;</span>
<span class=quote>&gt; &gt;&gt; +}  </span>
<span class=quote>&gt; &gt; </span>
<span class=quote>&gt; &gt; Seems like this could simply return int, -errno or zero for success.</span>
<span class=quote>&gt; &gt; The returned bsize is not used for anything else.</span>
<span class=quote>&gt; &gt;   </span>
<span class=quote>&gt; </span>
<span class=quote>&gt; ok.</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; &gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt;   static int vfio_dma_do_unmap(struct vfio_iommu *iommu,</span>
<span class=quote>&gt; &gt;&gt;   			     struct vfio_iommu_type1_dma_unmap *unmap)</span>
<span class=quote>&gt; &gt;&gt;   {</span>
<span class=quote>&gt; &gt;&gt; @@ -2277,6 +2478,80 @@ static long vfio_iommu_type1_ioctl(void *iommu_data,</span>
<span class=quote>&gt; &gt;&gt;   </span>
<span class=quote>&gt; &gt;&gt;   		return copy_to_user((void __user *)arg, &amp;unmap, minsz) ?</span>
<span class=quote>&gt; &gt;&gt;   			-EFAULT : 0;</span>
<span class=quote>&gt; &gt;&gt; +	} else if (cmd == VFIO_IOMMU_DIRTY_PAGES) {</span>
<span class=quote>&gt; &gt;&gt; +		struct vfio_iommu_type1_dirty_bitmap range;</span>
<span class=quote>&gt; &gt;&gt; +		uint32_t mask = VFIO_IOMMU_DIRTY_PAGES_FLAG_START |</span>
<span class=quote>&gt; &gt;&gt; +				VFIO_IOMMU_DIRTY_PAGES_FLAG_STOP |</span>
<span class=quote>&gt; &gt;&gt; +				VFIO_IOMMU_DIRTY_PAGES_FLAG_GET_BITMAP;</span>
<span class=quote>&gt; &gt;&gt; +		int ret;</span>
<span class=quote>&gt; &gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt; +		if (!iommu-&gt;v2)</span>
<span class=quote>&gt; &gt;&gt; +			return -EACCES;</span>
<span class=quote>&gt; &gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt; +		minsz = offsetofend(struct vfio_iommu_type1_dirty_bitmap,</span>
<span class=quote>&gt; &gt;&gt; +				    bitmap);  </span>
<span class=quote>&gt; &gt; </span>
<span class=quote>&gt; &gt; We require the user to provide iova, size, pgsize, bitmap_size, and</span>
<span class=quote>&gt; &gt; bitmap fields to START/STOP?  Why?</span>
<span class=quote>&gt; &gt;  </span>
<span class=quote>&gt; </span>
<span class=quote>&gt; No. But those are part of structure.</span>

But we do require it, minsz here includes all those fields, which would
probably make a user scratch their head wondering why they need to pass
irrelevant data for START/STOP.  It almost implies that we support
starting and stopping dirty logging for specific ranges of the IOVA
space.  We could define the structure, for example:

struct vfio_iommu_type1_dirty_bitmap {
	__u32	argsz;
	__u32	flags;
	__u8	data[];
};

struct vfio_iommu_type1_dirty_bitmap_get {
	__u64	iova;
	__u64	size;
	__u64	pgsize;
	__u64	bitmap_size;
	void __user *bitmap;
};

Where data[] is defined as the latter structure when FLAG_GET_BITMAP is
specified.  BTW, don't we need to specify the trailing void* as __u64?
We could theoretically be talking to an ILP32 user process.  Thanks,

Alex
<span class=quote>
&gt; &gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt; +		if (copy_from_user(&amp;range, (void __user *)arg, minsz))</span>
<span class=quote>&gt; &gt;&gt; +			return -EFAULT;</span>
<span class=quote>&gt; &gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt; +		if (range.argsz &lt; minsz || range.flags &amp; ~mask)</span>
<span class=quote>&gt; &gt;&gt; +			return -EINVAL;</span>
<span class=quote>&gt; &gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt; +		/* only one flag should be set at a time */</span>
<span class=quote>&gt; &gt;&gt; +		if (__ffs(range.flags) != __fls(range.flags))</span>
<span class=quote>&gt; &gt;&gt; +			return -EINVAL;</span>
<span class=quote>&gt; &gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt; +		if (range.flags &amp; VFIO_IOMMU_DIRTY_PAGES_FLAG_START) {</span>
<span class=quote>&gt; &gt;&gt; +			unsigned long iommu_pgsizes = vfio_pgsize_bitmap(iommu);</span>
<span class=quote>&gt; &gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt; +			mutex_lock(&amp;iommu-&gt;lock);</span>
<span class=quote>&gt; &gt;&gt; +			iommu-&gt;dirty_page_tracking = true;</span>
<span class=quote>&gt; &gt;&gt; +			ret = vfio_dma_all_bitmap_alloc(iommu, iommu_pgsizes);  </span>
<span class=quote>&gt; &gt; </span>
<span class=quote>&gt; &gt; So dirty page tracking is enabled even if we fail to allocate all the</span>
<span class=quote>&gt; &gt; bitmaps?  Shouldn't this return an error if dirty tracking is already</span>
<span class=quote>&gt; &gt; enabled?</span>
<span class=quote>&gt; &gt;   </span>
<span class=quote>&gt; </span>
<span class=quote>&gt; Adding error handling here in next patch.</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; &gt;&gt; +			mutex_unlock(&amp;iommu-&gt;lock);</span>
<span class=quote>&gt; &gt;&gt; +			return ret;</span>
<span class=quote>&gt; &gt;&gt; +		} else if (range.flags &amp; VFIO_IOMMU_DIRTY_PAGES_FLAG_STOP) {</span>
<span class=quote>&gt; &gt;&gt; +			mutex_lock(&amp;iommu-&gt;lock);</span>
<span class=quote>&gt; &gt;&gt; +			iommu-&gt;dirty_page_tracking = false;  </span>
<span class=quote>&gt; &gt; </span>
<span class=quote>&gt; &gt; Shouldn't we only allow STOP if tracking is enabled?</span>
<span class=quote>&gt; &gt;   </span>
<span class=quote>&gt; </span>
<span class=quote>&gt; Right,adding.</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; &gt;&gt; +			vfio_dma_all_bitmap_free(iommu);  </span>
<span class=quote>&gt; &gt; </span>
<span class=quote>&gt; &gt; Here's where that user induced double free enters the picture.</span>
<span class=quote>&gt; &gt;   </span>
<span class=quote>&gt; </span>
<span class=quote>&gt; Error handling as mentioned above will prevent double free.</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; Thanks,</span>
<span class=quote>&gt; Kirti</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; &gt;&gt; +			vfio_remove_unpinned_from_dma_list(iommu);</span>
<span class=quote>&gt; &gt;&gt; +			mutex_unlock(&amp;iommu-&gt;lock);</span>
<span class=quote>&gt; &gt;&gt; +			return 0;</span>
<span class=quote>&gt; &gt;&gt; +		} else if (range.flags &amp;</span>
<span class=quote>&gt; &gt;&gt; +				 VFIO_IOMMU_DIRTY_PAGES_FLAG_GET_BITMAP) {</span>
<span class=quote>&gt; &gt;&gt; +			long bsize;</span>
<span class=quote>&gt; &gt;&gt; +			unsigned long pgshift = __ffs(range.pgsize);</span>
<span class=quote>&gt; &gt;&gt; +			uint64_t iommu_pgsizes = vfio_pgsize_bitmap(iommu);</span>
<span class=quote>&gt; &gt;&gt; +			uint64_t iommu_pgmask =</span>
<span class=quote>&gt; &gt;&gt; +				 ((uint64_t)1 &lt;&lt; __ffs(iommu_pgsizes)) - 1;</span>
<span class=quote>&gt; &gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt; +			if ((range.pgsize &amp; iommu_pgsizes) != range.pgsize)</span>
<span class=quote>&gt; &gt;&gt; +				return -EINVAL;</span>
<span class=quote>&gt; &gt;&gt; +			if (range.iova &amp; iommu_pgmask)</span>
<span class=quote>&gt; &gt;&gt; +				return -EINVAL;</span>
<span class=quote>&gt; &gt;&gt; +			if (!range.size || range.size &amp; iommu_pgmask)</span>
<span class=quote>&gt; &gt;&gt; +				return -EINVAL;</span>
<span class=quote>&gt; &gt;&gt; +			if (range.iova + range.size &lt; range.iova)</span>
<span class=quote>&gt; &gt;&gt; +				return -EINVAL;</span>
<span class=quote>&gt; &gt;&gt; +			if (!access_ok((void __user *)range.bitmap,</span>
<span class=quote>&gt; &gt;&gt; +				       range.bitmap_size))</span>
<span class=quote>&gt; &gt;&gt; +				return -EINVAL;</span>
<span class=quote>&gt; &gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt; +			bsize = verify_bitmap_size(range.size &gt;&gt; pgshift,</span>
<span class=quote>&gt; &gt;&gt; +						   range.bitmap_size);</span>
<span class=quote>&gt; &gt;&gt; +			if (bsize &lt; 0)</span>
<span class=quote>&gt; &gt;&gt; +				return bsize;</span>
<span class=quote>&gt; &gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt; +			mutex_lock(&amp;iommu-&gt;lock);</span>
<span class=quote>&gt; &gt;&gt; +			if (iommu-&gt;dirty_page_tracking)</span>
<span class=quote>&gt; &gt;&gt; +				ret = vfio_iova_dirty_bitmap(iommu, range.iova,</span>
<span class=quote>&gt; &gt;&gt; +					 range.size, range.pgsize,</span>
<span class=quote>&gt; &gt;&gt; +					 (unsigned char __user *)range.bitmap);</span>
<span class=quote>&gt; &gt;&gt; +			else</span>
<span class=quote>&gt; &gt;&gt; +				ret = -EINVAL;</span>
<span class=quote>&gt; &gt;&gt; +			mutex_unlock(&amp;iommu-&gt;lock);</span>
<span class=quote>&gt; &gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt; +			return ret;</span>
<span class=quote>&gt; &gt;&gt; +		}</span>
<span class=quote>&gt; &gt;&gt;   	}</span>
<span class=quote>&gt; &gt;&gt;   </span>
<span class=quote>&gt; &gt;&gt;   	return -ENOTTY;  </span>
<span class=quote>&gt; &gt; </span>
<span class=quote>&gt; &gt; Thanks,</span>
<span class=quote>&gt; &gt; Alex</span>
<span class=quote>&gt; &gt;   </span>
<span class=quote>&gt;</span>
</pre>
</div>
<a name=23156013></a>
<div class=comment>
<div class=meta>
 <span><a href="https://patchwork.kernel.org/project/qemu-devel/list/?submitter=153211">Kirti Wankhede</a></span>
 <span class=pull-right>Feb. 13, 2020, 8:11 p.m. UTC | <a href=https://patchwork.kernel.org/comment/23156013/>#9</a></span>
</div>
<pre class=content>&lt;snip&gt;
<span class=quote>
&gt;&gt;&gt;&gt;    </span>
<span class=quote>&gt;&gt;&gt;&gt; +static int vfio_iova_dirty_bitmap(struct vfio_iommu *iommu, dma_addr_t iova,</span>
<span class=quote>&gt;&gt;&gt;&gt; +				  size_t size, uint64_t pgsize,</span>
<span class=quote>&gt;&gt;&gt;&gt; +				  unsigned char __user *bitmap)</span>
<span class=quote>&gt;&gt;&gt;&gt; +{</span>
<span class=quote>&gt;&gt;&gt;&gt; +	struct vfio_dma *dma;</span>
<span class=quote>&gt;&gt;&gt;&gt; +	dma_addr_t i = iova, iova_limit;</span>
<span class=quote>&gt;&gt;&gt;&gt; +	unsigned int bsize, nbits = 0, l = 0;</span>
<span class=quote>&gt;&gt;&gt;&gt; +	unsigned long pgshift = __ffs(pgsize);</span>
<span class=quote>&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt;&gt; +	while ((dma = vfio_find_dma(iommu, i, pgsize))) {</span>
<span class=quote>&gt;&gt;&gt;&gt; +		int ret, j;</span>
<span class=quote>&gt;&gt;&gt;&gt; +		unsigned int npages = 0, shift = 0;</span>
<span class=quote>&gt;&gt;&gt;&gt; +		unsigned char temp = 0;</span>
<span class=quote>&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt;&gt; +		/* mark all pages dirty if all pages are pinned and mapped. */</span>
<span class=quote>&gt;&gt;&gt;&gt; +		if (dma-&gt;iommu_mapped) {</span>
<span class=quote>&gt;&gt;&gt;&gt; +			iova_limit = min(dma-&gt;iova + dma-&gt;size, iova + size);</span>
<span class=quote>&gt;&gt;&gt;&gt; +			npages = iova_limit/pgsize;</span>
<span class=quote>&gt;&gt;&gt;&gt; +			bitmap_set(dma-&gt;bitmap, 0, npages);</span>
<span class=quote>&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt; npages is derived from iova_limit, which is the number of bits to set</span>
<span class=quote>&gt;&gt;&gt; dirty relative to the first requested iova, not iova zero, ie. the set</span>
<span class=quote>&gt;&gt;&gt; of dirty bits is offset from those requested unless iova == dma-&gt;iova.</span>
<span class=quote>&gt;&gt;&gt;    </span>
<span class=quote>&gt;&gt;</span>
<span class=quote>&gt;&gt; Right, fixing.</span>
<span class=quote>&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt; Also I hope dma-&gt;bitmap was actually allocated.  Not only does the</span>
<span class=quote>&gt;&gt;&gt; START error path potentially leave dirty tracking enabled without all</span>
<span class=quote>&gt;&gt;&gt; the bitmap allocated, when does the bitmap get allocated for a new</span>
<span class=quote>&gt;&gt;&gt; vfio_dma when dirty tracking is enabled?  Seems it only occurs if a</span>
<span class=quote>&gt;&gt;&gt; vpfn gets marked dirty.</span>
<span class=quote>&gt;&gt;&gt;    </span>
<span class=quote>&gt;&gt;</span>
<span class=quote>&gt;&gt; Right.</span>
<span class=quote>&gt;&gt;</span>
<span class=quote>&gt;&gt; Fixing error paths.</span>
<span class=quote>&gt;&gt;</span>
<span class=quote>&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt;&gt; +		} else if (dma-&gt;bitmap) {</span>
<span class=quote>&gt;&gt;&gt;&gt; +			struct rb_node *n = rb_first(&amp;dma-&gt;pfn_list);</span>
<span class=quote>&gt;&gt;&gt;&gt; +			bool found = false;</span>
<span class=quote>&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt;&gt; +			for (; n; n = rb_next(n)) {</span>
<span class=quote>&gt;&gt;&gt;&gt; +				struct vfio_pfn *vpfn = rb_entry(n,</span>
<span class=quote>&gt;&gt;&gt;&gt; +						struct vfio_pfn, node);</span>
<span class=quote>&gt;&gt;&gt;&gt; +				if (vpfn-&gt;iova &gt;= i) {</span>
<span class=quote>&gt;&gt;&gt;&gt; +					found = true;</span>
<span class=quote>&gt;&gt;&gt;&gt; +					break;</span>
<span class=quote>&gt;&gt;&gt;&gt; +				}</span>
<span class=quote>&gt;&gt;&gt;&gt; +			}</span>
<span class=quote>&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt;&gt; +			if (!found) {</span>
<span class=quote>&gt;&gt;&gt;&gt; +				i += dma-&gt;size;</span>
<span class=quote>&gt;&gt;&gt;&gt; +				continue;</span>
<span class=quote>&gt;&gt;&gt;&gt; +			}</span>
<span class=quote>&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt;&gt; +			for (; n; n = rb_next(n)) {</span>
<span class=quote>&gt;&gt;&gt;&gt; +				unsigned int s;</span>
<span class=quote>&gt;&gt;&gt;&gt; +				struct vfio_pfn *vpfn = rb_entry(n,</span>
<span class=quote>&gt;&gt;&gt;&gt; +						struct vfio_pfn, node);</span>
<span class=quote>&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt;&gt; +				if (vpfn-&gt;iova &gt;= iova + size)</span>
<span class=quote>&gt;&gt;&gt;&gt; +					break;</span>
<span class=quote>&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt;&gt; +				s = (vpfn-&gt;iova - dma-&gt;iova) &gt;&gt; pgshift;</span>
<span class=quote>&gt;&gt;&gt;&gt; +				bitmap_set(dma-&gt;bitmap, s, 1);</span>
<span class=quote>&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt;&gt; +				iova_limit = vpfn-&gt;iova + pgsize;</span>
<span class=quote>&gt;&gt;&gt;&gt; +			}</span>
<span class=quote>&gt;&gt;&gt;&gt; +			npages = iova_limit/pgsize;</span>
<span class=quote>&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt; Isn't iova_limit potentially uninitialized here?  For example, if our</span>
<span class=quote>&gt;&gt;&gt; vfio_dma covers {0,8192} and we ask for the bitmap of {0,4096} and</span>
<span class=quote>&gt;&gt;&gt; there's a vpfn at {4096,8192}.  I think that means vpfn-&gt;iova &gt;= i</span>
<span class=quote>&gt;&gt;&gt; (4096 &gt;= 0), so we break with found = true, then we test 4096 &gt;= 0 +</span>
<span class=quote>&gt;&gt;&gt; 4096 and break, and npages = ????/pgsize.</span>
<span class=quote>&gt;&gt;&gt;    </span>
<span class=quote>&gt;&gt;</span>
<span class=quote>&gt;&gt; Right, Fixing it.</span>
<span class=quote>&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt;&gt; +		}</span>
<span class=quote>&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt;&gt; +		bsize = dirty_bitmap_bytes(npages);</span>
<span class=quote>&gt;&gt;&gt;&gt; +		shift = nbits % BITS_PER_BYTE;</span>
<span class=quote>&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt;&gt; +		if (npages &amp;&amp; shift) {</span>
<span class=quote>&gt;&gt;&gt;&gt; +			l--;</span>
<span class=quote>&gt;&gt;&gt;&gt; +			if (!access_ok((void __user *)bitmap + l,</span>
<span class=quote>&gt;&gt;&gt;&gt; +					sizeof(unsigned char)))</span>
<span class=quote>&gt;&gt;&gt;&gt; +				return -EINVAL;</span>
<span class=quote>&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt;&gt; +			ret = __get_user(temp, bitmap + l);</span>
<span class=quote>&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt; I don't understand why we care to get the user's bitmap, are we trying</span>
<span class=quote>&gt;&gt;&gt; to leave whatever garbage they might have set in it and only also set</span>
<span class=quote>&gt;&gt;&gt; the dirty bits?  That seems unnecessary.</span>
<span class=quote>&gt;&gt;&gt;    </span>
<span class=quote>&gt;&gt;</span>
<span class=quote>&gt;&gt; Suppose dma mapped ranges are {start, size}:</span>
<span class=quote>&gt;&gt; {0, 0xa000}, {0xa000, 0x10000}</span>
<span class=quote>&gt;&gt;</span>
<span class=quote>&gt;&gt; Bitmap asked from 0 - 0x10000. Say suppose all pages are dirty.</span>
<span class=quote>&gt;&gt; Then in first iteration for dma {0,0xa000} there are 10 pages, so 10</span>
<span class=quote>&gt;&gt; bits are set, put_user() happens for 2 bytes, (00000011 11111111b).</span>
<span class=quote>&gt;&gt; In second iteration for dma {0xa000, 0x10000} there are 6 pages and</span>
<span class=quote>&gt;&gt; these bits should be appended to previous byte. So get_user() that byte,</span>
<span class=quote>&gt;&gt; then shift-OR rest of the bitmap, result should be: (11111111 11111111b)</span>
<span class=quote>&gt;&gt;</span>
<span class=quote>&gt;&gt; Without get_user() and shift-OR, resulting bitmap would be</span>
<span class=quote>&gt;&gt; 111111 00000011 11111111b which would be wrong.</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; Seems like if we use a put_user() approach then we should look for</span>
<span class=quote>&gt; adjacent vfio_dmas within the same byte/word/dword before we push it to</span>
<span class=quote>&gt; the user to avoid this sort of inefficiency.</span>
<span class=quote>&gt; </span>

Won't that add more complication to logic?
<span class=quote>
&gt;&gt;&gt; Also why do we need these access_ok() checks when we already checked</span>
<span class=quote>&gt;&gt;&gt; the range at the start of the ioctl?</span>
<span class=quote>&gt;&gt;</span>
<span class=quote>&gt;&gt; Since pointer is updated runtime here, better to check that pointer</span>
<span class=quote>&gt;&gt; before using that pointer.</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; Sorry, I still don't understand this, we check access_ok() with a</span>
<span class=quote>&gt; pointer and a length, therefore as long as we're incrementing the</span>
<span class=quote>&gt; pointer within that length, why do we need to retest?</span>
<span class=quote>&gt; </span>

Ideally caller for put_user() and get_user() must check the pointer with 
access_ok() which is used as argument to these functions before calling 
this function. That makes sure that pointer is correct after pointer 
arithematic. May be lets remove previous check of pointer and length, 
but keep these checks.
<span class=quote>
&gt;&gt;&gt;    </span>
<span class=quote>&gt;&gt;&gt;&gt; +			if (ret)</span>
<span class=quote>&gt;&gt;&gt;&gt; +				return ret;</span>
<span class=quote>&gt;&gt;&gt;&gt; +		}</span>
<span class=quote>&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt;&gt; +		for (j = 0; j &lt; bsize; j++, l++) {</span>
<span class=quote>&gt;&gt;&gt;&gt; +			temp = temp |</span>
<span class=quote>&gt;&gt;&gt;&gt; +			       (*((unsigned char *)dma-&gt;bitmap + j) &lt;&lt; shift);</span>
<span class=quote>&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt; |=</span>
<span class=quote>&gt;&gt;&gt;    </span>
<span class=quote>&gt;&gt;&gt;&gt; +			if (!access_ok((void __user *)bitmap + l,</span>
<span class=quote>&gt;&gt;&gt;&gt; +					sizeof(unsigned char)))</span>
<span class=quote>&gt;&gt;&gt;&gt; +				return -EINVAL;</span>
<span class=quote>&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt;&gt; +			ret = __put_user(temp, bitmap + l);</span>
<span class=quote>&gt;&gt;&gt;&gt; +			if (ret)</span>
<span class=quote>&gt;&gt;&gt;&gt; +				return ret;</span>
<span class=quote>&gt;&gt;&gt;&gt; +			if (shift) {</span>
<span class=quote>&gt;&gt;&gt;&gt; +				temp = *((unsigned char *)dma-&gt;bitmap + j) &gt;&gt;</span>
<span class=quote>&gt;&gt;&gt;&gt; +					(BITS_PER_BYTE - shift);</span>
<span class=quote>&gt;&gt;&gt;&gt; +			}</span>
<span class=quote>&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt; When shift == 0, temp just seems to accumulate bits that never get</span>
<span class=quote>&gt;&gt;&gt; cleared.</span>
<span class=quote>&gt;&gt;&gt;    </span>
<span class=quote>&gt;&gt;</span>
<span class=quote>&gt;&gt; Hope example above explains the shift logic.</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; But that example is when shift is non-zero.  When shift is zero, each</span>
<span class=quote>&gt; iteration of the loop just ORs in new bits to temp without ever</span>
<span class=quote>&gt; clearing the bits for the previous iteration.</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; </span>

Oh right, fixing it.
<span class=quote>
&gt;&gt;&gt;&gt; +		}</span>
<span class=quote>&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt;&gt; +		nbits += npages;</span>
<span class=quote>&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt;&gt; +		i = min(dma-&gt;iova + dma-&gt;size, iova + size);</span>
<span class=quote>&gt;&gt;&gt;&gt; +		if (i &gt;= iova + size)</span>
<span class=quote>&gt;&gt;&gt;&gt; +			break;</span>
<span class=quote>&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt; So whether we error or succeed, we leave cruft in dma-&gt;bitmap for the</span>
<span class=quote>&gt;&gt;&gt; next pass.  It doesn't seem to make any sense why we pre-allocated the</span>
<span class=quote>&gt;&gt;&gt; bitmap, we might as well just allocate it on demand here.  Actually, if</span>
<span class=quote>&gt;&gt;&gt; we're not going to do a copy_to_user() for some range of the bitmap,</span>
<span class=quote>&gt;&gt;&gt; I'm not sure what it's purpose is at all.  I think the big advantages</span>
<span class=quote>&gt;&gt;&gt; of the bitmap are that we can't amortize the cost across every pinned</span>
<span class=quote>&gt;&gt;&gt; page or DMA mapping, we don't need the overhead of tracking unmapped</span>
<span class=quote>&gt;&gt;&gt; vpfns, and we can use copy_to_user() to push the bitmap out.  We're not</span>
<span class=quote>&gt;&gt;&gt; getting any of those advantages here.</span>
<span class=quote>&gt;&gt;&gt;    </span>
<span class=quote>&gt;&gt;</span>
<span class=quote>&gt;&gt; That would still not work if dma range size is not multiples of 8 pages.</span>
<span class=quote>&gt;&gt; See example above.</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; I don't understand this comment, what about the example above justifies</span>
<span class=quote>&gt; the bitmap?</span>

copy_to_user() could be used if dma range size is not multiple of 8 pages.
<span class=quote>
&gt;  As I understand the above algorithm, we find a vfio_dma</span>
<span class=quote>&gt; overlapping the request and populate the bitmap for that range.  Then</span>
<span class=quote>&gt; we go back and put_user() for each byte that we touched.  We could</span>
<span class=quote>&gt; instead simply work on a one byte buffer as we enumerate the requested</span>
<span class=quote>&gt; range and do a put_user() ever time we reach the end of it and have bits</span>
<span class=quote>&gt; set. That would greatly simplify the above example.  But I would expect &gt; that we're a) more likely to get asked for ranges covering a single</span>
<span class=quote>&gt; vfio_dma </span>

QEMU ask for single vfio_dma during each iteration.

If we restrict this ABI to cover single vfio_dma only, then it 
simplifies the logic here. That was my original suggestion. Should we 
think about that again?
<span class=quote>
&gt; and b) we're going to spend far more time operating in the</span>
<span class=quote>&gt; middle of the range and limiting ourselves to one-byte operations there</span>
<span class=quote>&gt; seems absurd.  If we want to specify that the user provides 4-byte</span>
<span class=quote>&gt; aligned buffers and naturally aligned iova ranges to make our lives</span>
<span class=quote>&gt; easier in the kernel, now would be the time to do that.</span>
<span class=quote>&gt; </span>
<span class=quote>&gt;&gt;&gt;&gt; +	}</span>
<span class=quote>&gt;&gt;&gt;&gt; +	return 0;</span>
<span class=quote>&gt;&gt;&gt;&gt; +}</span>
<span class=quote>&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt;&gt; +static long verify_bitmap_size(unsigned long npages, unsigned long bitmap_size)</span>
<span class=quote>&gt;&gt;&gt;&gt; +{</span>
<span class=quote>&gt;&gt;&gt;&gt; +	long bsize;</span>
<span class=quote>&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt;&gt; +	if (!bitmap_size || bitmap_size &gt; SIZE_MAX)</span>
<span class=quote>&gt;&gt;&gt;&gt; +		return -EINVAL;</span>
<span class=quote>&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt;&gt; +	bsize = dirty_bitmap_bytes(npages);</span>
<span class=quote>&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt;&gt; +	if (bitmap_size &lt; bsize)</span>
<span class=quote>&gt;&gt;&gt;&gt; +		return -EINVAL;</span>
<span class=quote>&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt;&gt; +	return bsize;</span>
<span class=quote>&gt;&gt;&gt;&gt; +}</span>
<span class=quote>&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt; Seems like this could simply return int, -errno or zero for success.</span>
<span class=quote>&gt;&gt;&gt; The returned bsize is not used for anything else.</span>
<span class=quote>&gt;&gt;&gt;    </span>
<span class=quote>&gt;&gt;</span>
<span class=quote>&gt;&gt; ok.</span>
<span class=quote>&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt;&gt;    static int vfio_dma_do_unmap(struct vfio_iommu *iommu,</span>
<span class=quote>&gt;&gt;&gt;&gt;    			     struct vfio_iommu_type1_dma_unmap *unmap)</span>
<span class=quote>&gt;&gt;&gt;&gt;    {</span>
<span class=quote>&gt;&gt;&gt;&gt; @@ -2277,6 +2478,80 @@ static long vfio_iommu_type1_ioctl(void *iommu_data,</span>
<span class=quote>&gt;&gt;&gt;&gt;    </span>
<span class=quote>&gt;&gt;&gt;&gt;    		return copy_to_user((void __user *)arg, &amp;unmap, minsz) ?</span>
<span class=quote>&gt;&gt;&gt;&gt;    			-EFAULT : 0;</span>
<span class=quote>&gt;&gt;&gt;&gt; +	} else if (cmd == VFIO_IOMMU_DIRTY_PAGES) {</span>
<span class=quote>&gt;&gt;&gt;&gt; +		struct vfio_iommu_type1_dirty_bitmap range;</span>
<span class=quote>&gt;&gt;&gt;&gt; +		uint32_t mask = VFIO_IOMMU_DIRTY_PAGES_FLAG_START |</span>
<span class=quote>&gt;&gt;&gt;&gt; +				VFIO_IOMMU_DIRTY_PAGES_FLAG_STOP |</span>
<span class=quote>&gt;&gt;&gt;&gt; +				VFIO_IOMMU_DIRTY_PAGES_FLAG_GET_BITMAP;</span>
<span class=quote>&gt;&gt;&gt;&gt; +		int ret;</span>
<span class=quote>&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt;&gt; +		if (!iommu-&gt;v2)</span>
<span class=quote>&gt;&gt;&gt;&gt; +			return -EACCES;</span>
<span class=quote>&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt;&gt; +		minsz = offsetofend(struct vfio_iommu_type1_dirty_bitmap,</span>
<span class=quote>&gt;&gt;&gt;&gt; +				    bitmap);</span>
<span class=quote>&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt; We require the user to provide iova, size, pgsize, bitmap_size, and</span>
<span class=quote>&gt;&gt;&gt; bitmap fields to START/STOP?  Why?</span>
<span class=quote>&gt;&gt;&gt;   </span>
<span class=quote>&gt;&gt;</span>
<span class=quote>&gt;&gt; No. But those are part of structure.</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; But we do require it, minsz here includes all those fields, which would</span>
<span class=quote>&gt; probably make a user scratch their head wondering why they need to pass</span>
<span class=quote>&gt; irrelevant data for START/STOP.  It almost implies that we support</span>
<span class=quote>&gt; starting and stopping dirty logging for specific ranges of the IOVA</span>
<span class=quote>&gt; space.  We could define the structure, for example:</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; struct vfio_iommu_type1_dirty_bitmap {</span>
<span class=quote>&gt; 	__u32	argsz;</span>
<span class=quote>&gt; 	__u32	flags;</span>
<span class=quote>&gt; 	__u8	data[];</span>
<span class=quote>&gt; };</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; struct vfio_iommu_type1_dirty_bitmap_get {</span>
<span class=quote>&gt; 	__u64	iova;</span>
<span class=quote>&gt; 	__u64	size;</span>
<span class=quote>&gt; 	__u64	pgsize;</span>
<span class=quote>&gt; 	__u64	bitmap_size;</span>
<span class=quote>&gt; 	void __user *bitmap;</span>
<span class=quote>&gt; };</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; Where data[] is defined as the latter structure when FLAG_GET_BITMAP is</span>
<span class=quote>&gt; specified.</span>

Ok. Changing as above.
<span class=quote>
&gt;  BTW, don't we need to specify the trailing void* as __u64?</span>
<span class=quote>&gt; We could theoretically be talking to an ILP32 user process.  Thanks,</span>
<span class=quote>&gt; </span>

Even on ILP32, using void* pointer will reserve the size required to 
save a pointer address. I don't think using void* should be problem.

Thanks,
Kirti
<span class=quote>

&gt; Alex</span>
<span class=quote>&gt; </span>
<span class=quote>&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt;&gt; +		if (copy_from_user(&amp;range, (void __user *)arg, minsz))</span>
<span class=quote>&gt;&gt;&gt;&gt; +			return -EFAULT;</span>
<span class=quote>&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt;&gt; +		if (range.argsz &lt; minsz || range.flags &amp; ~mask)</span>
<span class=quote>&gt;&gt;&gt;&gt; +			return -EINVAL;</span>
<span class=quote>&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt;&gt; +		/* only one flag should be set at a time */</span>
<span class=quote>&gt;&gt;&gt;&gt; +		if (__ffs(range.flags) != __fls(range.flags))</span>
<span class=quote>&gt;&gt;&gt;&gt; +			return -EINVAL;</span>
<span class=quote>&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt;&gt; +		if (range.flags &amp; VFIO_IOMMU_DIRTY_PAGES_FLAG_START) {</span>
<span class=quote>&gt;&gt;&gt;&gt; +			unsigned long iommu_pgsizes = vfio_pgsize_bitmap(iommu);</span>
<span class=quote>&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt;&gt; +			mutex_lock(&amp;iommu-&gt;lock);</span>
<span class=quote>&gt;&gt;&gt;&gt; +			iommu-&gt;dirty_page_tracking = true;</span>
<span class=quote>&gt;&gt;&gt;&gt; +			ret = vfio_dma_all_bitmap_alloc(iommu, iommu_pgsizes);</span>
<span class=quote>&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt; So dirty page tracking is enabled even if we fail to allocate all the</span>
<span class=quote>&gt;&gt;&gt; bitmaps?  Shouldn't this return an error if dirty tracking is already</span>
<span class=quote>&gt;&gt;&gt; enabled?</span>
<span class=quote>&gt;&gt;&gt;    </span>
<span class=quote>&gt;&gt;</span>
<span class=quote>&gt;&gt; Adding error handling here in next patch.</span>
<span class=quote>&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt;&gt; +			mutex_unlock(&amp;iommu-&gt;lock);</span>
<span class=quote>&gt;&gt;&gt;&gt; +			return ret;</span>
<span class=quote>&gt;&gt;&gt;&gt; +		} else if (range.flags &amp; VFIO_IOMMU_DIRTY_PAGES_FLAG_STOP) {</span>
<span class=quote>&gt;&gt;&gt;&gt; +			mutex_lock(&amp;iommu-&gt;lock);</span>
<span class=quote>&gt;&gt;&gt;&gt; +			iommu-&gt;dirty_page_tracking = false;</span>
<span class=quote>&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt; Shouldn't we only allow STOP if tracking is enabled?</span>
<span class=quote>&gt;&gt;&gt;    </span>
<span class=quote>&gt;&gt;</span>
<span class=quote>&gt;&gt; Right,adding.</span>
<span class=quote>&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt;&gt; +			vfio_dma_all_bitmap_free(iommu);</span>
<span class=quote>&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt; Here's where that user induced double free enters the picture.</span>
<span class=quote>&gt;&gt;&gt;    </span>
<span class=quote>&gt;&gt;</span>
<span class=quote>&gt;&gt; Error handling as mentioned above will prevent double free.</span>
<span class=quote>&gt;&gt;</span>
<span class=quote>&gt;&gt; Thanks,</span>
<span class=quote>&gt;&gt; Kirti</span>
<span class=quote>&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt;&gt; +			vfio_remove_unpinned_from_dma_list(iommu);</span>
<span class=quote>&gt;&gt;&gt;&gt; +			mutex_unlock(&amp;iommu-&gt;lock);</span>
<span class=quote>&gt;&gt;&gt;&gt; +			return 0;</span>
<span class=quote>&gt;&gt;&gt;&gt; +		} else if (range.flags &amp;</span>
<span class=quote>&gt;&gt;&gt;&gt; +				 VFIO_IOMMU_DIRTY_PAGES_FLAG_GET_BITMAP) {</span>
<span class=quote>&gt;&gt;&gt;&gt; +			long bsize;</span>
<span class=quote>&gt;&gt;&gt;&gt; +			unsigned long pgshift = __ffs(range.pgsize);</span>
<span class=quote>&gt;&gt;&gt;&gt; +			uint64_t iommu_pgsizes = vfio_pgsize_bitmap(iommu);</span>
<span class=quote>&gt;&gt;&gt;&gt; +			uint64_t iommu_pgmask =</span>
<span class=quote>&gt;&gt;&gt;&gt; +				 ((uint64_t)1 &lt;&lt; __ffs(iommu_pgsizes)) - 1;</span>
<span class=quote>&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt;&gt; +			if ((range.pgsize &amp; iommu_pgsizes) != range.pgsize)</span>
<span class=quote>&gt;&gt;&gt;&gt; +				return -EINVAL;</span>
<span class=quote>&gt;&gt;&gt;&gt; +			if (range.iova &amp; iommu_pgmask)</span>
<span class=quote>&gt;&gt;&gt;&gt; +				return -EINVAL;</span>
<span class=quote>&gt;&gt;&gt;&gt; +			if (!range.size || range.size &amp; iommu_pgmask)</span>
<span class=quote>&gt;&gt;&gt;&gt; +				return -EINVAL;</span>
<span class=quote>&gt;&gt;&gt;&gt; +			if (range.iova + range.size &lt; range.iova)</span>
<span class=quote>&gt;&gt;&gt;&gt; +				return -EINVAL;</span>
<span class=quote>&gt;&gt;&gt;&gt; +			if (!access_ok((void __user *)range.bitmap,</span>
<span class=quote>&gt;&gt;&gt;&gt; +				       range.bitmap_size))</span>
<span class=quote>&gt;&gt;&gt;&gt; +				return -EINVAL;</span>
<span class=quote>&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt;&gt; +			bsize = verify_bitmap_size(range.size &gt;&gt; pgshift,</span>
<span class=quote>&gt;&gt;&gt;&gt; +						   range.bitmap_size);</span>
<span class=quote>&gt;&gt;&gt;&gt; +			if (bsize &lt; 0)</span>
<span class=quote>&gt;&gt;&gt;&gt; +				return bsize;</span>
<span class=quote>&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt;&gt; +			mutex_lock(&amp;iommu-&gt;lock);</span>
<span class=quote>&gt;&gt;&gt;&gt; +			if (iommu-&gt;dirty_page_tracking)</span>
<span class=quote>&gt;&gt;&gt;&gt; +				ret = vfio_iova_dirty_bitmap(iommu, range.iova,</span>
<span class=quote>&gt;&gt;&gt;&gt; +					 range.size, range.pgsize,</span>
<span class=quote>&gt;&gt;&gt;&gt; +					 (unsigned char __user *)range.bitmap);</span>
<span class=quote>&gt;&gt;&gt;&gt; +			else</span>
<span class=quote>&gt;&gt;&gt;&gt; +				ret = -EINVAL;</span>
<span class=quote>&gt;&gt;&gt;&gt; +			mutex_unlock(&amp;iommu-&gt;lock);</span>
<span class=quote>&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt;&gt; +			return ret;</span>
<span class=quote>&gt;&gt;&gt;&gt; +		}</span>
<span class=quote>&gt;&gt;&gt;&gt;    	}</span>
<span class=quote>&gt;&gt;&gt;&gt;    </span>
<span class=quote>&gt;&gt;&gt;&gt;    	return -ENOTTY;</span>
<span class=quote>&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt; Thanks,</span>
<span class=quote>&gt;&gt;&gt; Alex</span>
<span class=quote>&gt;&gt;&gt;    </span>
<span class=quote>&gt;&gt;</span>
<span class=quote>&gt;</span>
</pre>
</div>
<a name=23156307></a>
<div class=comment>
<div class=meta>
 <span><a href="https://patchwork.kernel.org/project/qemu-devel/list/?submitter=7781">Alex Williamson</a></span>
 <span class=pull-right>Feb. 13, 2020, 11:20 p.m. UTC | <a href=https://patchwork.kernel.org/comment/23156307/>#10</a></span>
</div>
<pre class=content>On Fri, 14 Feb 2020 01:41:35 +0530
Kirti Wankhede &lt;kwankhede@nvidia.com&gt; wrote:
<span class=quote>
&gt; &lt;snip&gt;</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;    </span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +static int vfio_iova_dirty_bitmap(struct vfio_iommu *iommu, dma_addr_t iova,</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +				  size_t size, uint64_t pgsize,</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +				  unsigned char __user *bitmap)</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +{</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +	struct vfio_dma *dma;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +	dma_addr_t i = iova, iova_limit;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +	unsigned int bsize, nbits = 0, l = 0;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +	unsigned long pgshift = __ffs(pgsize);</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +	while ((dma = vfio_find_dma(iommu, i, pgsize))) {</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +		int ret, j;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +		unsigned int npages = 0, shift = 0;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +		unsigned char temp = 0;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +		/* mark all pages dirty if all pages are pinned and mapped. */</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +		if (dma-&gt;iommu_mapped) {</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +			iova_limit = min(dma-&gt;iova + dma-&gt;size, iova + size);</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +			npages = iova_limit/pgsize;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +			bitmap_set(dma-&gt;bitmap, 0, npages);  </span>
<span class=quote>&gt; &gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt; npages is derived from iova_limit, which is the number of bits to set</span>
<span class=quote>&gt; &gt;&gt;&gt; dirty relative to the first requested iova, not iova zero, ie. the set</span>
<span class=quote>&gt; &gt;&gt;&gt; of dirty bits is offset from those requested unless iova == dma-&gt;iova.</span>
<span class=quote>&gt; &gt;&gt;&gt;      </span>
<span class=quote>&gt; &gt;&gt;</span>
<span class=quote>&gt; &gt;&gt; Right, fixing.</span>
<span class=quote>&gt; &gt;&gt;  </span>
<span class=quote>&gt; &gt;&gt;&gt; Also I hope dma-&gt;bitmap was actually allocated.  Not only does the</span>
<span class=quote>&gt; &gt;&gt;&gt; START error path potentially leave dirty tracking enabled without all</span>
<span class=quote>&gt; &gt;&gt;&gt; the bitmap allocated, when does the bitmap get allocated for a new</span>
<span class=quote>&gt; &gt;&gt;&gt; vfio_dma when dirty tracking is enabled?  Seems it only occurs if a</span>
<span class=quote>&gt; &gt;&gt;&gt; vpfn gets marked dirty.</span>
<span class=quote>&gt; &gt;&gt;&gt;      </span>
<span class=quote>&gt; &gt;&gt;</span>
<span class=quote>&gt; &gt;&gt; Right.</span>
<span class=quote>&gt; &gt;&gt;</span>
<span class=quote>&gt; &gt;&gt; Fixing error paths.</span>
<span class=quote>&gt; &gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;  </span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +		} else if (dma-&gt;bitmap) {</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +			struct rb_node *n = rb_first(&amp;dma-&gt;pfn_list);</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +			bool found = false;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +			for (; n; n = rb_next(n)) {</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +				struct vfio_pfn *vpfn = rb_entry(n,</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +						struct vfio_pfn, node);</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +				if (vpfn-&gt;iova &gt;= i) {</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +					found = true;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +					break;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +				}</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +			}</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +			if (!found) {</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +				i += dma-&gt;size;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +				continue;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +			}</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +			for (; n; n = rb_next(n)) {</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +				unsigned int s;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +				struct vfio_pfn *vpfn = rb_entry(n,</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +						struct vfio_pfn, node);</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +				if (vpfn-&gt;iova &gt;= iova + size)</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +					break;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +				s = (vpfn-&gt;iova - dma-&gt;iova) &gt;&gt; pgshift;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +				bitmap_set(dma-&gt;bitmap, s, 1);</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +				iova_limit = vpfn-&gt;iova + pgsize;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +			}</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +			npages = iova_limit/pgsize;  </span>
<span class=quote>&gt; &gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt; Isn't iova_limit potentially uninitialized here?  For example, if our</span>
<span class=quote>&gt; &gt;&gt;&gt; vfio_dma covers {0,8192} and we ask for the bitmap of {0,4096} and</span>
<span class=quote>&gt; &gt;&gt;&gt; there's a vpfn at {4096,8192}.  I think that means vpfn-&gt;iova &gt;= i</span>
<span class=quote>&gt; &gt;&gt;&gt; (4096 &gt;= 0), so we break with found = true, then we test 4096 &gt;= 0 +</span>
<span class=quote>&gt; &gt;&gt;&gt; 4096 and break, and npages = ????/pgsize.</span>
<span class=quote>&gt; &gt;&gt;&gt;      </span>
<span class=quote>&gt; &gt;&gt;</span>
<span class=quote>&gt; &gt;&gt; Right, Fixing it.</span>
<span class=quote>&gt; &gt;&gt;  </span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +		}</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +		bsize = dirty_bitmap_bytes(npages);</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +		shift = nbits % BITS_PER_BYTE;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +		if (npages &amp;&amp; shift) {</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +			l--;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +			if (!access_ok((void __user *)bitmap + l,</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +					sizeof(unsigned char)))</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +				return -EINVAL;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +			ret = __get_user(temp, bitmap + l);  </span>
<span class=quote>&gt; &gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt; I don't understand why we care to get the user's bitmap, are we trying</span>
<span class=quote>&gt; &gt;&gt;&gt; to leave whatever garbage they might have set in it and only also set</span>
<span class=quote>&gt; &gt;&gt;&gt; the dirty bits?  That seems unnecessary.</span>
<span class=quote>&gt; &gt;&gt;&gt;      </span>
<span class=quote>&gt; &gt;&gt;</span>
<span class=quote>&gt; &gt;&gt; Suppose dma mapped ranges are {start, size}:</span>
<span class=quote>&gt; &gt;&gt; {0, 0xa000}, {0xa000, 0x10000}</span>
<span class=quote>&gt; &gt;&gt;</span>
<span class=quote>&gt; &gt;&gt; Bitmap asked from 0 - 0x10000. Say suppose all pages are dirty.</span>
<span class=quote>&gt; &gt;&gt; Then in first iteration for dma {0,0xa000} there are 10 pages, so 10</span>
<span class=quote>&gt; &gt;&gt; bits are set, put_user() happens for 2 bytes, (00000011 11111111b).</span>
<span class=quote>&gt; &gt;&gt; In second iteration for dma {0xa000, 0x10000} there are 6 pages and</span>
<span class=quote>&gt; &gt;&gt; these bits should be appended to previous byte. So get_user() that byte,</span>
<span class=quote>&gt; &gt;&gt; then shift-OR rest of the bitmap, result should be: (11111111 11111111b)</span>
<span class=quote>&gt; &gt;&gt;</span>
<span class=quote>&gt; &gt;&gt; Without get_user() and shift-OR, resulting bitmap would be</span>
<span class=quote>&gt; &gt;&gt; 111111 00000011 11111111b which would be wrong.  </span>
<span class=quote>&gt; &gt; </span>
<span class=quote>&gt; &gt; Seems like if we use a put_user() approach then we should look for</span>
<span class=quote>&gt; &gt; adjacent vfio_dmas within the same byte/word/dword before we push it to</span>
<span class=quote>&gt; &gt; the user to avoid this sort of inefficiency.</span>
<span class=quote>&gt; &gt;   </span>
<span class=quote>&gt; </span>
<span class=quote>&gt; Won't that add more complication to logic?</span>

I'm tempted to think it might be less complicated.
<span class=quote> 
&gt; &gt;&gt;&gt; Also why do we need these access_ok() checks when we already checked</span>
<span class=quote>&gt; &gt;&gt;&gt; the range at the start of the ioctl?  </span>
<span class=quote>&gt; &gt;&gt;</span>
<span class=quote>&gt; &gt;&gt; Since pointer is updated runtime here, better to check that pointer</span>
<span class=quote>&gt; &gt;&gt; before using that pointer.  </span>
<span class=quote>&gt; &gt; </span>
<span class=quote>&gt; &gt; Sorry, I still don't understand this, we check access_ok() with a</span>
<span class=quote>&gt; &gt; pointer and a length, therefore as long as we're incrementing the</span>
<span class=quote>&gt; &gt; pointer within that length, why do we need to retest?</span>
<span class=quote>&gt; &gt;   </span>
<span class=quote>&gt; </span>
<span class=quote>&gt; Ideally caller for put_user() and get_user() must check the pointer with </span>
<span class=quote>&gt; access_ok() which is used as argument to these functions before calling </span>
<span class=quote>&gt; this function. That makes sure that pointer is correct after pointer </span>
<span class=quote>&gt; arithematic. May be lets remove previous check of pointer and length, </span>
<span class=quote>&gt; but keep these checks.</span>

So we don't trust that we can increment a pointer within a range that
we've already tested with access_ok() and expect it to still be ok?  I
think the point of having access_ok() and __put_user() is that we can
batch many __put_user() calls under a single access_ok() check.  I
don't see any justification here why if we already tested
access_ok(ptr, 2) that we still need to test access_ok(ptr + 0, 1) and
access_ok(ptr + 1, 1), and removing the initial test is clearly the
wrong optimization if we agree there is redundancy here.	
<span class=quote>
&gt; &gt;&gt;&gt;&gt; +			if (ret)</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +				return ret;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +		}</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +		for (j = 0; j &lt; bsize; j++, l++) {</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +			temp = temp |</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +			       (*((unsigned char *)dma-&gt;bitmap + j) &lt;&lt; shift);  </span>
<span class=quote>&gt; &gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt; |=</span>
<span class=quote>&gt; &gt;&gt;&gt;      </span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +			if (!access_ok((void __user *)bitmap + l,</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +					sizeof(unsigned char)))</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +				return -EINVAL;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +			ret = __put_user(temp, bitmap + l);</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +			if (ret)</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +				return ret;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +			if (shift) {</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +				temp = *((unsigned char *)dma-&gt;bitmap + j) &gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +					(BITS_PER_BYTE - shift);</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +			}  </span>
<span class=quote>&gt; &gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt; When shift == 0, temp just seems to accumulate bits that never get</span>
<span class=quote>&gt; &gt;&gt;&gt; cleared.</span>
<span class=quote>&gt; &gt;&gt;&gt;      </span>
<span class=quote>&gt; &gt;&gt;</span>
<span class=quote>&gt; &gt;&gt; Hope example above explains the shift logic.  </span>
<span class=quote>&gt; &gt; </span>
<span class=quote>&gt; &gt; But that example is when shift is non-zero.  When shift is zero, each</span>
<span class=quote>&gt; &gt; iteration of the loop just ORs in new bits to temp without ever</span>
<span class=quote>&gt; &gt; clearing the bits for the previous iteration.</span>
<span class=quote>&gt; &gt; </span>
<span class=quote>&gt; &gt;   </span>
<span class=quote>&gt; </span>
<span class=quote>&gt; Oh right, fixing it.</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +		}</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +		nbits += npages;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +		i = min(dma-&gt;iova + dma-&gt;size, iova + size);</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +		if (i &gt;= iova + size)</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +			break;  </span>
<span class=quote>&gt; &gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt; So whether we error or succeed, we leave cruft in dma-&gt;bitmap for the</span>
<span class=quote>&gt; &gt;&gt;&gt; next pass.  It doesn't seem to make any sense why we pre-allocated the</span>
<span class=quote>&gt; &gt;&gt;&gt; bitmap, we might as well just allocate it on demand here.  Actually, if</span>
<span class=quote>&gt; &gt;&gt;&gt; we're not going to do a copy_to_user() for some range of the bitmap,</span>
<span class=quote>&gt; &gt;&gt;&gt; I'm not sure what it's purpose is at all.  I think the big advantages</span>
<span class=quote>&gt; &gt;&gt;&gt; of the bitmap are that we can't amortize the cost across every pinned</span>
<span class=quote>&gt; &gt;&gt;&gt; page or DMA mapping, we don't need the overhead of tracking unmapped</span>
<span class=quote>&gt; &gt;&gt;&gt; vpfns, and we can use copy_to_user() to push the bitmap out.  We're not</span>
<span class=quote>&gt; &gt;&gt;&gt; getting any of those advantages here.</span>
<span class=quote>&gt; &gt;&gt;&gt;      </span>
<span class=quote>&gt; &gt;&gt;</span>
<span class=quote>&gt; &gt;&gt; That would still not work if dma range size is not multiples of 8 pages.</span>
<span class=quote>&gt; &gt;&gt; See example above.  </span>
<span class=quote>&gt; &gt; </span>
<span class=quote>&gt; &gt; I don't understand this comment, what about the example above justifies</span>
<span class=quote>&gt; &gt; the bitmap?  </span>
<span class=quote>&gt; </span>
<span class=quote>&gt; copy_to_user() could be used if dma range size is not multiple of 8 pages.</span>

s/is not/is/ ?

And we expect that to be a far more common case, right?  I don't think
there are too many ranges for a guest that are only mapped in sub-32KB
chucks.
<span class=quote> 
&gt; &gt;  As I understand the above algorithm, we find a vfio_dma</span>
<span class=quote>&gt; &gt; overlapping the request and populate the bitmap for that range.  Then</span>
<span class=quote>&gt; &gt; we go back and put_user() for each byte that we touched.  We could</span>
<span class=quote>&gt; &gt; instead simply work on a one byte buffer as we enumerate the requested</span>
<span class=quote>&gt; &gt; range and do a put_user() ever time we reach the end of it and have bits</span>
<span class=quote>&gt; &gt; set. That would greatly simplify the above example.  But I would expect</span>
<span class=quote>&gt; &gt; that we're a) more likely to get asked for ranges covering a single</span>
<span class=quote>&gt; &gt; vfio_dma   </span>
<span class=quote>&gt; </span>
<span class=quote>&gt; QEMU ask for single vfio_dma during each iteration.</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; If we restrict this ABI to cover single vfio_dma only, then it </span>
<span class=quote>&gt; simplifies the logic here. That was my original suggestion. Should we </span>
<span class=quote>&gt; think about that again?</span>

But we currently allow unmaps that overlap multiple vfio_dmas as long
as no vfio_dma is bisected, so I think that implies that an unmap while
asking for the dirty bitmap has even further restricted semantics.  I'm
also reluctant to design an ABI around what happens to be the current
QEMU implementation.

If we take your example above, ranges {0x0000,0xa000} and
{0xa000,0x10000} ({start,end}), I think you're working with the
following two bitmaps in this implementation:

00000011 11111111b
00111111b

And we need to combine those into:

11111111 11111111b

Right?

But it seems like that would be easier if the second bitmap was instead:

11111100b

Then we wouldn't need to worry about the entire bitmap being shifted by
the bit offset within the byte, which limits our fixes to the boundary
byte and allows us to use copy_to_user() directly for the bulk of the
copy.  So how do we get there?

I think we start with allocating the vfio_dma bitmap to account for
this initial offset, so we calculate bitmap_base_iova as:
  (iova &amp; ~((PAGE_SIZE &lt;&lt; 3) - 1))
We then use bitmap_base_iova in calculating which bits to set.

The user needs to follow the same rules, and maybe this adds some value
to the user providing the bitmap size rather than the kernel
calculating it.  For example, if the user wanted the dirty bitmap for
the range {0xa000,0x10000} above, they'd provide at least a 1 byte
bitmap, but we'd return bit #2 set to indicate 0xa000 is dirty.

Effectively the user can ask for any iova range, but the buffer will be
filled relative to the zeroth bit of the bitmap following the above
bitmap_base_iova formula (and replacing PAGE_SIZE with the user
requested pgsize).  I'm tempted to make this explicit in the user
interface (ie. only allow bitmaps starting on aligned pages), but a
user is able to map and unmap single pages and we need to support
returning a dirty bitmap with an unmap, so I don't think we can do that.

So now are we biting off more than we can chew trying to transpose the
bitmap between page sizes?  If asked for the previous range with an 8K
pgsize, we'd somehow need to translate 11111100b into 00001110b.
What's worse, the user could ask for just the 8K page at 0xa000 and we'd
need to return back 00000010b while leaving our internal bitmap a
11110000b after we mark the bits clean.  Seems like this is really
only tenable if we do multiples of PAGE_SIZE pages within a byte, so
for 4K we'd have 32K, 64K, 128K, 256K, etc.  I'm somewhat losing sight
on what this accomplishes though and whether we need this in the first
implementation.  Should we simplify by dropping this aspect of it,
supporting only the minimum iommu page size, and focus on actually
using the bitmaps effectively?
<span class=quote> 
&gt; &gt; and b) we're going to spend far more time operating in the</span>
<span class=quote>&gt; &gt; middle of the range and limiting ourselves to one-byte operations there</span>
<span class=quote>&gt; &gt; seems absurd.  If we want to specify that the user provides 4-byte</span>
<span class=quote>&gt; &gt; aligned buffers and naturally aligned iova ranges to make our lives</span>
<span class=quote>&gt; &gt; easier in the kernel, now would be the time to do that.</span>
<span class=quote>&gt; &gt;   </span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +	}</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +	return 0;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +}</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +static long verify_bitmap_size(unsigned long npages, unsigned long bitmap_size)</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +{</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +	long bsize;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +	if (!bitmap_size || bitmap_size &gt; SIZE_MAX)</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +		return -EINVAL;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +	bsize = dirty_bitmap_bytes(npages);</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +	if (bitmap_size &lt; bsize)</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +		return -EINVAL;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +	return bsize;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +}  </span>
<span class=quote>&gt; &gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt; Seems like this could simply return int, -errno or zero for success.</span>
<span class=quote>&gt; &gt;&gt;&gt; The returned bsize is not used for anything else.</span>
<span class=quote>&gt; &gt;&gt;&gt;      </span>
<span class=quote>&gt; &gt;&gt;</span>
<span class=quote>&gt; &gt;&gt; ok.</span>
<span class=quote>&gt; &gt;&gt;  </span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;    static int vfio_dma_do_unmap(struct vfio_iommu *iommu,</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;    			     struct vfio_iommu_type1_dma_unmap *unmap)</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;    {</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; @@ -2277,6 +2478,80 @@ static long vfio_iommu_type1_ioctl(void *iommu_data,</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;    </span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;    		return copy_to_user((void __user *)arg, &amp;unmap, minsz) ?</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;    			-EFAULT : 0;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +	} else if (cmd == VFIO_IOMMU_DIRTY_PAGES) {</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +		struct vfio_iommu_type1_dirty_bitmap range;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +		uint32_t mask = VFIO_IOMMU_DIRTY_PAGES_FLAG_START |</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +				VFIO_IOMMU_DIRTY_PAGES_FLAG_STOP |</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +				VFIO_IOMMU_DIRTY_PAGES_FLAG_GET_BITMAP;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +		int ret;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +		if (!iommu-&gt;v2)</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +			return -EACCES;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +		minsz = offsetofend(struct vfio_iommu_type1_dirty_bitmap,</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; +				    bitmap);  </span>
<span class=quote>&gt; &gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt; We require the user to provide iova, size, pgsize, bitmap_size, and</span>
<span class=quote>&gt; &gt;&gt;&gt; bitmap fields to START/STOP?  Why?</span>
<span class=quote>&gt; &gt;&gt;&gt;     </span>
<span class=quote>&gt; &gt;&gt;</span>
<span class=quote>&gt; &gt;&gt; No. But those are part of structure.  </span>
<span class=quote>&gt; &gt; </span>
<span class=quote>&gt; &gt; But we do require it, minsz here includes all those fields, which would</span>
<span class=quote>&gt; &gt; probably make a user scratch their head wondering why they need to pass</span>
<span class=quote>&gt; &gt; irrelevant data for START/STOP.  It almost implies that we support</span>
<span class=quote>&gt; &gt; starting and stopping dirty logging for specific ranges of the IOVA</span>
<span class=quote>&gt; &gt; space.  We could define the structure, for example:</span>
<span class=quote>&gt; &gt; </span>
<span class=quote>&gt; &gt; struct vfio_iommu_type1_dirty_bitmap {</span>
<span class=quote>&gt; &gt; 	__u32	argsz;</span>
<span class=quote>&gt; &gt; 	__u32	flags;</span>
<span class=quote>&gt; &gt; 	__u8	data[];</span>
<span class=quote>&gt; &gt; };</span>
<span class=quote>&gt; &gt; </span>
<span class=quote>&gt; &gt; struct vfio_iommu_type1_dirty_bitmap_get {</span>
<span class=quote>&gt; &gt; 	__u64	iova;</span>
<span class=quote>&gt; &gt; 	__u64	size;</span>
<span class=quote>&gt; &gt; 	__u64	pgsize;</span>
<span class=quote>&gt; &gt; 	__u64	bitmap_size;</span>
<span class=quote>&gt; &gt; 	void __user *bitmap;</span>
<span class=quote>&gt; &gt; };</span>
<span class=quote>&gt; &gt; </span>
<span class=quote>&gt; &gt; Where data[] is defined as the latter structure when FLAG_GET_BITMAP is</span>
<span class=quote>&gt; &gt; specified.  </span>
<span class=quote>&gt; </span>
<span class=quote>&gt; Ok. Changing as above.</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; &gt;  BTW, don't we need to specify the trailing void* as __u64?</span>
<span class=quote>&gt; &gt; We could theoretically be talking to an ILP32 user process.  Thanks,</span>
<span class=quote>&gt; &gt;   </span>
<span class=quote>&gt; </span>
<span class=quote>&gt; Even on ILP32, using void* pointer will reserve the size required to </span>
<span class=quote>&gt; save a pointer address. I don't think using void* should be problem.</span>

I think you're still assuming sizeof(void *) is the same in kernel vs
userspace whereas I'm thinking about an ILP32 user running on an LP64
kernel.  Thanks,

Alex
</pre>
</div>
<a name=23161861></a>
<div class=comment>
<div class=meta>
 <span><a href="https://patchwork.kernel.org/project/qemu-devel/list/?submitter=153211">Kirti Wankhede</a></span>
 <span class=pull-right>Feb. 17, 2020, 7:13 p.m. UTC | <a href=https://patchwork.kernel.org/comment/23161861/>#11</a></span>
</div>
<pre class=content>On 2/14/2020 4:50 AM, Alex Williamson wrote:
<span class=quote>&gt; On Fri, 14 Feb 2020 01:41:35 +0530</span>
<span class=quote>&gt; Kirti Wankhede &lt;kwankhede@nvidia.com&gt; wrote:</span>
<span class=quote>&gt; </span>
<span class=quote>&gt;&gt; &lt;snip&gt;</span>
<span class=quote>&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt;     </span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +static int vfio_iova_dirty_bitmap(struct vfio_iommu *iommu, dma_addr_t iova,</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +				  size_t size, uint64_t pgsize,</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +				  unsigned char __user *bitmap)</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +{</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +	struct vfio_dma *dma;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +	dma_addr_t i = iova, iova_limit;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +	unsigned int bsize, nbits = 0, l = 0;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +	unsigned long pgshift = __ffs(pgsize);</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +	while ((dma = vfio_find_dma(iommu, i, pgsize))) {</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +		int ret, j;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +		unsigned int npages = 0, shift = 0;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +		unsigned char temp = 0;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +		/* mark all pages dirty if all pages are pinned and mapped. */</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +		if (dma-&gt;iommu_mapped) {</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +			iova_limit = min(dma-&gt;iova + dma-&gt;size, iova + size);</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +			npages = iova_limit/pgsize;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +			bitmap_set(dma-&gt;bitmap, 0, npages);</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; npages is derived from iova_limit, which is the number of bits to set</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; dirty relative to the first requested iova, not iova zero, ie. the set</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; of dirty bits is offset from those requested unless iova == dma-&gt;iova.</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;       </span>
<span class=quote>&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt;&gt; Right, fixing.</span>
<span class=quote>&gt;&gt;&gt;&gt;   </span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; Also I hope dma-&gt;bitmap was actually allocated.  Not only does the</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; START error path potentially leave dirty tracking enabled without all</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; the bitmap allocated, when does the bitmap get allocated for a new</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; vfio_dma when dirty tracking is enabled?  Seems it only occurs if a</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; vpfn gets marked dirty.</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;       </span>
<span class=quote>&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt;&gt; Right.</span>
<span class=quote>&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt;&gt; Fixing error paths.</span>
<span class=quote>&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt;&gt;   </span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +		} else if (dma-&gt;bitmap) {</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +			struct rb_node *n = rb_first(&amp;dma-&gt;pfn_list);</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +			bool found = false;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +			for (; n; n = rb_next(n)) {</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +				struct vfio_pfn *vpfn = rb_entry(n,</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +						struct vfio_pfn, node);</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +				if (vpfn-&gt;iova &gt;= i) {</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +					found = true;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +					break;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +				}</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +			}</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +			if (!found) {</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +				i += dma-&gt;size;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +				continue;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +			}</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +			for (; n; n = rb_next(n)) {</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +				unsigned int s;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +				struct vfio_pfn *vpfn = rb_entry(n,</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +						struct vfio_pfn, node);</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +				if (vpfn-&gt;iova &gt;= iova + size)</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +					break;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +				s = (vpfn-&gt;iova - dma-&gt;iova) &gt;&gt; pgshift;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +				bitmap_set(dma-&gt;bitmap, s, 1);</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +				iova_limit = vpfn-&gt;iova + pgsize;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +			}</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +			npages = iova_limit/pgsize;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; Isn't iova_limit potentially uninitialized here?  For example, if our</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; vfio_dma covers {0,8192} and we ask for the bitmap of {0,4096} and</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; there's a vpfn at {4096,8192}.  I think that means vpfn-&gt;iova &gt;= i</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; (4096 &gt;= 0), so we break with found = true, then we test 4096 &gt;= 0 +</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; 4096 and break, and npages = ????/pgsize.</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;       </span>
<span class=quote>&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt;&gt; Right, Fixing it.</span>
<span class=quote>&gt;&gt;&gt;&gt;   </span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +		}</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +		bsize = dirty_bitmap_bytes(npages);</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +		shift = nbits % BITS_PER_BYTE;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +		if (npages &amp;&amp; shift) {</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +			l--;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +			if (!access_ok((void __user *)bitmap + l,</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +					sizeof(unsigned char)))</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +				return -EINVAL;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +			ret = __get_user(temp, bitmap + l);</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; I don't understand why we care to get the user's bitmap, are we trying</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; to leave whatever garbage they might have set in it and only also set</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; the dirty bits?  That seems unnecessary.</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;       </span>
<span class=quote>&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt;&gt; Suppose dma mapped ranges are {start, size}:</span>
<span class=quote>&gt;&gt;&gt;&gt; {0, 0xa000}, {0xa000, 0x10000}</span>
<span class=quote>&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt;&gt; Bitmap asked from 0 - 0x10000. Say suppose all pages are dirty.</span>
<span class=quote>&gt;&gt;&gt;&gt; Then in first iteration for dma {0,0xa000} there are 10 pages, so 10</span>
<span class=quote>&gt;&gt;&gt;&gt; bits are set, put_user() happens for 2 bytes, (00000011 11111111b).</span>
<span class=quote>&gt;&gt;&gt;&gt; In second iteration for dma {0xa000, 0x10000} there are 6 pages and</span>
<span class=quote>&gt;&gt;&gt;&gt; these bits should be appended to previous byte. So get_user() that byte,</span>
<span class=quote>&gt;&gt;&gt;&gt; then shift-OR rest of the bitmap, result should be: (11111111 11111111b)</span>
<span class=quote>&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt;&gt; Without get_user() and shift-OR, resulting bitmap would be</span>
<span class=quote>&gt;&gt;&gt;&gt; 111111 00000011 11111111b which would be wrong.</span>
<span class=quote>&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt; Seems like if we use a put_user() approach then we should look for</span>
<span class=quote>&gt;&gt;&gt; adjacent vfio_dmas within the same byte/word/dword before we push it to</span>
<span class=quote>&gt;&gt;&gt; the user to avoid this sort of inefficiency.</span>
<span class=quote>&gt;&gt;&gt;    </span>
<span class=quote>&gt;&gt;</span>
<span class=quote>&gt;&gt; Won't that add more complication to logic?</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; I'm tempted to think it might be less complicated.</span>
<span class=quote>&gt;   </span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; Also why do we need these access_ok() checks when we already checked</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; the range at the start of the ioctl?</span>
<span class=quote>&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt;&gt; Since pointer is updated runtime here, better to check that pointer</span>
<span class=quote>&gt;&gt;&gt;&gt; before using that pointer.</span>
<span class=quote>&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt; Sorry, I still don't understand this, we check access_ok() with a</span>
<span class=quote>&gt;&gt;&gt; pointer and a length, therefore as long as we're incrementing the</span>
<span class=quote>&gt;&gt;&gt; pointer within that length, why do we need to retest?</span>
<span class=quote>&gt;&gt;&gt;    </span>
<span class=quote>&gt;&gt;</span>
<span class=quote>&gt;&gt; Ideally caller for put_user() and get_user() must check the pointer with</span>
<span class=quote>&gt;&gt; access_ok() which is used as argument to these functions before calling</span>
<span class=quote>&gt;&gt; this function. That makes sure that pointer is correct after pointer</span>
<span class=quote>&gt;&gt; arithematic. May be lets remove previous check of pointer and length,</span>
<span class=quote>&gt;&gt; but keep these checks.</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; So we don't trust that we can increment a pointer within a range that</span>
<span class=quote>&gt; we've already tested with access_ok() and expect it to still be ok?  I</span>
<span class=quote>&gt; think the point of having access_ok() and __put_user() is that we can</span>
<span class=quote>&gt; batch many __put_user() calls under a single access_ok() check.  I</span>
<span class=quote>&gt; don't see any justification here why if we already tested</span>
<span class=quote>&gt; access_ok(ptr, 2) that we still need to test access_ok(ptr + 0, 1) and</span>
<span class=quote>&gt; access_ok(ptr + 1, 1), and removing the initial test is clearly the</span>
<span class=quote>&gt; wrong optimization if we agree there is redundancy here.	</span>
<span class=quote>&gt; </span>

access_ok(ptr + x, 1), where x is variable, then x shouldn't be out of 
range. If we go with initial test, then there should be check for x, 
such that x is within range.
<span class=quote>
&gt;&gt;&gt;&gt;&gt;&gt; +			if (ret)</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +				return ret;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +		}</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +		for (j = 0; j &lt; bsize; j++, l++) {</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +			temp = temp |</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +			       (*((unsigned char *)dma-&gt;bitmap + j) &lt;&lt; shift);</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; |=</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;       </span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +			if (!access_ok((void __user *)bitmap + l,</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +					sizeof(unsigned char)))</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +				return -EINVAL;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +			ret = __put_user(temp, bitmap + l);</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +			if (ret)</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +				return ret;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +			if (shift) {</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +				temp = *((unsigned char *)dma-&gt;bitmap + j) &gt;&gt;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +					(BITS_PER_BYTE - shift);</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +			}</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; When shift == 0, temp just seems to accumulate bits that never get</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; cleared.</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;       </span>
<span class=quote>&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt;&gt; Hope example above explains the shift logic.</span>
<span class=quote>&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt; But that example is when shift is non-zero.  When shift is zero, each</span>
<span class=quote>&gt;&gt;&gt; iteration of the loop just ORs in new bits to temp without ever</span>
<span class=quote>&gt;&gt;&gt; clearing the bits for the previous iteration.</span>
<span class=quote>&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt;    </span>
<span class=quote>&gt;&gt;</span>
<span class=quote>&gt;&gt; Oh right, fixing it.</span>
<span class=quote>&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +		}</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +		nbits += npages;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +		i = min(dma-&gt;iova + dma-&gt;size, iova + size);</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +		if (i &gt;= iova + size)</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +			break;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; So whether we error or succeed, we leave cruft in dma-&gt;bitmap for the</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; next pass.  It doesn't seem to make any sense why we pre-allocated the</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; bitmap, we might as well just allocate it on demand here.  Actually, if</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; we're not going to do a copy_to_user() for some range of the bitmap,</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; I'm not sure what it's purpose is at all.  I think the big advantages</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; of the bitmap are that we can't amortize the cost across every pinned</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; page or DMA mapping, we don't need the overhead of tracking unmapped</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; vpfns, and we can use copy_to_user() to push the bitmap out.  We're not</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; getting any of those advantages here.</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;       </span>
<span class=quote>&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt;&gt; That would still not work if dma range size is not multiples of 8 pages.</span>
<span class=quote>&gt;&gt;&gt;&gt; See example above.</span>
<span class=quote>&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt; I don't understand this comment, what about the example above justifies</span>
<span class=quote>&gt;&gt;&gt; the bitmap?</span>
<span class=quote>&gt;&gt;</span>
<span class=quote>&gt;&gt; copy_to_user() could be used if dma range size is not multiple of 8 pages.</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; s/is not/is/ ?</span>
<span class=quote>&gt; </span>

My bad, you're right.
<span class=quote>
&gt; And we expect that to be a far more common case, right?  I don't think</span>
<span class=quote>&gt; there are too many ranges for a guest that are only mapped in sub-32KB</span>
<span class=quote>&gt; chucks.</span>
<span class=quote>&gt;   </span>
<span class=quote>&gt;&gt;&gt;   As I understand the above algorithm, we find a vfio_dma</span>
<span class=quote>&gt;&gt;&gt; overlapping the request and populate the bitmap for that range.  Then</span>
<span class=quote>&gt;&gt;&gt; we go back and put_user() for each byte that we touched.  We could</span>
<span class=quote>&gt;&gt;&gt; instead simply work on a one byte buffer as we enumerate the requested</span>
<span class=quote>&gt;&gt;&gt; range and do a put_user() ever time we reach the end of it and have bits</span>
<span class=quote>&gt;&gt;&gt; set. That would greatly simplify the above example.  But I would expect</span>
<span class=quote>&gt;&gt;&gt; that we're a) more likely to get asked for ranges covering a single</span>
<span class=quote>&gt;&gt;&gt; vfio_dma</span>
<span class=quote>&gt;&gt;</span>
<span class=quote>&gt;&gt; QEMU ask for single vfio_dma during each iteration.</span>
<span class=quote>&gt;&gt;</span>
<span class=quote>&gt;&gt; If we restrict this ABI to cover single vfio_dma only, then it</span>
<span class=quote>&gt;&gt; simplifies the logic here. That was my original suggestion. Should we</span>
<span class=quote>&gt;&gt; think about that again?</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; But we currently allow unmaps that overlap multiple vfio_dmas as long</span>
<span class=quote>&gt; as no vfio_dma is bisected, so I think that implies that an unmap while</span>
<span class=quote>&gt; asking for the dirty bitmap has even further restricted semantics.  I'm</span>
<span class=quote>&gt; also reluctant to design an ABI around what happens to be the current</span>
<span class=quote>&gt; QEMU implementation.</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; If we take your example above, ranges {0x0000,0xa000} and</span>
<span class=quote>&gt; {0xa000,0x10000} ({start,end}), I think you're working with the</span>
<span class=quote>&gt; following two bitmaps in this implementation:</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; 00000011 11111111b</span>
<span class=quote>&gt; 00111111b</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; And we need to combine those into:</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; 11111111 11111111b</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; Right?</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; But it seems like that would be easier if the second bitmap was instead:</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; 11111100b</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; Then we wouldn't need to worry about the entire bitmap being shifted by</span>
<span class=quote>&gt; the bit offset within the byte, which limits our fixes to the boundary</span>
<span class=quote>&gt; byte and allows us to use copy_to_user() directly for the bulk of the</span>
<span class=quote>&gt; copy.  So how do we get there?</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; I think we start with allocating the vfio_dma bitmap to account for</span>
<span class=quote>&gt; this initial offset, so we calculate bitmap_base_iova as:</span>
<span class=quote>&gt;    (iova &amp; ~((PAGE_SIZE &lt;&lt; 3) - 1))</span>
<span class=quote>&gt; We then use bitmap_base_iova in calculating which bits to set.</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; The user needs to follow the same rules, and maybe this adds some value</span>
<span class=quote>&gt; to the user providing the bitmap size rather than the kernel</span>
<span class=quote>&gt; calculating it.  For example, if the user wanted the dirty bitmap for</span>
<span class=quote>&gt; the range {0xa000,0x10000} above, they'd provide at least a 1 byte</span>
<span class=quote>&gt; bitmap, but we'd return bit #2 set to indicate 0xa000 is dirty.</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; Effectively the user can ask for any iova range, but the buffer will be</span>
<span class=quote>&gt; filled relative to the zeroth bit of the bitmap following the above</span>
<span class=quote>&gt; bitmap_base_iova formula (and replacing PAGE_SIZE with the user</span>
<span class=quote>&gt; requested pgsize).  I'm tempted to make this explicit in the user</span>
<span class=quote>&gt; interface (ie. only allow bitmaps starting on aligned pages), but a</span>
<span class=quote>&gt; user is able to map and unmap single pages and we need to support</span>
<span class=quote>&gt; returning a dirty bitmap with an unmap, so I don't think we can do that.</span>
<span class=quote>&gt; </span>

Sigh, finding adjacent vfio_dmas within the same byte seems simpler than 
this.
<span class=quote>
&gt; So now are we biting off more than we can chew trying to transpose the</span>
<span class=quote>&gt; bitmap between page sizes?  If asked for the previous range with an 8K</span>
<span class=quote>&gt; pgsize, we'd somehow need to translate 11111100b into 00001110b.</span>
<span class=quote>&gt; What's worse, the user could ask for just the 8K page at 0xa000 and we'd</span>
<span class=quote>&gt; need to return back 00000010b while leaving our internal bitmap a</span>
<span class=quote>&gt; 11110000b after we mark the bits clean.  Seems like this is really</span>
<span class=quote>&gt; only tenable if we do multiples of PAGE_SIZE pages within a byte, so</span>
<span class=quote>&gt; for 4K we'd have 32K, 64K, 128K, 256K, etc.  I'm somewhat losing sight</span>
<span class=quote>&gt; on what this accomplishes though and whether we need this in the first</span>
<span class=quote>&gt; implementation.  Should we simplify by dropping this aspect of it,</span>
<span class=quote>&gt; supporting only the minimum iommu page size, and focus on actually</span>
<span class=quote>&gt; using the bitmaps effectively?</span>
<span class=quote>&gt;   </span>

Sure, this will help to push first implementation, we can add 
optimization later.
<span class=quote>
&gt;&gt;&gt; and b) we're going to spend far more time operating in the</span>
<span class=quote>&gt;&gt;&gt; middle of the range and limiting ourselves to one-byte operations there</span>
<span class=quote>&gt;&gt;&gt; seems absurd.  If we want to specify that the user provides 4-byte</span>
<span class=quote>&gt;&gt;&gt; aligned buffers and naturally aligned iova ranges to make our lives</span>
<span class=quote>&gt;&gt;&gt; easier in the kernel, now would be the time to do that.</span>
<span class=quote>&gt;&gt;&gt;    </span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +	}</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +	return 0;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +}</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +static long verify_bitmap_size(unsigned long npages, unsigned long bitmap_size)</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +{</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +	long bsize;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +	if (!bitmap_size || bitmap_size &gt; SIZE_MAX)</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +		return -EINVAL;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +	bsize = dirty_bitmap_bytes(npages);</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +	if (bitmap_size &lt; bsize)</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +		return -EINVAL;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +	return bsize;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +}</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; Seems like this could simply return int, -errno or zero for success.</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; The returned bsize is not used for anything else.</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;       </span>
<span class=quote>&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt;&gt; ok.</span>
<span class=quote>&gt;&gt;&gt;&gt;   </span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt;     static int vfio_dma_do_unmap(struct vfio_iommu *iommu,</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt;     			     struct vfio_iommu_type1_dma_unmap *unmap)</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt;     {</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; @@ -2277,6 +2478,80 @@ static long vfio_iommu_type1_ioctl(void *iommu_data,</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt;     </span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt;     		return copy_to_user((void __user *)arg, &amp;unmap, minsz) ?</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt;     			-EFAULT : 0;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +	} else if (cmd == VFIO_IOMMU_DIRTY_PAGES) {</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +		struct vfio_iommu_type1_dirty_bitmap range;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +		uint32_t mask = VFIO_IOMMU_DIRTY_PAGES_FLAG_START |</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +				VFIO_IOMMU_DIRTY_PAGES_FLAG_STOP |</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +				VFIO_IOMMU_DIRTY_PAGES_FLAG_GET_BITMAP;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +		int ret;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +		if (!iommu-&gt;v2)</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +			return -EACCES;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +		minsz = offsetofend(struct vfio_iommu_type1_dirty_bitmap,</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; +				    bitmap);</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; We require the user to provide iova, size, pgsize, bitmap_size, and</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; bitmap fields to START/STOP?  Why?</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;      </span>
<span class=quote>&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt;&gt; No. But those are part of structure.</span>
<span class=quote>&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt; But we do require it, minsz here includes all those fields, which would</span>
<span class=quote>&gt;&gt;&gt; probably make a user scratch their head wondering why they need to pass</span>
<span class=quote>&gt;&gt;&gt; irrelevant data for START/STOP.  It almost implies that we support</span>
<span class=quote>&gt;&gt;&gt; starting and stopping dirty logging for specific ranges of the IOVA</span>
<span class=quote>&gt;&gt;&gt; space.  We could define the structure, for example:</span>
<span class=quote>&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt; struct vfio_iommu_type1_dirty_bitmap {</span>
<span class=quote>&gt;&gt;&gt; 	__u32	argsz;</span>
<span class=quote>&gt;&gt;&gt; 	__u32	flags;</span>
<span class=quote>&gt;&gt;&gt; 	__u8	data[];</span>
<span class=quote>&gt;&gt;&gt; };</span>
<span class=quote>&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt; struct vfio_iommu_type1_dirty_bitmap_get {</span>
<span class=quote>&gt;&gt;&gt; 	__u64	iova;</span>
<span class=quote>&gt;&gt;&gt; 	__u64	size;</span>
<span class=quote>&gt;&gt;&gt; 	__u64	pgsize;</span>
<span class=quote>&gt;&gt;&gt; 	__u64	bitmap_size;</span>
<span class=quote>&gt;&gt;&gt; 	void __user *bitmap;</span>
<span class=quote>&gt;&gt;&gt; };</span>
<span class=quote>&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt; Where data[] is defined as the latter structure when FLAG_GET_BITMAP is</span>
<span class=quote>&gt;&gt;&gt; specified.</span>
<span class=quote>&gt;&gt;</span>
<span class=quote>&gt;&gt; Ok. Changing as above.</span>
<span class=quote>&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt;   BTW, don't we need to specify the trailing void* as __u64?</span>
<span class=quote>&gt;&gt;&gt; We could theoretically be talking to an ILP32 user process.  Thanks,</span>
<span class=quote>&gt;&gt;&gt;    </span>
<span class=quote>&gt;&gt;</span>
<span class=quote>&gt;&gt; Even on ILP32, using void* pointer will reserve the size required to</span>
<span class=quote>&gt;&gt; save a pointer address. I don't think using void* should be problem.</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; I think you're still assuming sizeof(void *) is the same in kernel vs</span>
<span class=quote>&gt; userspace whereas I'm thinking about an ILP32 user running on an LP64</span>
<span class=quote>&gt; kernel.  Thanks,</span>
<span class=quote>&gt; </span>
Ok. Changing it to __u64

Thanks,
Kirti
</pre>
</div>
<a name=23162025></a>
<div class=comment>
<div class=meta>
 <span><a href="https://patchwork.kernel.org/project/qemu-devel/list/?submitter=7781">Alex Williamson</a></span>
 <span class=pull-right>Feb. 17, 2020, 8:55 p.m. UTC | <a href=https://patchwork.kernel.org/comment/23162025/>#12</a></span>
</div>
<pre class=content>On Tue, 18 Feb 2020 00:43:48 +0530
Kirti Wankhede &lt;kwankhede@nvidia.com&gt; wrote:
<span class=quote>
&gt; On 2/14/2020 4:50 AM, Alex Williamson wrote:</span>
<span class=quote>&gt; &gt; On Fri, 14 Feb 2020 01:41:35 +0530</span>
<span class=quote>&gt; &gt; Kirti Wankhede &lt;kwankhede@nvidia.com&gt; wrote:</span>
<span class=quote>&gt; &gt;   </span>
<span class=quote>&gt; &gt;&gt; &lt;snip&gt;</span>
<span class=quote>&gt; &gt;&gt;  </span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt;     </span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +static int vfio_iova_dirty_bitmap(struct vfio_iommu *iommu, dma_addr_t iova,</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +				  size_t size, uint64_t pgsize,</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +				  unsigned char __user *bitmap)</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +{</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +	struct vfio_dma *dma;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +	dma_addr_t i = iova, iova_limit;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +	unsigned int bsize, nbits = 0, l = 0;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +	unsigned long pgshift = __ffs(pgsize);</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +	while ((dma = vfio_find_dma(iommu, i, pgsize))) {</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +		int ret, j;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +		unsigned int npages = 0, shift = 0;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +		unsigned char temp = 0;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +		/* mark all pages dirty if all pages are pinned and mapped. */</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +		if (dma-&gt;iommu_mapped) {</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +			iova_limit = min(dma-&gt;iova + dma-&gt;size, iova + size);</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +			npages = iova_limit/pgsize;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +			bitmap_set(dma-&gt;bitmap, 0, npages);  </span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; npages is derived from iova_limit, which is the number of bits to set</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; dirty relative to the first requested iova, not iova zero, ie. the set</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; of dirty bits is offset from those requested unless iova == dma-&gt;iova.</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;         </span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; Right, fixing.</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;     </span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; Also I hope dma-&gt;bitmap was actually allocated.  Not only does the</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; START error path potentially leave dirty tracking enabled without all</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; the bitmap allocated, when does the bitmap get allocated for a new</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; vfio_dma when dirty tracking is enabled?  Seems it only occurs if a</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; vpfn gets marked dirty.</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;         </span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; Right.</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; Fixing error paths.</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;     </span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +		} else if (dma-&gt;bitmap) {</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +			struct rb_node *n = rb_first(&amp;dma-&gt;pfn_list);</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +			bool found = false;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +			for (; n; n = rb_next(n)) {</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +				struct vfio_pfn *vpfn = rb_entry(n,</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +						struct vfio_pfn, node);</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +				if (vpfn-&gt;iova &gt;= i) {</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +					found = true;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +					break;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +				}</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +			}</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +			if (!found) {</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +				i += dma-&gt;size;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +				continue;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +			}</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +			for (; n; n = rb_next(n)) {</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +				unsigned int s;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +				struct vfio_pfn *vpfn = rb_entry(n,</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +						struct vfio_pfn, node);</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +				if (vpfn-&gt;iova &gt;= iova + size)</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +					break;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +				s = (vpfn-&gt;iova - dma-&gt;iova) &gt;&gt; pgshift;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +				bitmap_set(dma-&gt;bitmap, s, 1);</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +				iova_limit = vpfn-&gt;iova + pgsize;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +			}</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +			npages = iova_limit/pgsize;  </span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; Isn't iova_limit potentially uninitialized here?  For example, if our</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; vfio_dma covers {0,8192} and we ask for the bitmap of {0,4096} and</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; there's a vpfn at {4096,8192}.  I think that means vpfn-&gt;iova &gt;= i</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; (4096 &gt;= 0), so we break with found = true, then we test 4096 &gt;= 0 +</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; 4096 and break, and npages = ????/pgsize.</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;         </span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; Right, Fixing it.</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;     </span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +		}</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +		bsize = dirty_bitmap_bytes(npages);</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +		shift = nbits % BITS_PER_BYTE;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +		if (npages &amp;&amp; shift) {</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +			l--;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +			if (!access_ok((void __user *)bitmap + l,</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +					sizeof(unsigned char)))</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +				return -EINVAL;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +			ret = __get_user(temp, bitmap + l);  </span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; I don't understand why we care to get the user's bitmap, are we trying</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; to leave whatever garbage they might have set in it and only also set</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; the dirty bits?  That seems unnecessary.</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;         </span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; Suppose dma mapped ranges are {start, size}:</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; {0, 0xa000}, {0xa000, 0x10000}</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; Bitmap asked from 0 - 0x10000. Say suppose all pages are dirty.</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; Then in first iteration for dma {0,0xa000} there are 10 pages, so 10</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; bits are set, put_user() happens for 2 bytes, (00000011 11111111b).</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; In second iteration for dma {0xa000, 0x10000} there are 6 pages and</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; these bits should be appended to previous byte. So get_user() that byte,</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; then shift-OR rest of the bitmap, result should be: (11111111 11111111b)</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; Without get_user() and shift-OR, resulting bitmap would be</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; 111111 00000011 11111111b which would be wrong.  </span>
<span class=quote>&gt; &gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt; Seems like if we use a put_user() approach then we should look for</span>
<span class=quote>&gt; &gt;&gt;&gt; adjacent vfio_dmas within the same byte/word/dword before we push it to</span>
<span class=quote>&gt; &gt;&gt;&gt; the user to avoid this sort of inefficiency.</span>
<span class=quote>&gt; &gt;&gt;&gt;      </span>
<span class=quote>&gt; &gt;&gt;</span>
<span class=quote>&gt; &gt;&gt; Won't that add more complication to logic?  </span>
<span class=quote>&gt; &gt; </span>
<span class=quote>&gt; &gt; I'm tempted to think it might be less complicated.</span>
<span class=quote>&gt; &gt;     </span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; Also why do we need these access_ok() checks when we already checked</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; the range at the start of the ioctl?  </span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; Since pointer is updated runtime here, better to check that pointer</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; before using that pointer.  </span>
<span class=quote>&gt; &gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt; Sorry, I still don't understand this, we check access_ok() with a</span>
<span class=quote>&gt; &gt;&gt;&gt; pointer and a length, therefore as long as we're incrementing the</span>
<span class=quote>&gt; &gt;&gt;&gt; pointer within that length, why do we need to retest?</span>
<span class=quote>&gt; &gt;&gt;&gt;      </span>
<span class=quote>&gt; &gt;&gt;</span>
<span class=quote>&gt; &gt;&gt; Ideally caller for put_user() and get_user() must check the pointer with</span>
<span class=quote>&gt; &gt;&gt; access_ok() which is used as argument to these functions before calling</span>
<span class=quote>&gt; &gt;&gt; this function. That makes sure that pointer is correct after pointer</span>
<span class=quote>&gt; &gt;&gt; arithematic. May be lets remove previous check of pointer and length,</span>
<span class=quote>&gt; &gt;&gt; but keep these checks.  </span>
<span class=quote>&gt; &gt; </span>
<span class=quote>&gt; &gt; So we don't trust that we can increment a pointer within a range that</span>
<span class=quote>&gt; &gt; we've already tested with access_ok() and expect it to still be ok?  I</span>
<span class=quote>&gt; &gt; think the point of having access_ok() and __put_user() is that we can</span>
<span class=quote>&gt; &gt; batch many __put_user() calls under a single access_ok() check.  I</span>
<span class=quote>&gt; &gt; don't see any justification here why if we already tested</span>
<span class=quote>&gt; &gt; access_ok(ptr, 2) that we still need to test access_ok(ptr + 0, 1) and</span>
<span class=quote>&gt; &gt; access_ok(ptr + 1, 1), and removing the initial test is clearly the</span>
<span class=quote>&gt; &gt; wrong optimization if we agree there is redundancy here.	</span>
<span class=quote>&gt; &gt;   </span>
<span class=quote>&gt; </span>
<span class=quote>&gt; access_ok(ptr + x, 1), where x is variable, then x shouldn't be out of </span>
<span class=quote>&gt; range. If we go with initial test, then there should be check for x, </span>
<span class=quote>&gt; such that x is within range.</span>

That logic should already exist though, we shouldn't be trying to fill
a bitmap beyond what the user requested and therefore what we've
already tested that it's sized for and we have access to.
<span class=quote> 
&gt; &gt;&gt;&gt;&gt;&gt;&gt; +			if (ret)</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +				return ret;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +		}</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +		for (j = 0; j &lt; bsize; j++, l++) {</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +			temp = temp |</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +			       (*((unsigned char *)dma-&gt;bitmap + j) &lt;&lt; shift);  </span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; |=</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;         </span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +			if (!access_ok((void __user *)bitmap + l,</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +					sizeof(unsigned char)))</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +				return -EINVAL;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +			ret = __put_user(temp, bitmap + l);</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +			if (ret)</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +				return ret;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +			if (shift) {</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +				temp = *((unsigned char *)dma-&gt;bitmap + j) &gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +					(BITS_PER_BYTE - shift);</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +			}  </span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; When shift == 0, temp just seems to accumulate bits that never get</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; cleared.</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;         </span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; Hope example above explains the shift logic.  </span>
<span class=quote>&gt; &gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt; But that example is when shift is non-zero.  When shift is zero, each</span>
<span class=quote>&gt; &gt;&gt;&gt; iteration of the loop just ORs in new bits to temp without ever</span>
<span class=quote>&gt; &gt;&gt;&gt; clearing the bits for the previous iteration.</span>
<span class=quote>&gt; &gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt;      </span>
<span class=quote>&gt; &gt;&gt;</span>
<span class=quote>&gt; &gt;&gt; Oh right, fixing it.</span>
<span class=quote>&gt; &gt;&gt;  </span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +		}</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +		nbits += npages;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +		i = min(dma-&gt;iova + dma-&gt;size, iova + size);</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +		if (i &gt;= iova + size)</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; +			break;  </span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; So whether we error or succeed, we leave cruft in dma-&gt;bitmap for the</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; next pass.  It doesn't seem to make any sense why we pre-allocated the</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; bitmap, we might as well just allocate it on demand here.  Actually, if</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; we're not going to do a copy_to_user() for some range of the bitmap,</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; I'm not sure what it's purpose is at all.  I think the big advantages</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; of the bitmap are that we can't amortize the cost across every pinned</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; page or DMA mapping, we don't need the overhead of tracking unmapped</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; vpfns, and we can use copy_to_user() to push the bitmap out.  We're not</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; getting any of those advantages here.</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;         </span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; That would still not work if dma range size is not multiples of 8 pages.</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; See example above.  </span>
<span class=quote>&gt; &gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt; I don't understand this comment, what about the example above justifies</span>
<span class=quote>&gt; &gt;&gt;&gt; the bitmap?  </span>
<span class=quote>&gt; &gt;&gt;</span>
<span class=quote>&gt; &gt;&gt; copy_to_user() could be used if dma range size is not multiple of 8 pages.  </span>
<span class=quote>&gt; &gt; </span>
<span class=quote>&gt; &gt; s/is not/is/ ?</span>
<span class=quote>&gt; &gt;   </span>
<span class=quote>&gt; </span>
<span class=quote>&gt; My bad, you're right.</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; &gt; And we expect that to be a far more common case, right?  I don't think</span>
<span class=quote>&gt; &gt; there are too many ranges for a guest that are only mapped in sub-32KB</span>
<span class=quote>&gt; &gt; chucks.</span>
<span class=quote>&gt; &gt;     </span>
<span class=quote>&gt; &gt;&gt;&gt;   As I understand the above algorithm, we find a vfio_dma</span>
<span class=quote>&gt; &gt;&gt;&gt; overlapping the request and populate the bitmap for that range.  Then</span>
<span class=quote>&gt; &gt;&gt;&gt; we go back and put_user() for each byte that we touched.  We could</span>
<span class=quote>&gt; &gt;&gt;&gt; instead simply work on a one byte buffer as we enumerate the requested</span>
<span class=quote>&gt; &gt;&gt;&gt; range and do a put_user() ever time we reach the end of it and have bits</span>
<span class=quote>&gt; &gt;&gt;&gt; set. That would greatly simplify the above example.  But I would expect</span>
<span class=quote>&gt; &gt;&gt;&gt; that we're a) more likely to get asked for ranges covering a single</span>
<span class=quote>&gt; &gt;&gt;&gt; vfio_dma  </span>
<span class=quote>&gt; &gt;&gt;</span>
<span class=quote>&gt; &gt;&gt; QEMU ask for single vfio_dma during each iteration.</span>
<span class=quote>&gt; &gt;&gt;</span>
<span class=quote>&gt; &gt;&gt; If we restrict this ABI to cover single vfio_dma only, then it</span>
<span class=quote>&gt; &gt;&gt; simplifies the logic here. That was my original suggestion. Should we</span>
<span class=quote>&gt; &gt;&gt; think about that again?  </span>
<span class=quote>&gt; &gt; </span>
<span class=quote>&gt; &gt; But we currently allow unmaps that overlap multiple vfio_dmas as long</span>
<span class=quote>&gt; &gt; as no vfio_dma is bisected, so I think that implies that an unmap while</span>
<span class=quote>&gt; &gt; asking for the dirty bitmap has even further restricted semantics.  I'm</span>
<span class=quote>&gt; &gt; also reluctant to design an ABI around what happens to be the current</span>
<span class=quote>&gt; &gt; QEMU implementation.</span>
<span class=quote>&gt; &gt; </span>
<span class=quote>&gt; &gt; If we take your example above, ranges {0x0000,0xa000} and</span>
<span class=quote>&gt; &gt; {0xa000,0x10000} ({start,end}), I think you're working with the</span>
<span class=quote>&gt; &gt; following two bitmaps in this implementation:</span>
<span class=quote>&gt; &gt; </span>
<span class=quote>&gt; &gt; 00000011 11111111b</span>
<span class=quote>&gt; &gt; 00111111b</span>
<span class=quote>&gt; &gt; </span>
<span class=quote>&gt; &gt; And we need to combine those into:</span>
<span class=quote>&gt; &gt; </span>
<span class=quote>&gt; &gt; 11111111 11111111b</span>
<span class=quote>&gt; &gt; </span>
<span class=quote>&gt; &gt; Right?</span>
<span class=quote>&gt; &gt; </span>
<span class=quote>&gt; &gt; But it seems like that would be easier if the second bitmap was instead:</span>
<span class=quote>&gt; &gt; </span>
<span class=quote>&gt; &gt; 11111100b</span>
<span class=quote>&gt; &gt; </span>
<span class=quote>&gt; &gt; Then we wouldn't need to worry about the entire bitmap being shifted by</span>
<span class=quote>&gt; &gt; the bit offset within the byte, which limits our fixes to the boundary</span>
<span class=quote>&gt; &gt; byte and allows us to use copy_to_user() directly for the bulk of the</span>
<span class=quote>&gt; &gt; copy.  So how do we get there?</span>
<span class=quote>&gt; &gt; </span>
<span class=quote>&gt; &gt; I think we start with allocating the vfio_dma bitmap to account for</span>
<span class=quote>&gt; &gt; this initial offset, so we calculate bitmap_base_iova as:</span>
<span class=quote>&gt; &gt;    (iova &amp; ~((PAGE_SIZE &lt;&lt; 3) - 1))</span>
<span class=quote>&gt; &gt; We then use bitmap_base_iova in calculating which bits to set.</span>
<span class=quote>&gt; &gt; </span>
<span class=quote>&gt; &gt; The user needs to follow the same rules, and maybe this adds some value</span>
<span class=quote>&gt; &gt; to the user providing the bitmap size rather than the kernel</span>
<span class=quote>&gt; &gt; calculating it.  For example, if the user wanted the dirty bitmap for</span>
<span class=quote>&gt; &gt; the range {0xa000,0x10000} above, they'd provide at least a 1 byte</span>
<span class=quote>&gt; &gt; bitmap, but we'd return bit #2 set to indicate 0xa000 is dirty.</span>
<span class=quote>&gt; &gt; </span>
<span class=quote>&gt; &gt; Effectively the user can ask for any iova range, but the buffer will be</span>
<span class=quote>&gt; &gt; filled relative to the zeroth bit of the bitmap following the above</span>
<span class=quote>&gt; &gt; bitmap_base_iova formula (and replacing PAGE_SIZE with the user</span>
<span class=quote>&gt; &gt; requested pgsize).  I'm tempted to make this explicit in the user</span>
<span class=quote>&gt; &gt; interface (ie. only allow bitmaps starting on aligned pages), but a</span>
<span class=quote>&gt; &gt; user is able to map and unmap single pages and we need to support</span>
<span class=quote>&gt; &gt; returning a dirty bitmap with an unmap, so I don't think we can do that.</span>
<span class=quote>&gt; &gt;   </span>
<span class=quote>&gt; </span>
<span class=quote>&gt; Sigh, finding adjacent vfio_dmas within the same byte seems simpler than </span>
<span class=quote>&gt; this.</span>

How does KVM do this?  My intent was that if all of our bitmaps share
the same alignment then we can merge the intersection and continue to
use copy_to_user() on either side.  However, if QEMU doesn't do the
same, it doesn't really help us.  Is QEMU stuck with an implementation
of only retrieving dirty bits per MemoryRegionSection exactly because
of this issue and therefore we can rely on it in our implementation as
well?  Thanks,

Alex
</pre>
</div>
<a name=23162563></a>
<div class=comment>
<div class=meta>
 <span><a href="https://patchwork.kernel.org/project/qemu-devel/list/?submitter=153211">Kirti Wankhede</a></span>
 <span class=pull-right>Feb. 18, 2020, 5:58 a.m. UTC | <a href=https://patchwork.kernel.org/comment/23162563/>#13</a></span>
</div>
<pre class=content>&lt;snip&gt;
<span class=quote>
&gt;&gt;&gt;&gt;&gt;    As I understand the above algorithm, we find a vfio_dma</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; overlapping the request and populate the bitmap for that range.  Then</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; we go back and put_user() for each byte that we touched.  We could</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; instead simply work on a one byte buffer as we enumerate the requested</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; range and do a put_user() ever time we reach the end of it and have bits</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; set. That would greatly simplify the above example.  But I would expect</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; that we're a) more likely to get asked for ranges covering a single</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; vfio_dma</span>
<span class=quote>&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt;&gt; QEMU ask for single vfio_dma during each iteration.</span>
<span class=quote>&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt;&gt; If we restrict this ABI to cover single vfio_dma only, then it</span>
<span class=quote>&gt;&gt;&gt;&gt; simplifies the logic here. That was my original suggestion. Should we</span>
<span class=quote>&gt;&gt;&gt;&gt; think about that again?</span>
<span class=quote>&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt; But we currently allow unmaps that overlap multiple vfio_dmas as long</span>
<span class=quote>&gt;&gt;&gt; as no vfio_dma is bisected, so I think that implies that an unmap while</span>
<span class=quote>&gt;&gt;&gt; asking for the dirty bitmap has even further restricted semantics.  I'm</span>
<span class=quote>&gt;&gt;&gt; also reluctant to design an ABI around what happens to be the current</span>
<span class=quote>&gt;&gt;&gt; QEMU implementation.</span>
<span class=quote>&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt; If we take your example above, ranges {0x0000,0xa000} and</span>
<span class=quote>&gt;&gt;&gt; {0xa000,0x10000} ({start,end}), I think you're working with the</span>
<span class=quote>&gt;&gt;&gt; following two bitmaps in this implementation:</span>
<span class=quote>&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt; 00000011 11111111b</span>
<span class=quote>&gt;&gt;&gt; 00111111b</span>
<span class=quote>&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt; And we need to combine those into:</span>
<span class=quote>&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt; 11111111 11111111b</span>
<span class=quote>&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt; Right?</span>
<span class=quote>&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt; But it seems like that would be easier if the second bitmap was instead:</span>
<span class=quote>&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt; 11111100b</span>
<span class=quote>&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt; Then we wouldn't need to worry about the entire bitmap being shifted by</span>
<span class=quote>&gt;&gt;&gt; the bit offset within the byte, which limits our fixes to the boundary</span>
<span class=quote>&gt;&gt;&gt; byte and allows us to use copy_to_user() directly for the bulk of the</span>
<span class=quote>&gt;&gt;&gt; copy.  So how do we get there?</span>
<span class=quote>&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt; I think we start with allocating the vfio_dma bitmap to account for</span>
<span class=quote>&gt;&gt;&gt; this initial offset, so we calculate bitmap_base_iova as:</span>
<span class=quote>&gt;&gt;&gt;     (iova &amp; ~((PAGE_SIZE &lt;&lt; 3) - 1))</span>
<span class=quote>&gt;&gt;&gt; We then use bitmap_base_iova in calculating which bits to set.</span>
<span class=quote>&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt; The user needs to follow the same rules, and maybe this adds some value</span>
<span class=quote>&gt;&gt;&gt; to the user providing the bitmap size rather than the kernel</span>
<span class=quote>&gt;&gt;&gt; calculating it.  For example, if the user wanted the dirty bitmap for</span>
<span class=quote>&gt;&gt;&gt; the range {0xa000,0x10000} above, they'd provide at least a 1 byte</span>
<span class=quote>&gt;&gt;&gt; bitmap, but we'd return bit #2 set to indicate 0xa000 is dirty.</span>
<span class=quote>&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt; Effectively the user can ask for any iova range, but the buffer will be</span>
<span class=quote>&gt;&gt;&gt; filled relative to the zeroth bit of the bitmap following the above</span>
<span class=quote>&gt;&gt;&gt; bitmap_base_iova formula (and replacing PAGE_SIZE with the user</span>
<span class=quote>&gt;&gt;&gt; requested pgsize).  I'm tempted to make this explicit in the user</span>
<span class=quote>&gt;&gt;&gt; interface (ie. only allow bitmaps starting on aligned pages), but a</span>
<span class=quote>&gt;&gt;&gt; user is able to map and unmap single pages and we need to support</span>
<span class=quote>&gt;&gt;&gt; returning a dirty bitmap with an unmap, so I don't think we can do that.</span>
<span class=quote>&gt;&gt;&gt;    </span>
<span class=quote>&gt;&gt;</span>
<span class=quote>&gt;&gt; Sigh, finding adjacent vfio_dmas within the same byte seems simpler than</span>
<span class=quote>&gt;&gt; this.</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; How does KVM do this?  My intent was that if all of our bitmaps share</span>
<span class=quote>&gt; the same alignment then we can merge the intersection and continue to</span>
<span class=quote>&gt; use copy_to_user() on either side.  However, if QEMU doesn't do the</span>
<span class=quote>&gt; same, it doesn't really help us.  Is QEMU stuck with an implementation</span>
<span class=quote>&gt; of only retrieving dirty bits per MemoryRegionSection exactly because</span>
<span class=quote>&gt; of this issue and therefore we can rely on it in our implementation as</span>
<span class=quote>&gt; well?  Thanks,</span>
<span class=quote>&gt; </span>

QEMU sync dirty_bitmap per MemoryRegionSection. Within 
MemoryRegionSection there could be multiple KVMSlots. QEMU queries 
dirty_bitmap per KVMSlot and mark dirty for each KVMSlot.
On kernel side, KVM_GET_DIRTY_LOG ioctl calls 
kvm_get_dirty_log_protect(), where it uses copy_to_user() to copy bitmap 
of that memSlot.
vfio_dma is per MemoryRegionSection. We can reply on MemoryRegionSection 
in our implementation. But to get bitmap during unmap, we have to take 
care of concatenating bitmaps.

In QEMU, in function kvm_physical_sync_dirty_bitmap() there is a comment 
where bitmap size is calculated and bitmap is defined as 'void __user 
*dirty_bitmap' which is also the concern you raised and could be handled 
similarly as below.

         /* XXX bad kernel interface alert
          * For dirty bitmap, kernel allocates array of size aligned to
          * bits-per-long.  But for case when the kernel is 64bits and
          * the userspace is 32bits, userspace can't align to the same
          * bits-per-long, since sizeof(long) is different between kernel
          * and user space.  This way, userspace will provide buffer which
          * may be 4 bytes less than the kernel will use, resulting in
          * userspace memory corruption (which is not detectable by valgrind
          * too, in most cases).
          * So for now, let's align to 64 instead of HOST_LONG_BITS here, in
          * a hope that sizeof(long) won't become &gt;8 any time soon.
          */
         if (!mem-&gt;dirty_bmap) {
             hwaddr bitmap_size = ALIGN(((mem-&gt;memory_size) &gt;&gt; 
TARGET_PAGE_BITS),
                                         /*HOST_LONG_BITS*/ 64) / 8;
             /* Allocate on the first log_sync, once and for all */
             mem-&gt;dirty_bmap = g_malloc0(bitmap_size);
         }

Thanks,
Kirti
</pre>
</div>
<a name=23165235></a>
<div class=comment>
<div class=meta>
 <span><a href="https://patchwork.kernel.org/project/qemu-devel/list/?submitter=7781">Alex Williamson</a></span>
 <span class=pull-right>Feb. 18, 2020, 9:41 p.m. UTC | <a href=https://patchwork.kernel.org/comment/23165235/>#14</a></span>
</div>
<pre class=content>On Tue, 18 Feb 2020 11:28:53 +0530
Kirti Wankhede &lt;kwankhede@nvidia.com&gt; wrote:
<span class=quote>
&gt; &lt;snip&gt;</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;    As I understand the above algorithm, we find a vfio_dma</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; overlapping the request and populate the bitmap for that range.  Then</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; we go back and put_user() for each byte that we touched.  We could</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; instead simply work on a one byte buffer as we enumerate the requested</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; range and do a put_user() ever time we reach the end of it and have bits</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; set. That would greatly simplify the above example.  But I would expect</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; that we're a) more likely to get asked for ranges covering a single</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; vfio_dma  </span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; QEMU ask for single vfio_dma during each iteration.</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; If we restrict this ABI to cover single vfio_dma only, then it</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; simplifies the logic here. That was my original suggestion. Should we</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; think about that again?  </span>
<span class=quote>&gt; &gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt; But we currently allow unmaps that overlap multiple vfio_dmas as long</span>
<span class=quote>&gt; &gt;&gt;&gt; as no vfio_dma is bisected, so I think that implies that an unmap while</span>
<span class=quote>&gt; &gt;&gt;&gt; asking for the dirty bitmap has even further restricted semantics.  I'm</span>
<span class=quote>&gt; &gt;&gt;&gt; also reluctant to design an ABI around what happens to be the current</span>
<span class=quote>&gt; &gt;&gt;&gt; QEMU implementation.</span>
<span class=quote>&gt; &gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt; If we take your example above, ranges {0x0000,0xa000} and</span>
<span class=quote>&gt; &gt;&gt;&gt; {0xa000,0x10000} ({start,end}), I think you're working with the</span>
<span class=quote>&gt; &gt;&gt;&gt; following two bitmaps in this implementation:</span>
<span class=quote>&gt; &gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt; 00000011 11111111b</span>
<span class=quote>&gt; &gt;&gt;&gt; 00111111b</span>
<span class=quote>&gt; &gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt; And we need to combine those into:</span>
<span class=quote>&gt; &gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt; 11111111 11111111b</span>
<span class=quote>&gt; &gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt; Right?</span>
<span class=quote>&gt; &gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt; But it seems like that would be easier if the second bitmap was instead:</span>
<span class=quote>&gt; &gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt; 11111100b</span>
<span class=quote>&gt; &gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt; Then we wouldn't need to worry about the entire bitmap being shifted by</span>
<span class=quote>&gt; &gt;&gt;&gt; the bit offset within the byte, which limits our fixes to the boundary</span>
<span class=quote>&gt; &gt;&gt;&gt; byte and allows us to use copy_to_user() directly for the bulk of the</span>
<span class=quote>&gt; &gt;&gt;&gt; copy.  So how do we get there?</span>
<span class=quote>&gt; &gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt; I think we start with allocating the vfio_dma bitmap to account for</span>
<span class=quote>&gt; &gt;&gt;&gt; this initial offset, so we calculate bitmap_base_iova as:</span>
<span class=quote>&gt; &gt;&gt;&gt;     (iova &amp; ~((PAGE_SIZE &lt;&lt; 3) - 1))</span>
<span class=quote>&gt; &gt;&gt;&gt; We then use bitmap_base_iova in calculating which bits to set.</span>
<span class=quote>&gt; &gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt; The user needs to follow the same rules, and maybe this adds some value</span>
<span class=quote>&gt; &gt;&gt;&gt; to the user providing the bitmap size rather than the kernel</span>
<span class=quote>&gt; &gt;&gt;&gt; calculating it.  For example, if the user wanted the dirty bitmap for</span>
<span class=quote>&gt; &gt;&gt;&gt; the range {0xa000,0x10000} above, they'd provide at least a 1 byte</span>
<span class=quote>&gt; &gt;&gt;&gt; bitmap, but we'd return bit #2 set to indicate 0xa000 is dirty.</span>
<span class=quote>&gt; &gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt; Effectively the user can ask for any iova range, but the buffer will be</span>
<span class=quote>&gt; &gt;&gt;&gt; filled relative to the zeroth bit of the bitmap following the above</span>
<span class=quote>&gt; &gt;&gt;&gt; bitmap_base_iova formula (and replacing PAGE_SIZE with the user</span>
<span class=quote>&gt; &gt;&gt;&gt; requested pgsize).  I'm tempted to make this explicit in the user</span>
<span class=quote>&gt; &gt;&gt;&gt; interface (ie. only allow bitmaps starting on aligned pages), but a</span>
<span class=quote>&gt; &gt;&gt;&gt; user is able to map and unmap single pages and we need to support</span>
<span class=quote>&gt; &gt;&gt;&gt; returning a dirty bitmap with an unmap, so I don't think we can do that.</span>
<span class=quote>&gt; &gt;&gt;&gt;      </span>
<span class=quote>&gt; &gt;&gt;</span>
<span class=quote>&gt; &gt;&gt; Sigh, finding adjacent vfio_dmas within the same byte seems simpler than</span>
<span class=quote>&gt; &gt;&gt; this.  </span>
<span class=quote>&gt; &gt; </span>
<span class=quote>&gt; &gt; How does KVM do this?  My intent was that if all of our bitmaps share</span>
<span class=quote>&gt; &gt; the same alignment then we can merge the intersection and continue to</span>
<span class=quote>&gt; &gt; use copy_to_user() on either side.  However, if QEMU doesn't do the</span>
<span class=quote>&gt; &gt; same, it doesn't really help us.  Is QEMU stuck with an implementation</span>
<span class=quote>&gt; &gt; of only retrieving dirty bits per MemoryRegionSection exactly because</span>
<span class=quote>&gt; &gt; of this issue and therefore we can rely on it in our implementation as</span>
<span class=quote>&gt; &gt; well?  Thanks,</span>
<span class=quote>&gt; &gt;   </span>
<span class=quote>&gt; </span>
<span class=quote>&gt; QEMU sync dirty_bitmap per MemoryRegionSection. Within </span>
<span class=quote>&gt; MemoryRegionSection there could be multiple KVMSlots. QEMU queries </span>
<span class=quote>&gt; dirty_bitmap per KVMSlot and mark dirty for each KVMSlot.</span>
<span class=quote>&gt; On kernel side, KVM_GET_DIRTY_LOG ioctl calls </span>
<span class=quote>&gt; kvm_get_dirty_log_protect(), where it uses copy_to_user() to copy bitmap </span>
<span class=quote>&gt; of that memSlot.</span>
<span class=quote>&gt; vfio_dma is per MemoryRegionSection. We can reply on MemoryRegionSection </span>
<span class=quote>&gt; in our implementation. But to get bitmap during unmap, we have to take </span>
<span class=quote>&gt; care of concatenating bitmaps.</span>

So KVM does not worry about bitmap alignment because the interface is
based on slots, a dirty bitmap can only be retrieved for a single,
entire slot.  We need VFIO_IOMMU_UNMAP_DMA to maintain its support for
spanning multiple vfio_dmas, but maybe we have some leeway that we
don't need to support both multiple vfio_dmas and dirty bitmap at the
same time.  It seems like it would be a massive simplification if we
required an unmap with dirty bitmap to span exactly one vfio_dma,
right?  I don't see that we'd break any existing users with that, it's
unfortunate that we can't have the flexibility of the existing calling
convention, but I think there's good reason for it here.  Our separate
dirty bitmap log reporting would follow the same semantics.  I think
this all aligns with how the MemoryListener works in QEMU right now,
correct?  For example we wouldn't need any extra per MAP_DMA tracking
in QEMU like KVM has for its slots.
<span class=quote>
&gt; In QEMU, in function kvm_physical_sync_dirty_bitmap() there is a comment </span>
<span class=quote>&gt; where bitmap size is calculated and bitmap is defined as 'void __user </span>
<span class=quote>&gt; *dirty_bitmap' which is also the concern you raised and could be handled </span>
<span class=quote>&gt; similarly as below.</span>
<span class=quote>&gt; </span>
<span class=quote>&gt;          /* XXX bad kernel interface alert</span>
<span class=quote>&gt;           * For dirty bitmap, kernel allocates array of size aligned to</span>
<span class=quote>&gt;           * bits-per-long.  But for case when the kernel is 64bits and</span>
<span class=quote>&gt;           * the userspace is 32bits, userspace can't align to the same</span>
<span class=quote>&gt;           * bits-per-long, since sizeof(long) is different between kernel</span>
<span class=quote>&gt;           * and user space.  This way, userspace will provide buffer which</span>
<span class=quote>&gt;           * may be 4 bytes less than the kernel will use, resulting in</span>
<span class=quote>&gt;           * userspace memory corruption (which is not detectable by valgrind</span>
<span class=quote>&gt;           * too, in most cases).</span>
<span class=quote>&gt;           * So for now, let's align to 64 instead of HOST_LONG_BITS here, in</span>
<span class=quote>&gt;           * a hope that sizeof(long) won't become &gt;8 any time soon.</span>
<span class=quote>&gt;           */</span>
<span class=quote>&gt;          if (!mem-&gt;dirty_bmap) {</span>
<span class=quote>&gt;              hwaddr bitmap_size = ALIGN(((mem-&gt;memory_size) &gt;&gt; </span>
<span class=quote>&gt; TARGET_PAGE_BITS),</span>
<span class=quote>&gt;                                          /*HOST_LONG_BITS*/ 64) / 8;</span>
<span class=quote>&gt;              /* Allocate on the first log_sync, once and for all */</span>
<span class=quote>&gt;              mem-&gt;dirty_bmap = g_malloc0(bitmap_size);</span>
<span class=quote>&gt;          }</span>

Sort of, the the KVM ioctl seems to just pass a slot number and user
dirty bitmap pointer, so the size of the bitmap is inferred by the size
of the slot, but if both kernel and user round up to a multiple of
longs they might come up with different lengths.  QEMU therefore decides
to always round up the size for an LP64 based long.  Since you've
specified bitmap_size in our ioctl, the size agreement is explicit.

The concern I had looks like it addressed in KVM by placing the void*
__user pointer in a union with a u64:

struct kvm_dirty_log {
        __u32 slot;
        __u32 padding1;
        union {
                void __user *dirty_bitmap; /* one bit per page */
                __u64 padding2;
        };
};

The the kvm_vm_compat_ioctl() ioctl handles this with it's own private
structure:

truct compat_kvm_dirty_log {
        __u32 slot;
        __u32 padding1;
        union {
                compat_uptr_t dirty_bitmap; /* one bit per page */
                __u64 padding2;
        };
};

Which gets extracted via:

	log.dirty_bitmap = compat_ptr(compat_log.dirty_bitmap);

However, compat_ptr() has:

/*
 * A pointer passed in from user mode. This should not
 * be used for syscall parameters, just declare them
 * as pointers because the syscall entry code will have
 * appropriately converted them already.
 */
#ifndef compat_ptr
static inline void __user *compat_ptr(compat_uptr_t uptr)
{
        return (void __user *)(unsigned long)uptr;
}
#endif

So maybe we don't need to do anything special?  I'm tempted to think
the KVM handling is using legacy mechanism or the padding in the union
was assumed not to be for that purpose.  Thanks,

Alex
</pre>
</div>
<a name=23166273></a>
<div class=comment>
<div class=meta>
 <span><a href="https://patchwork.kernel.org/project/qemu-devel/list/?submitter=153211">Kirti Wankhede</a></span>
 <span class=pull-right>Feb. 19, 2020, 4:21 a.m. UTC | <a href=https://patchwork.kernel.org/comment/23166273/>#15</a></span>
</div>
<pre class=content>On 2/19/2020 3:11 AM, Alex Williamson wrote:
<span class=quote>&gt; On Tue, 18 Feb 2020 11:28:53 +0530</span>
<span class=quote>&gt; Kirti Wankhede &lt;kwankhede@nvidia.com&gt; wrote:</span>
<span class=quote>&gt; </span>
<span class=quote>&gt;&gt; &lt;snip&gt;</span>
<span class=quote>&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     As I understand the above algorithm, we find a vfio_dma</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt;&gt; overlapping the request and populate the bitmap for that range.  Then</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt;&gt; we go back and put_user() for each byte that we touched.  We could</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead simply work on a one byte buffer as we enumerate the requested</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt;&gt; range and do a put_user() ever time we reach the end of it and have bits</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt;&gt; set. That would greatly simplify the above example.  But I would expect</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt;&gt; that we're a) more likely to get asked for ranges covering a single</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt;&gt; vfio_dma</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; QEMU ask for single vfio_dma during each iteration.</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; If we restrict this ABI to cover single vfio_dma only, then it</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; simplifies the logic here. That was my original suggestion. Should we</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;&gt; think about that again?</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; But we currently allow unmaps that overlap multiple vfio_dmas as long</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; as no vfio_dma is bisected, so I think that implies that an unmap while</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; asking for the dirty bitmap has even further restricted semantics.  I'm</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; also reluctant to design an ABI around what happens to be the current</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; QEMU implementation.</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; If we take your example above, ranges {0x0000,0xa000} and</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; {0xa000,0x10000} ({start,end}), I think you're working with the</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; following two bitmaps in this implementation:</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; 00000011 11111111b</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; 00111111b</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; And we need to combine those into:</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; 11111111 11111111b</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; Right?</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; But it seems like that would be easier if the second bitmap was instead:</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; 11111100b</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; Then we wouldn't need to worry about the entire bitmap being shifted by</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; the bit offset within the byte, which limits our fixes to the boundary</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; byte and allows us to use copy_to_user() directly for the bulk of the</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; copy.  So how do we get there?</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; I think we start with allocating the vfio_dma bitmap to account for</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; this initial offset, so we calculate bitmap_base_iova as:</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;      (iova &amp; ~((PAGE_SIZE &lt;&lt; 3) - 1))</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; We then use bitmap_base_iova in calculating which bits to set.</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; The user needs to follow the same rules, and maybe this adds some value</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; to the user providing the bitmap size rather than the kernel</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; calculating it.  For example, if the user wanted the dirty bitmap for</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; the range {0xa000,0x10000} above, they'd provide at least a 1 byte</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; bitmap, but we'd return bit #2 set to indicate 0xa000 is dirty.</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; Effectively the user can ask for any iova range, but the buffer will be</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; filled relative to the zeroth bit of the bitmap following the above</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; bitmap_base_iova formula (and replacing PAGE_SIZE with the user</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; requested pgsize).  I'm tempted to make this explicit in the user</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; interface (ie. only allow bitmaps starting on aligned pages), but a</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; user is able to map and unmap single pages and we need to support</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt; returning a dirty bitmap with an unmap, so I don't think we can do that.</span>
<span class=quote>&gt;&gt;&gt;&gt;&gt;       </span>
<span class=quote>&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt;&gt; Sigh, finding adjacent vfio_dmas within the same byte seems simpler than</span>
<span class=quote>&gt;&gt;&gt;&gt; this.</span>
<span class=quote>&gt;&gt;&gt;</span>
<span class=quote>&gt;&gt;&gt; How does KVM do this?  My intent was that if all of our bitmaps share</span>
<span class=quote>&gt;&gt;&gt; the same alignment then we can merge the intersection and continue to</span>
<span class=quote>&gt;&gt;&gt; use copy_to_user() on either side.  However, if QEMU doesn't do the</span>
<span class=quote>&gt;&gt;&gt; same, it doesn't really help us.  Is QEMU stuck with an implementation</span>
<span class=quote>&gt;&gt;&gt; of only retrieving dirty bits per MemoryRegionSection exactly because</span>
<span class=quote>&gt;&gt;&gt; of this issue and therefore we can rely on it in our implementation as</span>
<span class=quote>&gt;&gt;&gt; well?  Thanks,</span>
<span class=quote>&gt;&gt;&gt;    </span>
<span class=quote>&gt;&gt;</span>
<span class=quote>&gt;&gt; QEMU sync dirty_bitmap per MemoryRegionSection. Within</span>
<span class=quote>&gt;&gt; MemoryRegionSection there could be multiple KVMSlots. QEMU queries</span>
<span class=quote>&gt;&gt; dirty_bitmap per KVMSlot and mark dirty for each KVMSlot.</span>
<span class=quote>&gt;&gt; On kernel side, KVM_GET_DIRTY_LOG ioctl calls</span>
<span class=quote>&gt;&gt; kvm_get_dirty_log_protect(), where it uses copy_to_user() to copy bitmap</span>
<span class=quote>&gt;&gt; of that memSlot.</span>
<span class=quote>&gt;&gt; vfio_dma is per MemoryRegionSection. We can reply on MemoryRegionSection</span>
<span class=quote>&gt;&gt; in our implementation. But to get bitmap during unmap, we have to take</span>
<span class=quote>&gt;&gt; care of concatenating bitmaps.</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; So KVM does not worry about bitmap alignment because the interface is</span>
<span class=quote>&gt; based on slots, a dirty bitmap can only be retrieved for a single,</span>
<span class=quote>&gt; entire slot.  We need VFIO_IOMMU_UNMAP_DMA to maintain its support for</span>
<span class=quote>&gt; spanning multiple vfio_dmas, but maybe we have some leeway that we</span>
<span class=quote>&gt; don't need to support both multiple vfio_dmas and dirty bitmap at the</span>
<span class=quote>&gt; same time.  It seems like it would be a massive simplification if we</span>
<span class=quote>&gt; required an unmap with dirty bitmap to span exactly one vfio_dma,</span>
<span class=quote>&gt; right? </span>

Yes.
<span class=quote>
&gt; I don't see that we'd break any existing users with that, it's</span>
<span class=quote>&gt; unfortunate that we can't have the flexibility of the existing calling</span>
<span class=quote>&gt; convention, but I think there's good reason for it here.  Our separate</span>
<span class=quote>&gt; dirty bitmap log reporting would follow the same semantics.  I think</span>
<span class=quote>&gt; this all aligns with how the MemoryListener works in QEMU right now,</span>
<span class=quote>&gt; correct?  For example we wouldn't need any extra per MAP_DMA tracking</span>
<span class=quote>&gt; in QEMU like KVM has for its slots.</span>
<span class=quote>&gt; </span>

That right.
Should we go ahead with the implementation to get dirty bitmap for one 
vfio_dma for GET_DIRTY ioctl and unmap with dirty ioctl? Accordingly we 
can have sanity checks in these ioctls.

Thanks,
Kirti
<span class=quote>
&gt;&gt; In QEMU, in function kvm_physical_sync_dirty_bitmap() there is a comment</span>
<span class=quote>&gt;&gt; where bitmap size is calculated and bitmap is defined as 'void __user</span>
<span class=quote>&gt;&gt; *dirty_bitmap' which is also the concern you raised and could be handled</span>
<span class=quote>&gt;&gt; similarly as below.</span>
<span class=quote>&gt;&gt;</span>
<span class=quote>&gt;&gt;           /* XXX bad kernel interface alert</span>
<span class=quote>&gt;&gt;            * For dirty bitmap, kernel allocates array of size aligned to</span>
<span class=quote>&gt;&gt;            * bits-per-long.  But for case when the kernel is 64bits and</span>
<span class=quote>&gt;&gt;            * the userspace is 32bits, userspace can't align to the same</span>
<span class=quote>&gt;&gt;            * bits-per-long, since sizeof(long) is different between kernel</span>
<span class=quote>&gt;&gt;            * and user space.  This way, userspace will provide buffer which</span>
<span class=quote>&gt;&gt;            * may be 4 bytes less than the kernel will use, resulting in</span>
<span class=quote>&gt;&gt;            * userspace memory corruption (which is not detectable by valgrind</span>
<span class=quote>&gt;&gt;            * too, in most cases).</span>
<span class=quote>&gt;&gt;            * So for now, let's align to 64 instead of HOST_LONG_BITS here, in</span>
<span class=quote>&gt;&gt;            * a hope that sizeof(long) won't become &gt;8 any time soon.</span>
<span class=quote>&gt;&gt;            */</span>
<span class=quote>&gt;&gt;           if (!mem-&gt;dirty_bmap) {</span>
<span class=quote>&gt;&gt;               hwaddr bitmap_size = ALIGN(((mem-&gt;memory_size) &gt;&gt;</span>
<span class=quote>&gt;&gt; TARGET_PAGE_BITS),</span>
<span class=quote>&gt;&gt;                                           /*HOST_LONG_BITS*/ 64) / 8;</span>
<span class=quote>&gt;&gt;               /* Allocate on the first log_sync, once and for all */</span>
<span class=quote>&gt;&gt;               mem-&gt;dirty_bmap = g_malloc0(bitmap_size);</span>
<span class=quote>&gt;&gt;           }</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; Sort of, the the KVM ioctl seems to just pass a slot number and user</span>
<span class=quote>&gt; dirty bitmap pointer, so the size of the bitmap is inferred by the size</span>
<span class=quote>&gt; of the slot, but if both kernel and user round up to a multiple of</span>
<span class=quote>&gt; longs they might come up with different lengths.  QEMU therefore decides</span>
<span class=quote>&gt; to always round up the size for an LP64 based long.  Since you've</span>
<span class=quote>&gt; specified bitmap_size in our ioctl, the size agreement is explicit.</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; The concern I had looks like it addressed in KVM by placing the void*</span>
<span class=quote>&gt; __user pointer in a union with a u64:</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; struct kvm_dirty_log {</span>
<span class=quote>&gt;          __u32 slot;</span>
<span class=quote>&gt;          __u32 padding1;</span>
<span class=quote>&gt;          union {</span>
<span class=quote>&gt;                  void __user *dirty_bitmap; /* one bit per page */</span>
<span class=quote>&gt;                  __u64 padding2;</span>
<span class=quote>&gt;          };</span>
<span class=quote>&gt; };</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; The the kvm_vm_compat_ioctl() ioctl handles this with it's own private</span>
<span class=quote>&gt; structure:</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; truct compat_kvm_dirty_log {</span>
<span class=quote>&gt;          __u32 slot;</span>
<span class=quote>&gt;          __u32 padding1;</span>
<span class=quote>&gt;          union {</span>
<span class=quote>&gt;                  compat_uptr_t dirty_bitmap; /* one bit per page */</span>
<span class=quote>&gt;                  __u64 padding2;</span>
<span class=quote>&gt;          };</span>
<span class=quote>&gt; };</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; Which gets extracted via:</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; 	log.dirty_bitmap = compat_ptr(compat_log.dirty_bitmap);</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; However, compat_ptr() has:</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; /*</span>
<span class=quote>&gt;   * A pointer passed in from user mode. This should not</span>
<span class=quote>&gt;   * be used for syscall parameters, just declare them</span>
<span class=quote>&gt;   * as pointers because the syscall entry code will have</span>
<span class=quote>&gt;   * appropriately converted them already.</span>
<span class=quote>&gt;   */</span>
<span class=quote>&gt; #ifndef compat_ptr</span>
<span class=quote>&gt; static inline void __user *compat_ptr(compat_uptr_t uptr)</span>
<span class=quote>&gt; {</span>
<span class=quote>&gt;          return (void __user *)(unsigned long)uptr;</span>
<span class=quote>&gt; }</span>
<span class=quote>&gt; #endif</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; So maybe we don't need to do anything special?  I'm tempted to think</span>
<span class=quote>&gt; the KVM handling is using legacy mechanism or the padding in the union</span>
<span class=quote>&gt; was assumed not to be for that purpose.  Thanks,</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; Alex</span>
<span class=quote>&gt;</span>
</pre>
</div>
<a name=23166305></a>
<div class=comment>
<div class=meta>
 <span><a href="https://patchwork.kernel.org/project/qemu-devel/list/?submitter=7781">Alex Williamson</a></span>
 <span class=pull-right>Feb. 19, 2020, 4:53 a.m. UTC | <a href=https://patchwork.kernel.org/comment/23166305/>#16</a></span>
</div>
<pre class=content>On Wed, 19 Feb 2020 09:51:32 +0530
Kirti Wankhede &lt;kwankhede@nvidia.com&gt; wrote:
<span class=quote>
&gt; On 2/19/2020 3:11 AM, Alex Williamson wrote:</span>
<span class=quote>&gt; &gt; On Tue, 18 Feb 2020 11:28:53 +0530</span>
<span class=quote>&gt; &gt; Kirti Wankhede &lt;kwankhede@nvidia.com&gt; wrote:</span>
<span class=quote>&gt; &gt;   </span>
<span class=quote>&gt; &gt;&gt; &lt;snip&gt;</span>
<span class=quote>&gt; &gt;&gt;  </span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;     As I understand the above algorithm, we find a vfio_dma</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; overlapping the request and populate the bitmap for that range.  Then</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; we go back and put_user() for each byte that we touched.  We could</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; instead simply work on a one byte buffer as we enumerate the requested</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; range and do a put_user() ever time we reach the end of it and have bits</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; set. That would greatly simplify the above example.  But I would expect</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; that we're a) more likely to get asked for ranges covering a single</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; vfio_dma  </span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; QEMU ask for single vfio_dma during each iteration.</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; If we restrict this ABI to cover single vfio_dma only, then it</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; simplifies the logic here. That was my original suggestion. Should we</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;&gt; think about that again?  </span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; But we currently allow unmaps that overlap multiple vfio_dmas as long</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; as no vfio_dma is bisected, so I think that implies that an unmap while</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; asking for the dirty bitmap has even further restricted semantics.  I'm</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; also reluctant to design an ABI around what happens to be the current</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; QEMU implementation.</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; If we take your example above, ranges {0x0000,0xa000} and</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; {0xa000,0x10000} ({start,end}), I think you're working with the</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; following two bitmaps in this implementation:</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; 00000011 11111111b</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; 00111111b</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; And we need to combine those into:</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; 11111111 11111111b</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; Right?</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; But it seems like that would be easier if the second bitmap was instead:</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; 11111100b</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; Then we wouldn't need to worry about the entire bitmap being shifted by</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; the bit offset within the byte, which limits our fixes to the boundary</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; byte and allows us to use copy_to_user() directly for the bulk of the</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; copy.  So how do we get there?</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; I think we start with allocating the vfio_dma bitmap to account for</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; this initial offset, so we calculate bitmap_base_iova as:</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;      (iova &amp; ~((PAGE_SIZE &lt;&lt; 3) - 1))</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; We then use bitmap_base_iova in calculating which bits to set.</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; The user needs to follow the same rules, and maybe this adds some value</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; to the user providing the bitmap size rather than the kernel</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; calculating it.  For example, if the user wanted the dirty bitmap for</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; the range {0xa000,0x10000} above, they'd provide at least a 1 byte</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; bitmap, but we'd return bit #2 set to indicate 0xa000 is dirty.</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; Effectively the user can ask for any iova range, but the buffer will be</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; filled relative to the zeroth bit of the bitmap following the above</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; bitmap_base_iova formula (and replacing PAGE_SIZE with the user</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; requested pgsize).  I'm tempted to make this explicit in the user</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; interface (ie. only allow bitmaps starting on aligned pages), but a</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; user is able to map and unmap single pages and we need to support</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt; returning a dirty bitmap with an unmap, so I don't think we can do that.</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;&gt;         </span>
<span class=quote>&gt; &gt;&gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; Sigh, finding adjacent vfio_dmas within the same byte seems simpler than</span>
<span class=quote>&gt; &gt;&gt;&gt;&gt; this.  </span>
<span class=quote>&gt; &gt;&gt;&gt;</span>
<span class=quote>&gt; &gt;&gt;&gt; How does KVM do this?  My intent was that if all of our bitmaps share</span>
<span class=quote>&gt; &gt;&gt;&gt; the same alignment then we can merge the intersection and continue to</span>
<span class=quote>&gt; &gt;&gt;&gt; use copy_to_user() on either side.  However, if QEMU doesn't do the</span>
<span class=quote>&gt; &gt;&gt;&gt; same, it doesn't really help us.  Is QEMU stuck with an implementation</span>
<span class=quote>&gt; &gt;&gt;&gt; of only retrieving dirty bits per MemoryRegionSection exactly because</span>
<span class=quote>&gt; &gt;&gt;&gt; of this issue and therefore we can rely on it in our implementation as</span>
<span class=quote>&gt; &gt;&gt;&gt; well?  Thanks,</span>
<span class=quote>&gt; &gt;&gt;&gt;      </span>
<span class=quote>&gt; &gt;&gt;</span>
<span class=quote>&gt; &gt;&gt; QEMU sync dirty_bitmap per MemoryRegionSection. Within</span>
<span class=quote>&gt; &gt;&gt; MemoryRegionSection there could be multiple KVMSlots. QEMU queries</span>
<span class=quote>&gt; &gt;&gt; dirty_bitmap per KVMSlot and mark dirty for each KVMSlot.</span>
<span class=quote>&gt; &gt;&gt; On kernel side, KVM_GET_DIRTY_LOG ioctl calls</span>
<span class=quote>&gt; &gt;&gt; kvm_get_dirty_log_protect(), where it uses copy_to_user() to copy bitmap</span>
<span class=quote>&gt; &gt;&gt; of that memSlot.</span>
<span class=quote>&gt; &gt;&gt; vfio_dma is per MemoryRegionSection. We can reply on MemoryRegionSection</span>
<span class=quote>&gt; &gt;&gt; in our implementation. But to get bitmap during unmap, we have to take</span>
<span class=quote>&gt; &gt;&gt; care of concatenating bitmaps.  </span>
<span class=quote>&gt; &gt; </span>
<span class=quote>&gt; &gt; So KVM does not worry about bitmap alignment because the interface is</span>
<span class=quote>&gt; &gt; based on slots, a dirty bitmap can only be retrieved for a single,</span>
<span class=quote>&gt; &gt; entire slot.  We need VFIO_IOMMU_UNMAP_DMA to maintain its support for</span>
<span class=quote>&gt; &gt; spanning multiple vfio_dmas, but maybe we have some leeway that we</span>
<span class=quote>&gt; &gt; don't need to support both multiple vfio_dmas and dirty bitmap at the</span>
<span class=quote>&gt; &gt; same time.  It seems like it would be a massive simplification if we</span>
<span class=quote>&gt; &gt; required an unmap with dirty bitmap to span exactly one vfio_dma,</span>
<span class=quote>&gt; &gt; right?   </span>
<span class=quote>&gt; </span>
<span class=quote>&gt; Yes.</span>
<span class=quote>&gt; </span>
<span class=quote>&gt; &gt; I don't see that we'd break any existing users with that, it's</span>
<span class=quote>&gt; &gt; unfortunate that we can't have the flexibility of the existing calling</span>
<span class=quote>&gt; &gt; convention, but I think there's good reason for it here.  Our separate</span>
<span class=quote>&gt; &gt; dirty bitmap log reporting would follow the same semantics.  I think</span>
<span class=quote>&gt; &gt; this all aligns with how the MemoryListener works in QEMU right now,</span>
<span class=quote>&gt; &gt; correct?  For example we wouldn't need any extra per MAP_DMA tracking</span>
<span class=quote>&gt; &gt; in QEMU like KVM has for its slots.</span>
<span class=quote>&gt; &gt;   </span>
<span class=quote>&gt; </span>
<span class=quote>&gt; That right.</span>
<span class=quote>&gt; Should we go ahead with the implementation to get dirty bitmap for one </span>
<span class=quote>&gt; vfio_dma for GET_DIRTY ioctl and unmap with dirty ioctl? Accordingly we </span>
<span class=quote>&gt; can have sanity checks in these ioctls.</span>

Yes, I'm convinced that bitmap alignment is sufficiently too difficult
and unnecessary to restrict the calling convention of UNMAP_DMA, when
using the dirty bitmap extension, to exactly unmap a single vfio_dma.
Thanks,

Alex
</pre>
</div>
<div>
 <div class="btn-group pull-right">
 <button type=button class="btn btn-default btn-copy" data-clipboard-text=11371205 title="Copy to Clipboard">
 11371205
 </button>
 
 <a href=https://patchwork.kernel.org/project/qemu-devel/patch/1581104554-10704-5-git-send-email-kwankhede@nvidia.com/raw/ class="btn btn-default" role=button title="Download patch diff">diff</a>
 <a href=https://patchwork.kernel.org/project/qemu-devel/patch/1581104554-10704-5-git-send-email-kwankhede@nvidia.com/mbox/ class="btn btn-default" role=button title="Download patch mbox">mbox</a>
 
 
 <a href=https://patchwork.kernel.org/series/238547/mbox/ class="btn btn-default" role=button title="Download patch mbox with dependencies">series</a>
 
</div>
 <h2>Patch</h2>
</div>
<div id=patch class=patch>
<pre class=content><span class=p_header>diff --git a/drivers/vfio/vfio_iommu_type1.c b/drivers/vfio/vfio_iommu_type1.c</span>
<span class=p_header>index d386461e5d11..df358dc1c85b 100644</span>
<span class=p_header>--- a/drivers/vfio/vfio_iommu_type1.c</span>
<span class=p_header>+++ b/drivers/vfio/vfio_iommu_type1.c</span>
<span class=p_chunk>@@ -70,6 +70,7 @@</span> <span class=p_context> struct vfio_iommu {</span>
 	unsigned int		dma_avail;
 	bool			v2;
 	bool			nesting;
<span class=p_add>+	bool			dirty_page_tracking;</span>
 };
 
 struct vfio_domain {
<span class=p_chunk>@@ -90,6 +91,7 @@</span> <span class=p_context> struct vfio_dma {</span>
 	bool			lock_cap;	/* capable(CAP_IPC_LOCK) */
 	struct task_struct	*task;
 	struct rb_root		pfn_list;	/* Ex-user pinned pfn list */
<span class=p_add>+	unsigned long		*bitmap;</span>
 };
 
 struct vfio_group {
<span class=p_chunk>@@ -125,6 +127,7 @@</span> <span class=p_context> struct vfio_regions {</span>
 					(!list_empty(&amp;iommu-&gt;domain_list))
 
 static int put_pfn(unsigned long pfn, int prot);
<span class=p_add>+static unsigned long vfio_pgsize_bitmap(struct vfio_iommu *iommu);</span>
 
 /*
  * This code handles mapping and unmapping of user data buffers
<span class=p_chunk>@@ -174,6 +177,57 @@</span> <span class=p_context> static void vfio_unlink_dma(struct vfio_iommu *iommu, struct vfio_dma *old)</span>
 	rb_erase(&amp;old-&gt;node, &amp;iommu-&gt;dma_list);
 }
 
<span class=p_add>+static inline unsigned long dirty_bitmap_bytes(unsigned int npages)</span>
<span class=p_add>+{</span>
<span class=p_add>+	if (!npages)</span>
<span class=p_add>+		return 0;</span>
<span class=p_add>+</span>
<span class=p_add>+	return ALIGN(npages, BITS_PER_LONG) / sizeof(unsigned long);</span>
<span class=p_add>+}</span>
<span class=p_add>+</span>
<span class=p_add>+static int vfio_dma_bitmap_alloc(struct vfio_iommu *iommu,</span>
<span class=p_add>+				 struct vfio_dma *dma, unsigned long pgsizes)</span>
<span class=p_add>+{</span>
<span class=p_add>+	unsigned long pgshift = __ffs(pgsizes);</span>
<span class=p_add>+</span>
<span class=p_add>+	if (!RB_EMPTY_ROOT(&amp;dma-&gt;pfn_list) || dma-&gt;iommu_mapped) {</span>
<span class=p_add>+		unsigned long npages = dma-&gt;size &gt;&gt; pgshift;</span>
<span class=p_add>+		unsigned long bsize = dirty_bitmap_bytes(npages);</span>
<span class=p_add>+</span>
<span class=p_add>+		dma-&gt;bitmap = kvzalloc(bsize, GFP_KERNEL);</span>
<span class=p_add>+		if (!dma-&gt;bitmap)</span>
<span class=p_add>+			return -ENOMEM;</span>
<span class=p_add>+	}</span>
<span class=p_add>+	return 0;</span>
<span class=p_add>+}</span>
<span class=p_add>+</span>
<span class=p_add>+static int vfio_dma_all_bitmap_alloc(struct vfio_iommu *iommu,</span>
<span class=p_add>+				     unsigned long pgsizes)</span>
<span class=p_add>+{</span>
<span class=p_add>+	struct rb_node *n = rb_first(&amp;iommu-&gt;dma_list);</span>
<span class=p_add>+	int ret;</span>
<span class=p_add>+</span>
<span class=p_add>+	for (; n; n = rb_next(n)) {</span>
<span class=p_add>+		struct vfio_dma *dma = rb_entry(n, struct vfio_dma, node);</span>
<span class=p_add>+</span>
<span class=p_add>+		ret = vfio_dma_bitmap_alloc(iommu, dma, pgsizes);</span>
<span class=p_add>+		if (ret)</span>
<span class=p_add>+			return ret;</span>
<span class=p_add>+	}</span>
<span class=p_add>+	return 0;</span>
<span class=p_add>+}</span>
<span class=p_add>+</span>
<span class=p_add>+static void vfio_dma_all_bitmap_free(struct vfio_iommu *iommu)</span>
<span class=p_add>+{</span>
<span class=p_add>+	struct rb_node *n = rb_first(&amp;iommu-&gt;dma_list);</span>
<span class=p_add>+</span>
<span class=p_add>+	for (; n; n = rb_next(n)) {</span>
<span class=p_add>+		struct vfio_dma *dma = rb_entry(n, struct vfio_dma, node);</span>
<span class=p_add>+</span>
<span class=p_add>+		kfree(dma-&gt;bitmap);</span>
<span class=p_add>+	}</span>
<span class=p_add>+}</span>
<span class=p_add>+</span>
 /*
  * Helper Functions for host iova-pfn list
  */
<span class=p_chunk>@@ -244,6 +298,29 @@</span> <span class=p_context> static void vfio_remove_from_pfn_list(struct vfio_dma *dma,</span>
 	kfree(vpfn);
 }
 
<span class=p_add>+static void vfio_remove_unpinned_from_pfn_list(struct vfio_dma *dma)</span>
<span class=p_add>+{</span>
<span class=p_add>+	struct rb_node *n = rb_first(&amp;dma-&gt;pfn_list);</span>
<span class=p_add>+</span>
<span class=p_add>+	for (; n; n = rb_next(n)) {</span>
<span class=p_add>+		struct vfio_pfn *vpfn = rb_entry(n, struct vfio_pfn, node);</span>
<span class=p_add>+</span>
<span class=p_add>+		if (!vpfn-&gt;ref_count)</span>
<span class=p_add>+			vfio_remove_from_pfn_list(dma, vpfn);</span>
<span class=p_add>+	}</span>
<span class=p_add>+}</span>
<span class=p_add>+</span>
<span class=p_add>+static void vfio_remove_unpinned_from_dma_list(struct vfio_iommu *iommu)</span>
<span class=p_add>+{</span>
<span class=p_add>+	struct rb_node *n = rb_first(&amp;iommu-&gt;dma_list);</span>
<span class=p_add>+</span>
<span class=p_add>+	for (; n; n = rb_next(n)) {</span>
<span class=p_add>+		struct vfio_dma *dma = rb_entry(n, struct vfio_dma, node);</span>
<span class=p_add>+</span>
<span class=p_add>+		vfio_remove_unpinned_from_pfn_list(dma);</span>
<span class=p_add>+	}</span>
<span class=p_add>+}</span>
<span class=p_add>+</span>
 static struct vfio_pfn *vfio_iova_get_vfio_pfn(struct vfio_dma *dma,
 					       unsigned long iova)
 {
<span class=p_chunk>@@ -261,7 +338,8 @@</span> <span class=p_context> static int vfio_iova_put_vfio_pfn(struct vfio_dma *dma, struct vfio_pfn *vpfn)</span>
 	vpfn-&gt;ref_count--;
 	if (!vpfn-&gt;ref_count) {
 		ret = put_pfn(vpfn-&gt;pfn, dma-&gt;prot);
<span class=p_del>-		vfio_remove_from_pfn_list(dma, vpfn);</span>
<span class=p_add>+		if (!dma-&gt;bitmap)</span>
<span class=p_add>+			vfio_remove_from_pfn_list(dma, vpfn);</span>
 	}
 	return ret;
 }
<span class=p_chunk>@@ -483,13 +561,14 @@</span> <span class=p_context> static int vfio_pin_page_external(struct vfio_dma *dma, unsigned long vaddr,</span>
 	return ret;
 }
 
<span class=p_del>-static int vfio_unpin_page_external(struct vfio_dma *dma, dma_addr_t iova,</span>
<span class=p_add>+static int vfio_unpin_page_external(struct vfio_iommu *iommu,</span>
<span class=p_add>+				    struct vfio_dma *dma, dma_addr_t iova,</span>
 				    bool do_accounting)
 {
 	int unlocked;
 	struct vfio_pfn *vpfn = vfio_find_vpfn(dma, iova);
 
<span class=p_del>-	if (!vpfn)</span>
<span class=p_add>+	if (!vpfn || !vpfn-&gt;ref_count)</span>
 		return 0;
 
 	unlocked = vfio_iova_put_vfio_pfn(dma, vpfn);
<span class=p_chunk>@@ -510,6 +589,7 @@</span> <span class=p_context> static int vfio_iommu_type1_pin_pages(void *iommu_data,</span>
 	unsigned long remote_vaddr;
 	struct vfio_dma *dma;
 	bool do_accounting;
<span class=p_add>+	unsigned long iommu_pgsizes = vfio_pgsize_bitmap(iommu);</span>
 
 	if (!iommu || !user_pfn || !phys_pfn)
 		return -EINVAL;
<span class=p_chunk>@@ -551,8 +631,10 @@</span> <span class=p_context> static int vfio_iommu_type1_pin_pages(void *iommu_data,</span>
 
 		vpfn = vfio_iova_get_vfio_pfn(dma, iova);
 		if (vpfn) {
<span class=p_del>-			phys_pfn[i] = vpfn-&gt;pfn;</span>
<span class=p_del>-			continue;</span>
<span class=p_add>+			if (vpfn-&gt;ref_count &gt; 1) {</span>
<span class=p_add>+				phys_pfn[i] = vpfn-&gt;pfn;</span>
<span class=p_add>+				continue;</span>
<span class=p_add>+			}</span>
 		}
 
 		remote_vaddr = dma-&gt;vaddr + iova - dma-&gt;iova;
<span class=p_chunk>@@ -560,11 +642,23 @@</span> <span class=p_context> static int vfio_iommu_type1_pin_pages(void *iommu_data,</span>
 					     do_accounting);
 		if (ret)
 			goto pin_unwind;
<span class=p_del>-</span>
<span class=p_del>-		ret = vfio_add_to_pfn_list(dma, iova, phys_pfn[i]);</span>
<span class=p_del>-		if (ret) {</span>
<span class=p_del>-			vfio_unpin_page_external(dma, iova, do_accounting);</span>
<span class=p_del>-			goto pin_unwind;</span>
<span class=p_add>+		if (!vpfn) {</span>
<span class=p_add>+			ret = vfio_add_to_pfn_list(dma, iova, phys_pfn[i]);</span>
<span class=p_add>+			if (ret) {</span>
<span class=p_add>+				vfio_unpin_page_external(iommu, dma, iova,</span>
<span class=p_add>+							 do_accounting);</span>
<span class=p_add>+				goto pin_unwind;</span>
<span class=p_add>+			}</span>
<span class=p_add>+		} else</span>
<span class=p_add>+			vpfn-&gt;pfn = phys_pfn[i];</span>
<span class=p_add>+</span>
<span class=p_add>+		if (iommu-&gt;dirty_page_tracking &amp;&amp; !dma-&gt;bitmap) {</span>
<span class=p_add>+			ret = vfio_dma_bitmap_alloc(iommu, dma, iommu_pgsizes);</span>
<span class=p_add>+			if (ret) {</span>
<span class=p_add>+				vfio_unpin_page_external(iommu, dma, iova,</span>
<span class=p_add>+							 do_accounting);</span>
<span class=p_add>+				goto pin_unwind;</span>
<span class=p_add>+			}</span>
 		}
 	}
 
<span class=p_chunk>@@ -578,7 +672,7 @@</span> <span class=p_context> static int vfio_iommu_type1_pin_pages(void *iommu_data,</span>
 
 		iova = user_pfn[j] &lt;&lt; PAGE_SHIFT;
 		dma = vfio_find_dma(iommu, iova, PAGE_SIZE);
<span class=p_del>-		vfio_unpin_page_external(dma, iova, do_accounting);</span>
<span class=p_add>+		vfio_unpin_page_external(iommu, dma, iova, do_accounting);</span>
 		phys_pfn[j] = 0;
 	}
 pin_done:
<span class=p_chunk>@@ -612,7 +706,7 @@</span> <span class=p_context> static int vfio_iommu_type1_unpin_pages(void *iommu_data,</span>
 		dma = vfio_find_dma(iommu, iova, PAGE_SIZE);
 		if (!dma)
 			goto unpin_exit;
<span class=p_del>-		vfio_unpin_page_external(dma, iova, do_accounting);</span>
<span class=p_add>+		vfio_unpin_page_external(iommu, dma, iova, do_accounting);</span>
 	}
 
 unpin_exit:
<span class=p_chunk>@@ -830,6 +924,113 @@</span> <span class=p_context> static unsigned long vfio_pgsize_bitmap(struct vfio_iommu *iommu)</span>
 	return bitmap;
 }
 
<span class=p_add>+static int vfio_iova_dirty_bitmap(struct vfio_iommu *iommu, dma_addr_t iova,</span>
<span class=p_add>+				  size_t size, uint64_t pgsize,</span>
<span class=p_add>+				  unsigned char __user *bitmap)</span>
<span class=p_add>+{</span>
<span class=p_add>+	struct vfio_dma *dma;</span>
<span class=p_add>+	dma_addr_t i = iova, iova_limit;</span>
<span class=p_add>+	unsigned int bsize, nbits = 0, l = 0;</span>
<span class=p_add>+	unsigned long pgshift = __ffs(pgsize);</span>
<span class=p_add>+</span>
<span class=p_add>+	while ((dma = vfio_find_dma(iommu, i, pgsize))) {</span>
<span class=p_add>+		int ret, j;</span>
<span class=p_add>+		unsigned int npages = 0, shift = 0;</span>
<span class=p_add>+		unsigned char temp = 0;</span>
<span class=p_add>+</span>
<span class=p_add>+		/* mark all pages dirty if all pages are pinned and mapped. */</span>
<span class=p_add>+		if (dma-&gt;iommu_mapped) {</span>
<span class=p_add>+			iova_limit = min(dma-&gt;iova + dma-&gt;size, iova + size);</span>
<span class=p_add>+			npages = iova_limit/pgsize;</span>
<span class=p_add>+			bitmap_set(dma-&gt;bitmap, 0, npages);</span>
<span class=p_add>+		} else if (dma-&gt;bitmap) {</span>
<span class=p_add>+			struct rb_node *n = rb_first(&amp;dma-&gt;pfn_list);</span>
<span class=p_add>+			bool found = false;</span>
<span class=p_add>+</span>
<span class=p_add>+			for (; n; n = rb_next(n)) {</span>
<span class=p_add>+				struct vfio_pfn *vpfn = rb_entry(n,</span>
<span class=p_add>+						struct vfio_pfn, node);</span>
<span class=p_add>+				if (vpfn-&gt;iova &gt;= i) {</span>
<span class=p_add>+					found = true;</span>
<span class=p_add>+					break;</span>
<span class=p_add>+				}</span>
<span class=p_add>+			}</span>
<span class=p_add>+</span>
<span class=p_add>+			if (!found) {</span>
<span class=p_add>+				i += dma-&gt;size;</span>
<span class=p_add>+				continue;</span>
<span class=p_add>+			}</span>
<span class=p_add>+</span>
<span class=p_add>+			for (; n; n = rb_next(n)) {</span>
<span class=p_add>+				unsigned int s;</span>
<span class=p_add>+				struct vfio_pfn *vpfn = rb_entry(n,</span>
<span class=p_add>+						struct vfio_pfn, node);</span>
<span class=p_add>+</span>
<span class=p_add>+				if (vpfn-&gt;iova &gt;= iova + size)</span>
<span class=p_add>+					break;</span>
<span class=p_add>+</span>
<span class=p_add>+				s = (vpfn-&gt;iova - dma-&gt;iova) &gt;&gt; pgshift;</span>
<span class=p_add>+				bitmap_set(dma-&gt;bitmap, s, 1);</span>
<span class=p_add>+</span>
<span class=p_add>+				iova_limit = vpfn-&gt;iova + pgsize;</span>
<span class=p_add>+			}</span>
<span class=p_add>+			npages = iova_limit/pgsize;</span>
<span class=p_add>+		}</span>
<span class=p_add>+</span>
<span class=p_add>+		bsize = dirty_bitmap_bytes(npages);</span>
<span class=p_add>+		shift = nbits % BITS_PER_BYTE;</span>
<span class=p_add>+</span>
<span class=p_add>+		if (npages &amp;&amp; shift) {</span>
<span class=p_add>+			l--;</span>
<span class=p_add>+			if (!access_ok((void __user *)bitmap + l,</span>
<span class=p_add>+					sizeof(unsigned char)))</span>
<span class=p_add>+				return -EINVAL;</span>
<span class=p_add>+</span>
<span class=p_add>+			ret = __get_user(temp, bitmap + l);</span>
<span class=p_add>+			if (ret)</span>
<span class=p_add>+				return ret;</span>
<span class=p_add>+		}</span>
<span class=p_add>+</span>
<span class=p_add>+		for (j = 0; j &lt; bsize; j++, l++) {</span>
<span class=p_add>+			temp = temp |</span>
<span class=p_add>+			       (*((unsigned char *)dma-&gt;bitmap + j) &lt;&lt; shift);</span>
<span class=p_add>+			if (!access_ok((void __user *)bitmap + l,</span>
<span class=p_add>+					sizeof(unsigned char)))</span>
<span class=p_add>+				return -EINVAL;</span>
<span class=p_add>+</span>
<span class=p_add>+			ret = __put_user(temp, bitmap + l);</span>
<span class=p_add>+			if (ret)</span>
<span class=p_add>+				return ret;</span>
<span class=p_add>+			if (shift) {</span>
<span class=p_add>+				temp = *((unsigned char *)dma-&gt;bitmap + j) &gt;&gt;</span>
<span class=p_add>+					(BITS_PER_BYTE - shift);</span>
<span class=p_add>+			}</span>
<span class=p_add>+		}</span>
<span class=p_add>+</span>
<span class=p_add>+		nbits += npages;</span>
<span class=p_add>+</span>
<span class=p_add>+		i = min(dma-&gt;iova + dma-&gt;size, iova + size);</span>
<span class=p_add>+		if (i &gt;= iova + size)</span>
<span class=p_add>+			break;</span>
<span class=p_add>+	}</span>
<span class=p_add>+	return 0;</span>
<span class=p_add>+}</span>
<span class=p_add>+</span>
<span class=p_add>+static long verify_bitmap_size(unsigned long npages, unsigned long bitmap_size)</span>
<span class=p_add>+{</span>
<span class=p_add>+	long bsize;</span>
<span class=p_add>+</span>
<span class=p_add>+	if (!bitmap_size || bitmap_size &gt; SIZE_MAX)</span>
<span class=p_add>+		return -EINVAL;</span>
<span class=p_add>+</span>
<span class=p_add>+	bsize = dirty_bitmap_bytes(npages);</span>
<span class=p_add>+</span>
<span class=p_add>+	if (bitmap_size &lt; bsize)</span>
<span class=p_add>+		return -EINVAL;</span>
<span class=p_add>+</span>
<span class=p_add>+	return bsize;</span>
<span class=p_add>+}</span>
<span class=p_add>+</span>
 static int vfio_dma_do_unmap(struct vfio_iommu *iommu,
 			     struct vfio_iommu_type1_dma_unmap *unmap)
 {
<span class=p_chunk>@@ -2277,6 +2478,80 @@</span> <span class=p_context> static long vfio_iommu_type1_ioctl(void *iommu_data,</span>
 
 		return copy_to_user((void __user *)arg, &amp;unmap, minsz) ?
 			-EFAULT : 0;
<span class=p_add>+	} else if (cmd == VFIO_IOMMU_DIRTY_PAGES) {</span>
<span class=p_add>+		struct vfio_iommu_type1_dirty_bitmap range;</span>
<span class=p_add>+		uint32_t mask = VFIO_IOMMU_DIRTY_PAGES_FLAG_START |</span>
<span class=p_add>+				VFIO_IOMMU_DIRTY_PAGES_FLAG_STOP |</span>
<span class=p_add>+				VFIO_IOMMU_DIRTY_PAGES_FLAG_GET_BITMAP;</span>
<span class=p_add>+		int ret;</span>
<span class=p_add>+</span>
<span class=p_add>+		if (!iommu-&gt;v2)</span>
<span class=p_add>+			return -EACCES;</span>
<span class=p_add>+</span>
<span class=p_add>+		minsz = offsetofend(struct vfio_iommu_type1_dirty_bitmap,</span>
<span class=p_add>+				    bitmap);</span>
<span class=p_add>+</span>
<span class=p_add>+		if (copy_from_user(&amp;range, (void __user *)arg, minsz))</span>
<span class=p_add>+			return -EFAULT;</span>
<span class=p_add>+</span>
<span class=p_add>+		if (range.argsz &lt; minsz || range.flags &amp; ~mask)</span>
<span class=p_add>+			return -EINVAL;</span>
<span class=p_add>+</span>
<span class=p_add>+		/* only one flag should be set at a time */</span>
<span class=p_add>+		if (__ffs(range.flags) != __fls(range.flags))</span>
<span class=p_add>+			return -EINVAL;</span>
<span class=p_add>+</span>
<span class=p_add>+		if (range.flags &amp; VFIO_IOMMU_DIRTY_PAGES_FLAG_START) {</span>
<span class=p_add>+			unsigned long iommu_pgsizes = vfio_pgsize_bitmap(iommu);</span>
<span class=p_add>+</span>
<span class=p_add>+			mutex_lock(&amp;iommu-&gt;lock);</span>
<span class=p_add>+			iommu-&gt;dirty_page_tracking = true;</span>
<span class=p_add>+			ret = vfio_dma_all_bitmap_alloc(iommu, iommu_pgsizes);</span>
<span class=p_add>+			mutex_unlock(&amp;iommu-&gt;lock);</span>
<span class=p_add>+			return ret;</span>
<span class=p_add>+		} else if (range.flags &amp; VFIO_IOMMU_DIRTY_PAGES_FLAG_STOP) {</span>
<span class=p_add>+			mutex_lock(&amp;iommu-&gt;lock);</span>
<span class=p_add>+			iommu-&gt;dirty_page_tracking = false;</span>
<span class=p_add>+			vfio_dma_all_bitmap_free(iommu);</span>
<span class=p_add>+			vfio_remove_unpinned_from_dma_list(iommu);</span>
<span class=p_add>+			mutex_unlock(&amp;iommu-&gt;lock);</span>
<span class=p_add>+			return 0;</span>
<span class=p_add>+		} else if (range.flags &amp;</span>
<span class=p_add>+				 VFIO_IOMMU_DIRTY_PAGES_FLAG_GET_BITMAP) {</span>
<span class=p_add>+			long bsize;</span>
<span class=p_add>+			unsigned long pgshift = __ffs(range.pgsize);</span>
<span class=p_add>+			uint64_t iommu_pgsizes = vfio_pgsize_bitmap(iommu);</span>
<span class=p_add>+			uint64_t iommu_pgmask =</span>
<span class=p_add>+				 ((uint64_t)1 &lt;&lt; __ffs(iommu_pgsizes)) - 1;</span>
<span class=p_add>+</span>
<span class=p_add>+			if ((range.pgsize &amp; iommu_pgsizes) != range.pgsize)</span>
<span class=p_add>+				return -EINVAL;</span>
<span class=p_add>+			if (range.iova &amp; iommu_pgmask)</span>
<span class=p_add>+				return -EINVAL;</span>
<span class=p_add>+			if (!range.size || range.size &amp; iommu_pgmask)</span>
<span class=p_add>+				return -EINVAL;</span>
<span class=p_add>+			if (range.iova + range.size &lt; range.iova)</span>
<span class=p_add>+				return -EINVAL;</span>
<span class=p_add>+			if (!access_ok((void __user *)range.bitmap,</span>
<span class=p_add>+				       range.bitmap_size))</span>
<span class=p_add>+				return -EINVAL;</span>
<span class=p_add>+</span>
<span class=p_add>+			bsize = verify_bitmap_size(range.size &gt;&gt; pgshift,</span>
<span class=p_add>+						   range.bitmap_size);</span>
<span class=p_add>+			if (bsize &lt; 0)</span>
<span class=p_add>+				return bsize;</span>
<span class=p_add>+</span>
<span class=p_add>+			mutex_lock(&amp;iommu-&gt;lock);</span>
<span class=p_add>+			if (iommu-&gt;dirty_page_tracking)</span>
<span class=p_add>+				ret = vfio_iova_dirty_bitmap(iommu, range.iova,</span>
<span class=p_add>+					 range.size, range.pgsize,</span>
<span class=p_add>+					 (unsigned char __user *)range.bitmap);</span>
<span class=p_add>+			else</span>
<span class=p_add>+				ret = -EINVAL;</span>
<span class=p_add>+			mutex_unlock(&amp;iommu-&gt;lock);</span>
<span class=p_add>+</span>
<span class=p_add>+			return ret;</span>
<span class=p_add>+		}</span>
 	}
 
 	return -ENOTTY;

</pre>
</div>
 </div>
 <div id=footer>
 <a href=http://jk.ozlabs.org/projects/patchwork/>patchwork</a>
 patch tracking system | version v2.2.6 | <a href=https://patchwork.kernel.org/about/>about patchwork</a>
 </div>
 
<div style=all:initial><div style=all:initial id=__hcfy__><template shadowrootmode=open><style class=sf-hidden>#root{-webkit-text-size-adjust:100%;box-sizing:border-box;font-size:14px;font-weight:400;letter-spacing:0;line-height:1.28581;text-transform:none;color:#182026;font-family:-apple-system,"BlinkMacSystemFont","Segoe UI","Roboto","Oxygen","Ubuntu","Cantarell","Open Sans","Helvetica Neue","Icons16",sans-serif;touch-action:manipulation}#root>.bp5-portal{z-index:9999999999}</style><style class=sf-hidden>#translate-panel{background-color:#f6f7f9;display:flex;flex-direction:column;padding-bottom:8px}.bp5-dark #translate-panel{background-color:#252a31}#translate-panel .fixed{flex-shrink:0;margin-bottom:10px}#translate-panel .body{flex-grow:1;overflow:auto;overscroll-behavior:contain}#translate-panel .body::-webkit-scrollbar{width:8px;background-color:rgba(0,0,0,0);-webkit-border-radius:100px}#translate-panel .body::-webkit-scrollbar:hover{background-color:rgba(0,0,0,.09)}#translate-panel .body::-webkit-scrollbar-thumb:vertical{background:rgba(0,0,0,.5);-webkit-border-radius:100px}#translate-panel .body::-webkit-scrollbar-thumb:vertical:active{background:rgba(0,0,0,.61);-webkit-border-radius:100px}#translate-panel.size-small,#translate-panel.size-small h6.bp5-heading,#translate-panel.size-small .bp5-control.bp5-large,#translate-panel.size-small textarea.bp5-input.bp5-small{font-size:14px}#translate-panel.size-small .phonetic-item,#translate-panel.size-small .quick-settings a{font-size:12px}#translate-panel.size-middle,#translate-panel.size-middle h6.bp5-heading,#translate-panel.size-middle .bp5-control.bp5-large,#translate-panel.size-middle textarea.bp5-input{font-size:18px}#translate-panel.size-middle .phonetic-item,#translate-panel.size-middle .quick-settings a{font-size:14px}#translate-panel.size-large,#translate-panel.size-large h6.bp5-heading,#translate-panel.size-large .bp5-control.bp5-large,#translate-panel.size-large textarea.bp5-input.bp5-large{font-size:22px}#translate-panel.size-large .source,#translate-panel.size-large .phonetic-item,#translate-panel.size-large .quick-settings a{font-size:18px}#translate-panel .bp5-button.bp5-small,#translate-panel .bp5-small .bp5-button{min-height:20px;min-width:20px}#translate-panel .header{display:flex;align-items:center;padding:4px 6px 4px 10px;border-bottom:1px solid #d1d1d1}.bp5-dark #translate-panel .header{border-bottom-color:rgba(17,20,24,.4)}#translate-panel .header .drag-block{min-width:5px;flex-shrink:0;flex-grow:1;align-self:stretch}#translate-panel .header .left{flex-shrink:0;display:flex}#translate-panel .header .right{flex-shrink:0;display:flex;align-items:center}#translate-panel .header .right .bp5-icon-arrow-right{flex-shrink:0;margin:0 5px}#translate-panel .header .right>.bp5-button{flex-shrink:0;margin:0 1px}#translate-panel .header .right>.bp5-button:last-child{margin-right:0}#translate-panel .quick-settings{padding:4px 9px;margin:0 1px}#translate-panel .quick-settings>div{margin-bottom:5px}#translate-panel .quick-settings .bp5-control{margin-bottom:0}#translate-panel .query-text{position:relative;padding:10px 10px 2px 10px}#translate-panel .query-text textarea.bp5-input{min-height:44px;font-family:system-ui,-apple-system,"Segoe UI","Roboto","Ubuntu","Cantarell","Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";overscroll-behavior:contain}#translate-panel .query-text .translate-btn{position:absolute;opacity:.6}#translate-panel .query-text .translate-btn:hover{opacity:1}#translate-panel .body{padding:0 10px}#translate-panel .body .bp5-card:first-child{margin-top:1px}#translate-panel .body .bp5-card:last-child{margin-bottom:1px}#translate-panel .body .no-api{margin:20px 0}.result-block{margin:8px 0;padding:2px 5px}.result-block .bp5-button{visibility:hidden}.result-block .error .bp5-button,.result-block:hover .bp5-button{visibility:visible}.result-block .legend{display:flex;align-items:center;justify-content:space-between}.result-block .legend .legend-left{display:flex;align-items:center}.result-block .legend .api-ico,.result-block .legend .bp5-heading{flex-shrink:0;white-space:nowrap}.result-block .legend .api-ico{display:inline-block;width:14px;height:14px;background-size:contain;margin-right:3px}.result-block .legend .bp5-heading{margin-bottom:0;margin-right:10px}.result-block .legend .source{cursor:pointer;font-size:12px;display:inline-flex;align-items:center}.result-block .legend .source .source-text{overflow:hidden}.result-block .legend .source .bp5-icon{position:relative;top:-1px;margin-left:1px}.result-block .phonetic{display:flex;flex-wrap:wrap}.result-block .phonetic .phonetic-item{display:flex;align-items:center;font-size:12px}.result-block .phonetic .phonetic-item:not(:last-child){margin-right:12px}.result-block .common-result p{line-height:1.3;margin:2px 0;overflow-wrap:break-word}.result-block .common-result .dict a{text-decoration:underline}.result-block .error{font-size:12px;padding:5px 10px}.result-block .dict-pos{margin-right:5px}.external-translators{margin-bottom:3px;padding:0;display:flex;flex-wrap:wrap}.external-translators>div{margin:0 5px 5px 0}.quick-links a{margin:0 5px 5px 0}#popper-container{width:250px;max-width:100%;position:absolute;left:0;top:0;z-index:9999999998;touch-action:none;transition:opacity .2s;background-color:#f6f7f9}.bp5-dark #popper-container{background-color:#252a31}#popper-container.show{opacity:1;pointer-events:auto;-moz-user-select:auto;user-select:auto}#popper-container,#popper-container[data-popper-reference-hidden=true]{opacity:0;pointer-events:none;-moz-user-select:none;user-select:none}#popper-container .drag-block{cursor:-webkit-grab;cursor:grab}#popper-container.pin{position:fixed}#popper-container.pin .arrow{display:none}#popper-container .arrow,#popper-container .arrow::before{position:absolute;width:8px;height:8px;z-index:-1}#popper-container .arrow::before{content:"";transform:rotate(45deg);background:#f6f7f9}.bp5-dark #popper-container .arrow::before{background-color:#252a31}#popper-container .arrow{display:none}#popper-container.show[data-popper-placement]:not([data-popper-reference-hidden=true]) .arrow{display:block}#popper-container[data-popper-placement^=top] .arrow{bottom:-5px}#popper-container[data-popper-placement^=top] .arrow::before{border-right:1px solid #d1d1d1;border-bottom:1px solid #d1d1d1}#popper-container[data-popper-placement^=bottom] .arrow{top:-5px}#popper-container[data-popper-placement^=bottom] .arrow::before{border-left:1px solid #d1d1d1;border-top:1px solid #d1d1d1}#popper-container[data-popper-placement^=left] .arrow{right:-5px}#popper-container[data-popper-placement^=left] .arrow::before{border-right:1px solid #d1d1d1;border-top:1px solid #d1d1d1}#popper-container[data-popper-placement^=right] .arrow{left:-5px}#popper-container[data-popper-placement^=right] .arrow::before{border-left:1px solid #d1d1d1;border-bottom:1px solid #d1d1d1}#translate-btn{display:none;position:absolute;z-index:9999999999;left:0;top:0}#translate-btn .bp5-button{padding:2px;min-width:0;min-height:0}#translate-btn .btn-icon{width:18px;height:18px;background-image:url(moz-extension://72d6ca68-5609-1440-b1ba-15daf8cbdb2d/logo.png);background-size:contain}.bp5-dark #translate-btn .btn-icon{background-image:url(moz-extension://72d6ca68-5609-1440-b1ba-15daf8cbdb2d/logowhite36.png)}#translate-btn.show{display:block}.translate-type-selector .bp5-label{display:inline}.translate-type-selector .bp5-radio{margin-bottom:0}#ocr-container{position:fixed;z-index:99999999999999;left:0;top:0;right:0;bottom:0}#ocr-container .toolbar{display:none;position:absolute;z-index:1}#ocr-container img{max-width:100%}#app{cursor:default}.switch-pin{flex-shrink:0;cursor:pointer}.switch-pin .bp5-icon-pin{transition:transform .2s,color .2s;transform:rotate(-45deg)}.pin .switch-pin .bp5-icon-pin{transform:rotate(-70deg)}.cut-btn{margin-left:2px}.app-toaster-container{position:fixed!important;z-index:9999999999!important}.app-toaster-container .bp5-toast{min-width:auto}#web-trs-panel .app-toaster-container{padding-right:0;padding-left:0}#web-trs-panel .page-trs-form-group{margin:0 0 0 0;align-items:center}#web-trs-panel .page-trs-form-group>label{width:70px}</style><div id=root dir=ltr class=bp5-dark><div id=app class=bp5-dark><div id=translate-btn class=sf-hidden></div><div id=popper-container style=width:250px;transform:translate(0px) class=bp5-elevation-4><div id=translate-panel class=size-small><div class=fixed><div class=header><div class=left><div class=switch-pin><button type=button class="bp5-button bp5-minimal bp5-small"><span aria-hidden=true class="bp5-icon bp5-icon-pin"><svg data-icon=pin height=14 role=img viewBox="0 0 16 16" width=14><path d="M9.41.92c-.51.51-.41 1.5.15 2.56L4.34 7.54C2.8 6.48 1.45 6.05.92 6.58l3.54 3.54-3.54 4.95 4.95-3.54 3.54 3.54c.53-.53.1-1.88-.96-3.42l4.06-5.22c1.06.56 2.04.66 2.55.15L9.41.92z" fill-rule=evenodd></path></svg></span></button></div><button type=button class="bp5-button bp5-minimal bp5-small cut-btn" title=截图翻译><span aria-hidden=true class="bp5-icon bp5-icon-cut"><svg data-icon=cut height=14 role=img viewBox="0 0 16 16" width=14><path d="M13 2s.71-1.29 0-2L8.66 5.07l1.05 1.32L13 2zm.07 8c-.42 0-.82.09-1.18.26L3.31 0c-.69.71 0 2 0 2l3.68 5.02-2.77 3.24A2.996 2.996 0 000 13c0 1.66 1.34 3 3 3s3-1.34 3-3c0-.46-.11-.89-.29-1.27L8.1 8.54l2.33 3.19c-.18.39-.29.82-.29 1.27 0 1.66 1.31 3 2.93 3S16 14.66 16 13s-1.31-3-2.93-3zM3 14c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm10.07 0c-.54 0-.98-.45-.98-1s.44-1 .98-1 .98.45.98 1-.44 1-.98 1z" fill-rule=evenodd></path></svg></span></button><button type=button class="bp5-button bp5-minimal bp5-small cut-btn" title=网页全文翻译><span aria-hidden=true class="bp5-icon bp5-icon-translate"><svg data-icon=translate height=14 role=img viewBox="0 0 16 16" width=14><path d="M15.89 14.56l-3.99-8h-.01c-.17-.33-.5-.56-.89-.56s-.72.23-.89.56h-.01L9 8.76 7.17 7.38l.23-.18C8.37 6.47 9 5.31 9 4V3h1c.55 0 1-.45 1-1s-.45-1-1-1H7c0-.55-.45-1-1-1H5c-.55 0-1 .45-1 1H1c-.55 0-1 .45-1 1s.45 1 1 1h6v1c0 .66-.32 1.25-.82 1.61l-.68.51-.68-.5C4.32 5.25 4 4.66 4 4H2c0 1.31.63 2.47 1.6 3.2l.23.17L1.4 9.2l.01.01C1.17 9.4 1 9.67 1 10c0 .55.45 1 1 1 .23 0 .42-.09.59-.21l.01.01 2.9-2.17 2.6 1.95-1.99 3.98h.01c-.07.13-.12.28-.12.44 0 .55.45 1 1 1 .39 0 .72-.23.89-.56h.01L8.62 14h4.76l.72 1.45h.01c.17.32.5.55.89.55.55 0 1-.45 1-1 0-.16-.05-.31-.11-.44zM9.62 12L11 9.24 12.38 12H9.62z" fill-rule=evenodd></path></svg></span></button><button type=button class="bp5-button bp5-minimal bp5-small cut-btn" title=音视频翻译 style=margin-right:2px><span aria-hidden=true class="bp5-icon bp5-icon-video"><svg data-icon=video height=14 role=img viewBox="0 0 16 16" width=14><path d="M15 2H1c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h14c.55 0 1-.45 1-1V3c0-.55-.45-1-1-1zM5 11V5l6 3-6 3z" fill-rule=evenodd></path></svg></span></button><button type=button title=图片翻译 class="bp5-button bp5-minimal bp5-small"><span aria-hidden=true class="bp5-icon bp5-icon-media"><svg data-icon=media height=14 role=img viewBox="0 0 16 16" width=14><path d="M11.99 6.99c.55 0 1-.45 1-1s-.45-1-1-1-1 .45-1 1 .45 1 1 1zm3-5h-14c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h14c.55 0 1-.45 1-1v-10c0-.55-.45-1-1-1zm-1 9l-5-3-1 2-3-4-3 5v-7h12v7z" fill-rule=evenodd></path></svg></span></button><button type=button title=语音翻译 class="bp5-button bp5-minimal bp5-small"><span class=bp5-icon><svg version=1.1 id=Capa_1 width=14 height=14 xmlns=http://www.w3.org/2000/svg xmlns:xlink=http://www.w3.org/1999/xlink x=0px y=0px viewBox="0 0 490.9 490.9" xml:space=preserve><g><g><path d="M245.5,322.9c53,0,96.2-43.2,96.2-96.2V96.2c0-53-43.2-96.2-96.2-96.2s-96.2,43.2-96.2,96.2v130.5 C149.3,279.8,192.5,322.9,245.5,322.9z M173.8,96.2c0-39.5,32.2-71.7,71.7-71.7s71.7,32.2,71.7,71.7v130.5 c0,39.5-32.2,71.7-71.7,71.7s-71.7-32.2-71.7-71.7V96.2z"></path><path d="M94.4,214.5c-6.8,0-12.3,5.5-12.3,12.3c0,85.9,66.7,156.6,151.1,162.8v76.7h-63.9c-6.8,0-12.3,5.5-12.3,12.3 s5.5,12.3,12.3,12.3h152.3c6.8,0,12.3-5.5,12.3-12.3s-5.5-12.3-12.3-12.3h-63.9v-76.7c84.4-6.3,151.1-76.9,151.1-162.8 c0-6.8-5.5-12.3-12.3-12.3s-12.3,5.5-12.3,12.3c0,76.6-62.3,138.9-138.9,138.9s-138.9-62.3-138.9-138.9 C106.6,220,101.2,214.5,94.4,214.5z"></path></g></g></svg></span></button></div><div class=drag-block title=按住不放可以拖动></div><div class=right><button type=button disabled title=添加到收藏夹 class="bp5-button bp5-disabled bp5-minimal bp5-small" tabindex=-1><span aria-hidden=true class="bp5-icon bp5-icon-star-empty"><svg data-icon=star-empty height=14 role=img viewBox="0 0 16 16" width=14><path d="M16 6.11l-5.53-.84L8 0 5.53 5.27 0 6.11l4 4.1L3.06 16 8 13.27 12.94 16 12 10.21l4-4.1zM4.91 13.2l.59-3.62L3 7.02l3.45-.53L8 3.2l1.55 3.29 3.45.53-2.5 2.56.59 3.62L8 11.49 4.91 13.2z" fill-rule=evenodd></path></svg></span></button><button type=button class="bp5-button bp5-minimal bp5-small settings" title=快捷设置><span aria-hidden=true class="bp5-icon bp5-icon-cog"><svg data-icon=cog height=14 role=img viewBox="0 0 16 16" width=14><path d="M15.19 6.39h-1.85c-.11-.37-.27-.71-.45-1.04l1.36-1.36c.31-.31.31-.82 0-1.13l-1.13-1.13a.803.803 0 00-1.13 0l-1.36 1.36c-.33-.17-.67-.33-1.04-.44V.79c0-.44-.36-.8-.8-.8h-1.6c-.44 0-.8.36-.8.8v1.86c-.39.12-.75.28-1.1.47l-1.3-1.3c-.3-.3-.79-.3-1.09 0L1.82 2.91c-.3.3-.3.79 0 1.09l1.3 1.3c-.2.34-.36.7-.48 1.09H.79c-.44 0-.8.36-.8.8v1.6c0 .44.36.8.8.8h1.85c.11.37.27.71.45 1.04l-1.36 1.36c-.31.31-.31.82 0 1.13l1.13 1.13c.31.31.82.31 1.13 0l1.36-1.36c.33.18.67.33 1.04.44v1.86c0 .44.36.8.8.8h1.6c.44 0 .8-.36.8-.8v-1.86c.39-.12.75-.28 1.1-.47l1.3 1.3c.3.3.79.3 1.09 0l1.09-1.09c.3-.3.3-.79 0-1.09l-1.3-1.3c.19-.35.36-.71.48-1.1h1.85c.44 0 .8-.36.8-.8v-1.6a.816.816 0 00-.81-.79zm-7.2 4.6c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3z" fill-rule=evenodd></path></svg></span></button><button type=button title=关闭(Esc) class="bp5-button bp5-minimal bp5-small"><span aria-hidden=true class="bp5-icon bp5-icon-cross"><svg data-icon=cross height=18 role=img viewBox="0 0 16 16" width=18><path d="M9.41 8l3.29-3.29c.19-.18.3-.43.3-.71a1.003 1.003 0 00-1.71-.71L8 6.59l-3.29-3.3a1.003 1.003 0 00-1.42 1.42L6.59 8 3.3 11.29c-.19.18-.3.43-.3.71a1.003 1.003 0 001.71.71L8 9.41l3.29 3.29c.18.19.43.3.71.3a1.003 1.003 0 00.71-1.71L9.41 8z" fill-rule=evenodd></path></svg></span></button></div></div><div class=bp5-collapse><div class="bp5-collapse-body sf-hidden" aria-hidden=true></div></div></div><div class=body><p>请输入需要翻译的文本。</p></div></div><div class="arrow sf-hidden"></div></div><div id=web-trs-panel></div></div></div></template></div></div><script data-template-shadow-root>(()=>{document.currentScript.remove();processNode(document);function processNode(node){node.querySelectorAll("template[shadowrootmode]").forEach(element=>{let shadowRoot = element.parentElement.shadowRoot;if (!shadowRoot) {try {shadowRoot=element.parentElement.attachShadow({mode:element.getAttribute("shadowrootmode"),delegatesFocus:element.getAttribute("shadowrootdelegatesfocus")!=null,clonable:element.getAttribute("shadowrootclonable")!=null,serializable:element.getAttribute("shadowrootserializable)!=null});shadowRoot.innerHTML=element.innerHTML;element.remove()} catch (error) {} if (shadowRoot) {processNode(shadowRoot)}}})}})()</script>